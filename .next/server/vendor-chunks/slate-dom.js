"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slate-dom";
exports.ids = ["vendor-chunks/slate-dom"];
exports.modules = {

/***/ "(ssr)/./node_modules/slate-dom/dist/index.es.js":
/*!*************************************************!*\
  !*** ./node_modules/slate-dom/dist/index.es.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CAN_USE_DOM: () => (/* binding */ CAN_USE_DOM),\n/* harmony export */   DOMEditor: () => (/* binding */ DOMEditor),\n/* harmony export */   DOMElement: () => (/* binding */ DOMElement),\n/* harmony export */   DOMNode: () => (/* binding */ DOMNode),\n/* harmony export */   DOMRange: () => (/* binding */ DOMRange),\n/* harmony export */   DOMSelection: () => (/* binding */ DOMSelection),\n/* harmony export */   DOMStaticRange: () => (/* binding */ DOMStaticRange),\n/* harmony export */   DOMText: () => (/* binding */ DOMText),\n/* harmony export */   EDITOR_TO_ELEMENT: () => (/* binding */ EDITOR_TO_ELEMENT),\n/* harmony export */   EDITOR_TO_FORCE_RENDER: () => (/* binding */ EDITOR_TO_FORCE_RENDER),\n/* harmony export */   EDITOR_TO_KEY_TO_ELEMENT: () => (/* binding */ EDITOR_TO_KEY_TO_ELEMENT),\n/* harmony export */   EDITOR_TO_ON_CHANGE: () => (/* binding */ EDITOR_TO_ON_CHANGE),\n/* harmony export */   EDITOR_TO_PENDING_ACTION: () => (/* binding */ EDITOR_TO_PENDING_ACTION),\n/* harmony export */   EDITOR_TO_PENDING_DIFFS: () => (/* binding */ EDITOR_TO_PENDING_DIFFS),\n/* harmony export */   EDITOR_TO_PENDING_INSERTION_MARKS: () => (/* binding */ EDITOR_TO_PENDING_INSERTION_MARKS),\n/* harmony export */   EDITOR_TO_PENDING_SELECTION: () => (/* binding */ EDITOR_TO_PENDING_SELECTION),\n/* harmony export */   EDITOR_TO_PLACEHOLDER_ELEMENT: () => (/* binding */ EDITOR_TO_PLACEHOLDER_ELEMENT),\n/* harmony export */   EDITOR_TO_SCHEDULE_FLUSH: () => (/* binding */ EDITOR_TO_SCHEDULE_FLUSH),\n/* harmony export */   EDITOR_TO_USER_MARKS: () => (/* binding */ EDITOR_TO_USER_MARKS),\n/* harmony export */   EDITOR_TO_USER_SELECTION: () => (/* binding */ EDITOR_TO_USER_SELECTION),\n/* harmony export */   EDITOR_TO_WINDOW: () => (/* binding */ EDITOR_TO_WINDOW),\n/* harmony export */   ELEMENT_TO_NODE: () => (/* binding */ ELEMENT_TO_NODE),\n/* harmony export */   HAS_BEFORE_INPUT_SUPPORT: () => (/* binding */ HAS_BEFORE_INPUT_SUPPORT),\n/* harmony export */   Hotkeys: () => (/* binding */ hotkeys),\n/* harmony export */   IS_ANDROID: () => (/* binding */ IS_ANDROID),\n/* harmony export */   IS_CHROME: () => (/* binding */ IS_CHROME),\n/* harmony export */   IS_COMPOSING: () => (/* binding */ IS_COMPOSING),\n/* harmony export */   IS_FIREFOX: () => (/* binding */ IS_FIREFOX),\n/* harmony export */   IS_FIREFOX_LEGACY: () => (/* binding */ IS_FIREFOX_LEGACY),\n/* harmony export */   IS_FOCUSED: () => (/* binding */ IS_FOCUSED),\n/* harmony export */   IS_IOS: () => (/* binding */ IS_IOS),\n/* harmony export */   IS_NODE_MAP_DIRTY: () => (/* binding */ IS_NODE_MAP_DIRTY),\n/* harmony export */   IS_READ_ONLY: () => (/* binding */ IS_READ_ONLY),\n/* harmony export */   IS_UC_MOBILE: () => (/* binding */ IS_UC_MOBILE),\n/* harmony export */   IS_WEBKIT: () => (/* binding */ IS_WEBKIT),\n/* harmony export */   IS_WECHATBROWSER: () => (/* binding */ IS_WECHATBROWSER),\n/* harmony export */   Key: () => (/* binding */ Key),\n/* harmony export */   MARK_PLACEHOLDER_SYMBOL: () => (/* binding */ MARK_PLACEHOLDER_SYMBOL),\n/* harmony export */   NODE_TO_ELEMENT: () => (/* binding */ NODE_TO_ELEMENT),\n/* harmony export */   NODE_TO_INDEX: () => (/* binding */ NODE_TO_INDEX),\n/* harmony export */   NODE_TO_KEY: () => (/* binding */ NODE_TO_KEY),\n/* harmony export */   NODE_TO_PARENT: () => (/* binding */ NODE_TO_PARENT),\n/* harmony export */   PLACEHOLDER_SYMBOL: () => (/* binding */ PLACEHOLDER_SYMBOL),\n/* harmony export */   TRIPLE_CLICK: () => (/* binding */ TRIPLE_CLICK),\n/* harmony export */   applyStringDiff: () => (/* binding */ applyStringDiff),\n/* harmony export */   getActiveElement: () => (/* binding */ getActiveElement),\n/* harmony export */   getDefaultView: () => (/* binding */ getDefaultView),\n/* harmony export */   getSelection: () => (/* binding */ getSelection),\n/* harmony export */   hasShadowRoot: () => (/* binding */ hasShadowRoot),\n/* harmony export */   isAfter: () => (/* binding */ isAfter),\n/* harmony export */   isBefore: () => (/* binding */ isBefore),\n/* harmony export */   isDOMElement: () => (/* binding */ isDOMElement),\n/* harmony export */   isDOMNode: () => (/* binding */ isDOMNode),\n/* harmony export */   isDOMSelection: () => (/* binding */ isDOMSelection),\n/* harmony export */   isElementDecorationsEqual: () => (/* binding */ isElementDecorationsEqual),\n/* harmony export */   isPlainTextOnlyPaste: () => (/* binding */ isPlainTextOnlyPaste),\n/* harmony export */   isTextDecorationsEqual: () => (/* binding */ isTextDecorationsEqual),\n/* harmony export */   isTrackedMutation: () => (/* binding */ isTrackedMutation),\n/* harmony export */   mergeStringDiffs: () => (/* binding */ mergeStringDiffs),\n/* harmony export */   normalizeDOMPoint: () => (/* binding */ normalizeDOMPoint),\n/* harmony export */   normalizePoint: () => (/* binding */ normalizePoint),\n/* harmony export */   normalizeRange: () => (/* binding */ normalizeRange),\n/* harmony export */   normalizeStringDiff: () => (/* binding */ normalizeStringDiff),\n/* harmony export */   targetRange: () => (/* binding */ targetRange),\n/* harmony export */   verifyDiffState: () => (/* binding */ verifyDiffState),\n/* harmony export */   withDOM: () => (/* binding */ withDOM)\n/* harmony export */ });\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var is_hotkey__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-hotkey */ \"(ssr)/./node_modules/is-hotkey/lib/index.js\");\n\n\n\n/**\n * Types.\n */\n// COMPAT: This is required to prevent TypeScript aliases from doing some very\n// weird things for Slate's types with the same name as globals. (2019/11/27)\n// https://github.com/microsoft/TypeScript/issues/35002\nvar DOMNode = globalThis.Node;\nvar DOMElement = globalThis.Element;\nvar DOMText = globalThis.Text;\nvar DOMRange = globalThis.Range;\nvar DOMSelection = globalThis.Selection;\nvar DOMStaticRange = globalThis.StaticRange;\n/**\n * Returns the host window of a DOM node\n */\nvar getDefaultView = value => {\n  return value && value.ownerDocument && value.ownerDocument.defaultView || null;\n};\n/**\n * Check if a DOM node is a comment node.\n */\nvar isDOMComment = value => {\n  return isDOMNode(value) && value.nodeType === 8;\n};\n/**\n * Check if a DOM node is an element node.\n */\nvar isDOMElement = value => {\n  return isDOMNode(value) && value.nodeType === 1;\n};\n/**\n * Check if a value is a DOM node.\n */\nvar isDOMNode = value => {\n  var window = getDefaultView(value);\n  return !!window && value instanceof window.Node;\n};\n/**\n * Check if a value is a DOM selection.\n */\nvar isDOMSelection = value => {\n  var window = value && value.anchorNode && getDefaultView(value.anchorNode);\n  return !!window && value instanceof window.Selection;\n};\n/**\n * Check if a DOM node is an element node.\n */\nvar isDOMText = value => {\n  return isDOMNode(value) && value.nodeType === 3;\n};\n/**\n * Checks whether a paste event is a plaintext-only event.\n */\nvar isPlainTextOnlyPaste = event => {\n  return event.clipboardData && event.clipboardData.getData('text/plain') !== '' && event.clipboardData.types.length === 1;\n};\n/**\n * Normalize a DOM point so that it always refers to a text node.\n */\nvar normalizeDOMPoint = domPoint => {\n  var [node, offset] = domPoint;\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (isDOMElement(node) && node.childNodes.length) {\n    var isLast = offset === node.childNodes.length;\n    var index = isLast ? offset - 1 : offset;\n    [node, index] = getEditableChildAndIndex(node, index, isLast ? 'backward' : 'forward');\n    // If the editable child found is in front of input offset, we instead seek to its end\n    isLast = index < offset;\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (isDOMElement(node) && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i, isLast ? 'backward' : 'forward');\n    }\n    // Determine the new offset inside the text node.\n    offset = isLast && node.textContent != null ? node.textContent.length : 0;\n  }\n  // Return the node and offset.\n  return [node, offset];\n};\n/**\n * Determines whether the active element is nested within a shadowRoot\n */\nvar hasShadowRoot = node => {\n  var parent = node && node.parentNode;\n  while (parent) {\n    if (parent.toString() === '[object ShadowRoot]') {\n      return true;\n    }\n    parent = parent.parentNode;\n  }\n  return false;\n};\n/**\n * Get the nearest editable child and index at `index` in a `parent`, preferring\n * `direction`.\n */\nvar getEditableChildAndIndex = (parent, index, direction) => {\n  var {\n    childNodes\n  } = parent;\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false;\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute('contenteditable') === 'false') {\n    if (triedForward && triedBackward) {\n      break;\n    }\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n    child = childNodes[i];\n    index = i;\n    i += direction === 'forward' ? 1 : -1;\n  }\n  return [child, index];\n};\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n */\nvar getEditableChild = (parent, index, direction) => {\n  var [child] = getEditableChildAndIndex(parent, index, direction);\n  return child;\n};\n/**\n * Get a plaintext representation of the content of a node, accounting for block\n * elements which get a newline appended.\n *\n * The domNode must be attached to the DOM.\n */\nvar getPlainText = domNode => {\n  var text = '';\n  if (isDOMText(domNode) && domNode.nodeValue) {\n    return domNode.nodeValue;\n  }\n  if (isDOMElement(domNode)) {\n    for (var childNode of Array.from(domNode.childNodes)) {\n      text += getPlainText(childNode);\n    }\n    var display = getComputedStyle(domNode).getPropertyValue('display');\n    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {\n      text += '\\n';\n    }\n  }\n  return text;\n};\n/**\n * Get x-slate-fragment attribute from data-slate-fragment\n */\nvar catchSlateFragment = /data-slate-fragment=\"(.+?)\"/m;\nvar getSlateFragmentAttribute = dataTransfer => {\n  var htmlData = dataTransfer.getData('text/html');\n  var [, fragment] = htmlData.match(catchSlateFragment) || [];\n  return fragment;\n};\n/**\n * Get the dom selection from Shadow Root if possible, otherwise from the document\n */\nvar getSelection = root => {\n  if (root.getSelection != null) {\n    return root.getSelection();\n  }\n  return document.getSelection();\n};\n/**\n * Check whether a mutation originates from a editable element inside the editor.\n */\nvar isTrackedMutation = (editor, mutation, batch) => {\n  var {\n    target\n  } = mutation;\n  if (isDOMElement(target) && target.matches('[contentEditable=\"false\"]')) {\n    return false;\n  }\n  var {\n    document\n  } = DOMEditor.getWindow(editor);\n  if (document.contains(target)) {\n    return DOMEditor.hasDOMNode(editor, target, {\n      editable: true\n    });\n  }\n  var parentMutation = batch.find(_ref => {\n    var {\n      addedNodes,\n      removedNodes\n    } = _ref;\n    for (var node of addedNodes) {\n      if (node === target || node.contains(target)) {\n        return true;\n      }\n    }\n    for (var _node of removedNodes) {\n      if (_node === target || _node.contains(target)) {\n        return true;\n      }\n    }\n  });\n  if (!parentMutation || parentMutation === mutation) {\n    return false;\n  }\n  // Target add/remove is tracked. Track the mutation if we track the parent mutation.\n  return isTrackedMutation(editor, parentMutation, batch);\n};\n/**\n * Retrieves the deepest active element in the DOM, considering nested shadow DOMs.\n */\nvar getActiveElement = () => {\n  var activeElement = document.activeElement;\n  while ((_activeElement = activeElement) !== null && _activeElement !== void 0 && _activeElement.shadowRoot && (_activeElement$shadow = activeElement.shadowRoot) !== null && _activeElement$shadow !== void 0 && _activeElement$shadow.activeElement) {\n    var _activeElement, _activeElement$shadow, _activeElement2;\n    activeElement = (_activeElement2 = activeElement) === null || _activeElement2 === void 0 || (_activeElement2 = _activeElement2.shadowRoot) === null || _activeElement2 === void 0 ? void 0 : _activeElement2.activeElement;\n  }\n  return activeElement;\n};\n/**\n * @returns `true` if `otherNode` is before `node` in the document; otherwise, `false`.\n */\nvar isBefore = (node, otherNode) => Boolean(node.compareDocumentPosition(otherNode) & DOMNode.DOCUMENT_POSITION_PRECEDING);\n/**\n * @returns `true` if `otherNode` is after `node` in the document; otherwise, `false`.\n */\nvar isAfter = (node, otherNode) => Boolean(node.compareDocumentPosition(otherNode) & DOMNode.DOCUMENT_POSITION_FOLLOWING);\n\nvar _navigator$userAgent$, _navigator$userAgent$2;\nvar IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nvar IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent);\nvar IS_ANDROID = typeof navigator !== 'undefined' && /Android/.test(navigator.userAgent);\nvar IS_FIREFOX = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nvar IS_WEBKIT = typeof navigator !== 'undefined' && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent);\n// \"modern\" Edge was released at 79.x\nvar IS_EDGE_LEGACY = typeof navigator !== 'undefined' && /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent);\nvar IS_CHROME = typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent);\n// Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\nvar IS_CHROME_LEGACY = typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent);\nvar IS_ANDROID_CHROME_LEGACY = IS_ANDROID && typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-5]?\\d)(?:\\.)/i.test(navigator.userAgent);\n// Firefox did not support `beforeInput` until `v87`.\nvar IS_FIREFOX_LEGACY = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(navigator.userAgent);\n// UC mobile browser\nvar IS_UC_MOBILE = typeof navigator !== 'undefined' && /.*UCBrowser/.test(navigator.userAgent);\n// Wechat browser (not including mac wechat)\nvar IS_WECHATBROWSER = typeof navigator !== 'undefined' && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent); // avoid lookbehind (buggy in safari < 16.4)\n// Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nvar CAN_USE_DOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n// Check if the browser is Safari and older than 17\ntypeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && /Version\\/(\\d+)/.test(navigator.userAgent) && ((_navigator$userAgent$ = navigator.userAgent.match(/Version\\/(\\d+)/)) !== null && _navigator$userAgent$ !== void 0 && _navigator$userAgent$[1] ? parseInt((_navigator$userAgent$2 = navigator.userAgent.match(/Version\\/(\\d+)/)) === null || _navigator$userAgent$2 === void 0 ? void 0 : _navigator$userAgent$2[1], 10) < 17 : false);\n// COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\nvar HAS_BEFORE_INPUT_SUPPORT = (!IS_CHROME_LEGACY || !IS_ANDROID_CHROME_LEGACY) && !IS_EDGE_LEGACY &&\n// globalThis is undefined in older browsers\ntypeof globalThis !== 'undefined' && globalThis.InputEvent &&\n// @ts-ignore The `getTargetRanges` property isn't recognized.\ntypeof globalThis.InputEvent.prototype.getTargetRanges === 'function';\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * An auto-incrementing identifier for keys.\n */\nvar n = 0;\n/**\n * A class that keeps track of a key string. We use a full class here because we\n * want to be able to use them as keys in `WeakMap` objects.\n */\nclass Key {\n  constructor() {\n    _defineProperty(this, \"id\", void 0);\n    this.id = \"\".concat(n++);\n  }\n}\n\n/**\n * Two weak maps that allow us rebuild a path given a node. They are populated\n * at render time such that after a render occurs we can always backtrack.\n */\nvar IS_NODE_MAP_DIRTY = new WeakMap();\nvar NODE_TO_INDEX = new WeakMap();\nvar NODE_TO_PARENT = new WeakMap();\n/**\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\n * are used to resolve DOM event-related logic into Slate actions.\n */\nvar EDITOR_TO_WINDOW = new WeakMap();\nvar EDITOR_TO_ELEMENT = new WeakMap();\nvar EDITOR_TO_PLACEHOLDER_ELEMENT = new WeakMap();\nvar ELEMENT_TO_NODE = new WeakMap();\nvar NODE_TO_ELEMENT = new WeakMap();\nvar NODE_TO_KEY = new WeakMap();\nvar EDITOR_TO_KEY_TO_ELEMENT = new WeakMap();\n/**\n * Weak maps for storing editor-related state.\n */\nvar IS_READ_ONLY = new WeakMap();\nvar IS_FOCUSED = new WeakMap();\nvar IS_COMPOSING = new WeakMap();\nvar EDITOR_TO_USER_SELECTION = new WeakMap();\n/**\n * Weak map for associating the context `onChange` context with the plugin.\n */\nvar EDITOR_TO_ON_CHANGE = new WeakMap();\n/**\n * Weak maps for saving pending state on composition stage.\n */\nvar EDITOR_TO_SCHEDULE_FLUSH = new WeakMap();\nvar EDITOR_TO_PENDING_INSERTION_MARKS = new WeakMap();\nvar EDITOR_TO_USER_MARKS = new WeakMap();\n/**\n * Android input handling specific weak-maps\n */\nvar EDITOR_TO_PENDING_DIFFS = new WeakMap();\nvar EDITOR_TO_PENDING_ACTION = new WeakMap();\nvar EDITOR_TO_PENDING_SELECTION = new WeakMap();\nvar EDITOR_TO_FORCE_RENDER = new WeakMap();\n/**\n * Symbols.\n */\nvar PLACEHOLDER_SYMBOL = Symbol('placeholder');\nvar MARK_PLACEHOLDER_SYMBOL = Symbol('mark-placeholder');\n\n// eslint-disable-next-line no-redeclare\nvar DOMEditor = {\n  androidPendingDiffs: editor => EDITOR_TO_PENDING_DIFFS.get(editor),\n  androidScheduleFlush: editor => {\n    var _EDITOR_TO_SCHEDULE_F;\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 || _EDITOR_TO_SCHEDULE_F();\n  },\n  blur: editor => {\n    var el = DOMEditor.toDOMNode(editor, editor);\n    var root = DOMEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, false);\n    if (root.activeElement === el) {\n      el.blur();\n    }\n  },\n  deselect: editor => {\n    var {\n      selection\n    } = editor;\n    var root = DOMEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = getSelection(root);\n    if (domSelection && domSelection.rangeCount > 0) {\n      domSelection.removeAllRanges();\n    }\n    if (selection) {\n      slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.deselect(editor);\n    }\n  },\n  findDocumentOrShadowRoot: editor => {\n    var el = DOMEditor.toDOMNode(editor, editor);\n    var root = el.getRootNode();\n    if (root instanceof Document || root instanceof ShadowRoot) {\n      return root;\n    }\n    return el.ownerDocument;\n  },\n  findEventRange: (editor, event) => {\n    if ('nativeEvent' in event) {\n      event = event.nativeEvent;\n    }\n    var {\n      clientX: x,\n      clientY: y,\n      target\n    } = event;\n    if (x == null || y == null) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n    var node = DOMEditor.toSlateNode(editor, event.target);\n    var path = DOMEditor.findPath(editor, node);\n    // If the drop target is inside a void node, move it into either the\n    // next or previous node, depending on which side the `x` and `y`\n    // coordinates are closest to.\n    if (slate__WEBPACK_IMPORTED_MODULE_1__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isVoid(editor, node)) {\n      var rect = target.getBoundingClientRect();\n      var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n      var edge = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.point(editor, path, {\n        edge: isPrev ? 'start' : 'end'\n      });\n      var point = isPrev ? slate__WEBPACK_IMPORTED_MODULE_1__.Editor.before(editor, edge) : slate__WEBPACK_IMPORTED_MODULE_1__.Editor.after(editor, edge);\n      if (point) {\n        var _range = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, point);\n        return _range;\n      }\n    }\n    // Else resolve a range from the caret position where the drop occured.\n    var domRange;\n    var {\n      document\n    } = DOMEditor.getWindow(editor);\n    // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n    if (document.caretRangeFromPoint) {\n      domRange = document.caretRangeFromPoint(x, y);\n    } else {\n      var position = document.caretPositionFromPoint(x, y);\n      if (position) {\n        domRange = document.createRange();\n        domRange.setStart(position.offsetNode, position.offset);\n        domRange.setEnd(position.offsetNode, position.offset);\n      }\n    }\n    if (!domRange) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n    // Resolve a Slate range from the DOM range.\n    var range = DOMEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      suppressThrow: false\n    });\n    return range;\n  },\n  findKey: (editor, node) => {\n    var key = NODE_TO_KEY.get(node);\n    if (!key) {\n      key = new Key();\n      NODE_TO_KEY.set(node, key);\n    }\n    return key;\n  },\n  findPath: (editor, node) => {\n    var path = [];\n    var child = node;\n    while (true) {\n      var parent = NODE_TO_PARENT.get(child);\n      if (parent == null) {\n        if (slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isEditor(child)) {\n          return path;\n        } else {\n          break;\n        }\n      }\n      var i = NODE_TO_INDEX.get(child);\n      if (i == null) {\n        break;\n      }\n      path.unshift(i);\n      child = parent;\n    }\n    throw new Error(\"Unable to find the path for Slate node: \".concat(slate__WEBPACK_IMPORTED_MODULE_1__.Scrubber.stringify(node)));\n  },\n  focus: function focus(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      retries: 5\n    };\n    // Return if already focused\n    if (IS_FOCUSED.get(editor)) {\n      return;\n    }\n    // Retry setting focus if the editor has pending operations.\n    // The DOM (selection) is unstable while changes are applied.\n    // Retry until retries are exhausted or editor is focused.\n    if (options.retries <= 0) {\n      throw new Error('Could not set focus, editor seems stuck with pending operations');\n    }\n    if (editor.operations.length > 0) {\n      setTimeout(() => {\n        DOMEditor.focus(editor, {\n          retries: options.retries - 1\n        });\n      }, 10);\n      return;\n    }\n    var el = DOMEditor.toDOMNode(editor, editor);\n    var root = DOMEditor.findDocumentOrShadowRoot(editor);\n    if (root.activeElement !== el) {\n      // Ensure that the DOM selection state is set to the editor's selection\n      if (editor.selection && root instanceof Document) {\n        var domSelection = getSelection(root);\n        var domRange = DOMEditor.toDOMRange(editor, editor.selection);\n        domSelection === null || domSelection === void 0 || domSelection.removeAllRanges();\n        domSelection === null || domSelection === void 0 || domSelection.addRange(domRange);\n      }\n      // Create a new selection in the top of the document if missing\n      if (!editor.selection) {\n        slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_1__.Editor.start(editor, []));\n      }\n      // IS_FOCUSED should be set before calling el.focus() to ensure that\n      // FocusedContext is updated to the correct value\n      IS_FOCUSED.set(editor, true);\n      el.focus({\n        preventScroll: true\n      });\n    }\n  },\n  getWindow: editor => {\n    var window = EDITOR_TO_WINDOW.get(editor);\n    if (!window) {\n      throw new Error('Unable to find a host window element for this editor');\n    }\n    return window;\n  },\n  hasDOMNode: function hasDOMNode(editor, target) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      editable = false\n    } = options;\n    var editorEl = DOMEditor.toDOMNode(editor, editor);\n    var targetEl;\n    // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n    try {\n      targetEl = isDOMElement(target) ? target : target.parentElement;\n    } catch (err) {\n      if (err instanceof Error && !err.message.includes('Permission denied to access property \"nodeType\"')) {\n        throw err;\n      }\n    }\n    if (!targetEl) {\n      return false;\n    }\n    return targetEl.closest(\"[data-slate-editor]\") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === 'boolean' &&\n    // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined\n    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable=\"false\"(readOnly)\n    targetEl.closest('[contenteditable=\"false\"]') === editorEl || !!targetEl.getAttribute('data-slate-zero-width'));\n  },\n  hasEditableTarget: (editor, target) => isDOMNode(target) && DOMEditor.hasDOMNode(editor, target, {\n    editable: true\n  }),\n  hasRange: (editor, range) => {\n    var {\n      anchor,\n      focus\n    } = range;\n    return slate__WEBPACK_IMPORTED_MODULE_1__.Editor.hasPath(editor, anchor.path) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.hasPath(editor, focus.path);\n  },\n  hasSelectableTarget: (editor, target) => DOMEditor.hasEditableTarget(editor, target) || DOMEditor.isTargetInsideNonReadonlyVoid(editor, target),\n  hasTarget: (editor, target) => isDOMNode(target) && DOMEditor.hasDOMNode(editor, target),\n  insertData: (editor, data) => {\n    editor.insertData(data);\n  },\n  insertFragmentData: (editor, data) => editor.insertFragmentData(data),\n  insertTextData: (editor, data) => editor.insertTextData(data),\n  isComposing: editor => {\n    return !!IS_COMPOSING.get(editor);\n  },\n  isFocused: editor => !!IS_FOCUSED.get(editor),\n  isReadOnly: editor => !!IS_READ_ONLY.get(editor),\n  isTargetInsideNonReadonlyVoid: (editor, target) => {\n    if (IS_READ_ONLY.get(editor)) return false;\n    var slateNode = DOMEditor.hasTarget(editor, target) && DOMEditor.toSlateNode(editor, target);\n    return slate__WEBPACK_IMPORTED_MODULE_1__.Element.isElement(slateNode) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isVoid(editor, slateNode);\n  },\n  setFragmentData: (editor, data, originEvent) => editor.setFragmentData(data, originEvent),\n  toDOMNode: (editor, node) => {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    var domNode = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(DOMEditor.findKey(editor, node));\n    if (!domNode) {\n      throw new Error(\"Cannot resolve a DOM node from Slate node: \".concat(slate__WEBPACK_IMPORTED_MODULE_1__.Scrubber.stringify(node)));\n    }\n    return domNode;\n  },\n  toDOMPoint: (editor, point) => {\n    var [node] = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.node(editor, point.path);\n    var el = DOMEditor.toDOMNode(editor, node);\n    var domPoint;\n    // If we're inside a void node, force the offset to 0, otherwise the zero\n    // width spacing character will result in an incorrect offset of 1\n    if (slate__WEBPACK_IMPORTED_MODULE_1__.Editor.void(editor, {\n      at: point\n    })) {\n      point = {\n        path: point.path,\n        offset: 0\n      };\n    }\n    // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n    var selector = \"[data-slate-string], [data-slate-zero-width]\";\n    var texts = Array.from(el.querySelectorAll(selector));\n    var start = 0;\n    for (var i = 0; i < texts.length; i++) {\n      var text = texts[i];\n      var domNode = text.childNodes[0];\n      if (domNode == null || domNode.textContent == null) {\n        continue;\n      }\n      var {\n        length\n      } = domNode.textContent;\n      var attr = text.getAttribute('data-slate-length');\n      var trueLength = attr == null ? length : parseInt(attr, 10);\n      var end = start + trueLength;\n      // Prefer putting the selection inside the mark placeholder to ensure\n      // composed text is displayed with the correct marks.\n      var nextText = texts[i + 1];\n      if (point.offset === end && nextText !== null && nextText !== void 0 && nextText.hasAttribute('data-slate-mark-placeholder')) {\n        var _nextText$textContent;\n        var domText = nextText.childNodes[0];\n        domPoint = [\n        // COMPAT: If we don't explicity set the dom point to be on the actual\n        // dom text element, chrome will put the selection behind the actual dom\n        // text element, causing domRange.getBoundingClientRect() calls on a collapsed\n        // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)\n        // which will cause issues when scrolling to it.\n        domText instanceof DOMText ? domText : nextText, (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith('\\uFEFF') ? 1 : 0];\n        break;\n      }\n      if (point.offset <= end) {\n        var offset = Math.min(length, Math.max(0, point.offset - start));\n        domPoint = [domNode, offset];\n        break;\n      }\n      start = end;\n    }\n    if (!domPoint) {\n      throw new Error(\"Cannot resolve a DOM point from Slate point: \".concat(slate__WEBPACK_IMPORTED_MODULE_1__.Scrubber.stringify(point)));\n    }\n    return domPoint;\n  },\n  toDOMRange: (editor, range) => {\n    var {\n      anchor,\n      focus\n    } = range;\n    var isBackward = slate__WEBPACK_IMPORTED_MODULE_1__.Range.isBackward(range);\n    var domAnchor = DOMEditor.toDOMPoint(editor, anchor);\n    var domFocus = slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(range) ? domAnchor : DOMEditor.toDOMPoint(editor, focus);\n    var window = DOMEditor.getWindow(editor);\n    var domRange = window.document.createRange();\n    var [startNode, startOffset] = isBackward ? domFocus : domAnchor;\n    var [endNode, endOffset] = isBackward ? domAnchor : domFocus;\n    // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n    // adjust the offset accordingly.\n    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;\n    var isStartAtZeroWidth = !!startEl.getAttribute('data-slate-zero-width');\n    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;\n    var isEndAtZeroWidth = !!endEl.getAttribute('data-slate-zero-width');\n    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);\n    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);\n    return domRange;\n  },\n  toSlateNode: (editor, domNode) => {\n    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;\n    if (domEl && !domEl.hasAttribute('data-slate-node')) {\n      domEl = domEl.closest(\"[data-slate-node]\");\n    }\n    var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;\n    if (!node) {\n      throw new Error(\"Cannot resolve a Slate node from DOM node: \".concat(domEl));\n    }\n    return node;\n  },\n  toSlatePoint: (editor, domPoint, options) => {\n    var {\n      exactMatch,\n      suppressThrow,\n      searchDirection = 'backward'\n    } = options;\n    var [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint);\n    var parentNode = nearestNode.parentNode;\n    var textNode = null;\n    var offset = 0;\n    if (parentNode) {\n      var _domNode$textContent, _domNode$textContent2;\n      var editorEl = DOMEditor.toDOMNode(editor, editor);\n      var potentialVoidNode = parentNode.closest('[data-slate-void=\"true\"]');\n      // Need to ensure that the closest void node is actually a void node\n      // within this editor, and not a void node within some parent editor. This can happen\n      // if this editor is within a void node of another editor (\"nested editors\", like in\n      // the \"Editable Voids\" example on the docs site).\n      var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;\n      var potentialNonEditableNode = parentNode.closest('[contenteditable=\"false\"]');\n      var nonEditableNode = potentialNonEditableNode && editorEl.contains(potentialNonEditableNode) ? potentialNonEditableNode : null;\n      var leafNode = parentNode.closest('[data-slate-leaf]');\n      var domNode = null;\n      // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n      if (leafNode) {\n        textNode = leafNode.closest('[data-slate-node=\"text\"]');\n        if (textNode) {\n          var window = DOMEditor.getWindow(editor);\n          var range = window.document.createRange();\n          range.setStart(textNode, 0);\n          range.setEnd(nearestNode, nearestOffset);\n          var contents = range.cloneContents();\n          var removals = [...Array.prototype.slice.call(contents.querySelectorAll('[data-slate-zero-width]')), ...Array.prototype.slice.call(contents.querySelectorAll('[contenteditable=false]'))];\n          removals.forEach(el => {\n            // COMPAT: While composing at the start of a text node, some keyboards put\n            // the text content inside the zero width space.\n            if (IS_ANDROID && !exactMatch && el.hasAttribute('data-slate-zero-width') && el.textContent.length > 0 && el.textContext !== '\\uFEFF') {\n              if (el.textContent.startsWith('\\uFEFF')) {\n                el.textContent = el.textContent.slice(1);\n              }\n              return;\n            }\n            el.parentNode.removeChild(el);\n          });\n          // COMPAT: Edge has a bug where Range.prototype.toString() will\n          // convert \\n into \\r\\n. The bug causes a loop when slate-dom\n          // attempts to reposition its cursor to match the native position. Use\n          // textContent.length instead.\n          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n          offset = contents.textContent.length;\n          domNode = textNode;\n        }\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent and taking the\n        // first one that isn't inside a nested editor.\n        var leafNodes = voidNode.querySelectorAll('[data-slate-leaf]');\n        for (var index = 0; index < leafNodes.length; index++) {\n          var current = leafNodes[index];\n          if (DOMEditor.hasDOMNode(editor, current)) {\n            leafNode = current;\n            break;\n          }\n        }\n        // COMPAT: In read-only editors the leaf is not rendered.\n        if (!leafNode) {\n          offset = 1;\n        } else {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]');\n          domNode = leafNode;\n          offset = domNode.textContent.length;\n          domNode.querySelectorAll('[data-slate-zero-width]').forEach(el => {\n            offset -= el.textContent.length;\n          });\n        }\n      } else if (nonEditableNode) {\n        // Find the edge of the nearest leaf in `searchDirection`\n        var getLeafNodes = node => node ? node.querySelectorAll(\n        // Exclude leaf nodes in nested editors\n        '[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])') : [];\n        var elementNode = nonEditableNode.closest('[data-slate-node=\"element\"]');\n        if (searchDirection === 'forward') {\n          var _leafNodes$find;\n          var _leafNodes = [...getLeafNodes(elementNode), ...getLeafNodes(elementNode === null || elementNode === void 0 ? void 0 : elementNode.nextElementSibling)];\n          leafNode = (_leafNodes$find = _leafNodes.find(leaf => isAfter(nonEditableNode, leaf))) !== null && _leafNodes$find !== void 0 ? _leafNodes$find : null;\n        } else {\n          var _leafNodes2$findLast;\n          var _leafNodes2 = [...getLeafNodes(elementNode === null || elementNode === void 0 ? void 0 : elementNode.previousElementSibling), ...getLeafNodes(elementNode)];\n          leafNode = (_leafNodes2$findLast = _leafNodes2.findLast(leaf => isBefore(nonEditableNode, leaf))) !== null && _leafNodes2$findLast !== void 0 ? _leafNodes2$findLast : null;\n        }\n        if (leafNode) {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]');\n          domNode = leafNode;\n          if (searchDirection === 'forward') {\n            offset = 0;\n          } else {\n            offset = domNode.textContent.length;\n            domNode.querySelectorAll('[data-slate-zero-width]').forEach(el => {\n              offset -= el.textContent.length;\n            });\n          }\n        }\n      }\n      if (domNode && offset === domNode.textContent.length &&\n      // COMPAT: Android IMEs might remove the zero width space while composing,\n      // and we don't add it for line-breaks.\n      IS_ANDROID && domNode.getAttribute('data-slate-zero-width') === 'z' && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith('\\uFEFF') && (\n      // COMPAT: If the parent node is a Slate zero-width space, editor is\n      // because the text node should have no characters. However, during IME\n      // composition the ASCII characters will be prepended to the zero-width\n      // space, so subtract 1 from the offset to account for the zero-width\n      // space character.\n      parentNode.hasAttribute('data-slate-zero-width') ||\n      // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\\n'\n      // when the document ends with a new-line character. This results in the offset\n      // length being off by one, so we need to subtract one to account for this.\n      IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith('\\n\\n'))) {\n        offset--;\n      }\n    }\n    if (IS_ANDROID && !textNode && !exactMatch) {\n      var node = parentNode.hasAttribute('data-slate-node') ? parentNode : parentNode.closest('[data-slate-node]');\n      if (node && DOMEditor.hasDOMNode(editor, node, {\n        editable: true\n      })) {\n        var _slateNode = DOMEditor.toSlateNode(editor, node);\n        var {\n          path: _path,\n          offset: _offset\n        } = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.start(editor, DOMEditor.findPath(editor, _slateNode));\n        if (!node.querySelector('[data-slate-leaf]')) {\n          _offset = nearestOffset;\n        }\n        return {\n          path: _path,\n          offset: _offset\n        };\n      }\n    }\n    if (!textNode) {\n      if (suppressThrow) {\n        return null;\n      }\n      throw new Error(\"Cannot resolve a Slate point from DOM point: \".concat(domPoint));\n    }\n    // COMPAT: If someone is clicking from one Slate editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n    var slateNode = DOMEditor.toSlateNode(editor, textNode);\n    var path = DOMEditor.findPath(editor, slateNode);\n    return {\n      path,\n      offset\n    };\n  },\n  toSlateRange: (editor, domRange, options) => {\n    var _focusNode$textConten;\n    var {\n      exactMatch,\n      suppressThrow\n    } = options;\n    var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;\n    var anchorNode;\n    var anchorOffset;\n    var focusNode;\n    var focusOffset;\n    var isCollapsed;\n    if (el) {\n      if (isDOMSelection(domRange)) {\n        // COMPAT: In firefox the normal seletion way does not work\n        // (https://github.com/ianstormtaylor/slate/pull/5486#issue-1820720223)\n        if (IS_FIREFOX && domRange.rangeCount > 1) {\n          focusNode = domRange.focusNode; // Focus node works fine\n          var firstRange = domRange.getRangeAt(0);\n          var lastRange = domRange.getRangeAt(domRange.rangeCount - 1);\n          // Here we are in the contenteditable mode of a table in firefox\n          if (focusNode instanceof HTMLTableRowElement && firstRange.startContainer instanceof HTMLTableRowElement && lastRange.startContainer instanceof HTMLTableRowElement) {\n            // HTMLElement, becouse Element is a slate element\n            function getLastChildren(element) {\n              if (element.childElementCount > 0) {\n                return getLastChildren(element.children[0]);\n              } else {\n                return element;\n              }\n            }\n            var firstNodeRow = firstRange.startContainer;\n            var lastNodeRow = lastRange.startContainer;\n            // This should never fail as \"The HTMLElement interface represents any HTML element.\"\n            var firstNode = getLastChildren(firstNodeRow.children[firstRange.startOffset]);\n            var lastNode = getLastChildren(lastNodeRow.children[lastRange.startOffset]);\n            // Zero, as we allways take the right one as the anchor point\n            focusOffset = 0;\n            if (lastNode.childNodes.length > 0) {\n              anchorNode = lastNode.childNodes[0];\n            } else {\n              anchorNode = lastNode;\n            }\n            if (firstNode.childNodes.length > 0) {\n              focusNode = firstNode.childNodes[0];\n            } else {\n              focusNode = firstNode;\n            }\n            if (lastNode instanceof HTMLElement) {\n              anchorOffset = lastNode.innerHTML.length;\n            } else {\n              // Fallback option\n              anchorOffset = 0;\n            }\n          } else {\n            // This is the read only mode of a firefox table\n            // Right to left\n            if (firstRange.startContainer === focusNode) {\n              anchorNode = lastRange.endContainer;\n              anchorOffset = lastRange.endOffset;\n              focusOffset = firstRange.startOffset;\n            } else {\n              // Left to right\n              anchorNode = firstRange.startContainer;\n              anchorOffset = firstRange.endOffset;\n              focusOffset = lastRange.startOffset;\n            }\n          }\n        } else {\n          anchorNode = domRange.anchorNode;\n          anchorOffset = domRange.anchorOffset;\n          focusNode = domRange.focusNode;\n          focusOffset = domRange.focusOffset;\n        }\n        // COMPAT: There's a bug in chrome that always returns `true` for\n        // `isCollapsed` for a Selection that comes from a ShadowRoot.\n        // (2020/08/08)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n        // IsCollapsed might not work in firefox, but this will\n        if (IS_CHROME && hasShadowRoot(anchorNode) || IS_FIREFOX) {\n          isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;\n        } else {\n          isCollapsed = domRange.isCollapsed;\n        }\n      } else {\n        anchorNode = domRange.startContainer;\n        anchorOffset = domRange.startOffset;\n        focusNode = domRange.endContainer;\n        focusOffset = domRange.endOffset;\n        isCollapsed = domRange.collapsed;\n      }\n    }\n    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n      throw new Error(\"Cannot resolve a Slate range from DOM range: \".concat(domRange));\n    }\n    // COMPAT: Firefox sometimes includes an extra \\n (rendered by TextString\n    // when isTrailing is true) in the focusOffset, resulting in an invalid\n    // Slate point. (2023/11/01)\n    if (IS_FIREFOX && (_focusNode$textConten = focusNode.textContent) !== null && _focusNode$textConten !== void 0 && _focusNode$textConten.endsWith('\\n\\n') && focusOffset === focusNode.textContent.length) {\n      focusOffset--;\n    }\n    var anchor = DOMEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {\n      exactMatch,\n      suppressThrow\n    });\n    if (!anchor) {\n      return null;\n    }\n    var focusBeforeAnchor = isBefore(anchorNode, focusNode) || anchorNode === focusNode && focusOffset < anchorOffset;\n    var focus = isCollapsed ? anchor : DOMEditor.toSlatePoint(editor, [focusNode, focusOffset], {\n      exactMatch,\n      suppressThrow,\n      searchDirection: focusBeforeAnchor ? 'forward' : 'backward'\n    });\n    if (!focus) {\n      return null;\n    }\n    var range = {\n      anchor: anchor,\n      focus: focus\n    };\n    // if the selection is a hanging range that ends in a void\n    // and the DOM focus is an Element\n    // (meaning that the selection ends before the element)\n    // unhang the range to avoid mistakenly including the void\n    if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isExpanded(range) && slate__WEBPACK_IMPORTED_MODULE_1__.Range.isForward(range) && isDOMElement(focusNode) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.void(editor, {\n      at: range.focus,\n      mode: 'highest'\n    })) {\n      range = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.unhangRange(editor, range, {\n        voids: true\n      });\n    }\n    return range;\n  }\n};\n\n/**\n * Check whether a text diff was applied in a way we can perform the pending action on /\n * recover the pending selection.\n */\nfunction verifyDiffState(editor, textDiff) {\n  var {\n    path,\n    diff\n  } = textDiff;\n  if (!slate__WEBPACK_IMPORTED_MODULE_1__.Editor.hasPath(editor, path)) {\n    return false;\n  }\n  var node = slate__WEBPACK_IMPORTED_MODULE_1__.Node.get(editor, path);\n  if (!slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(node)) {\n    return false;\n  }\n  if (diff.start !== node.text.length || diff.text.length === 0) {\n    return node.text.slice(diff.start, diff.start + diff.text.length) === diff.text;\n  }\n  var nextPath = slate__WEBPACK_IMPORTED_MODULE_1__.Path.next(path);\n  if (!slate__WEBPACK_IMPORTED_MODULE_1__.Editor.hasPath(editor, nextPath)) {\n    return false;\n  }\n  var nextNode = slate__WEBPACK_IMPORTED_MODULE_1__.Node.get(editor, nextPath);\n  return slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(nextNode) && nextNode.text.startsWith(diff.text);\n}\nfunction applyStringDiff(text) {\n  for (var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    diffs[_key - 1] = arguments[_key];\n  }\n  return diffs.reduce((text, diff) => text.slice(0, diff.start) + diff.text + text.slice(diff.end), text);\n}\nfunction longestCommonPrefixLength(str, another) {\n  var length = Math.min(str.length, another.length);\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(i) !== another.charAt(i)) {\n      return i;\n    }\n  }\n  return length;\n}\nfunction longestCommonSuffixLength(str, another, max) {\n  var length = Math.min(str.length, another.length, max);\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(str.length - i - 1) !== another.charAt(another.length - i - 1)) {\n      return i;\n    }\n  }\n  return length;\n}\n/**\n * Remove redundant changes from the diff so that it spans the minimal possible range\n */\nfunction normalizeStringDiff(targetText, diff) {\n  var {\n    start,\n    end,\n    text\n  } = diff;\n  var removedText = targetText.slice(start, end);\n  var prefixLength = longestCommonPrefixLength(removedText, text);\n  var max = Math.min(removedText.length - prefixLength, text.length - prefixLength);\n  var suffixLength = longestCommonSuffixLength(removedText, text, max);\n  var normalized = {\n    start: start + prefixLength,\n    end: end - suffixLength,\n    text: text.slice(prefixLength, text.length - suffixLength)\n  };\n  if (normalized.start === normalized.end && normalized.text.length === 0) {\n    return null;\n  }\n  return normalized;\n}\n/**\n * Return a string diff that is equivalent to applying b after a spanning the range of\n * both changes\n */\nfunction mergeStringDiffs(targetText, a, b) {\n  var start = Math.min(a.start, b.start);\n  var overlap = Math.max(0, Math.min(a.start + a.text.length, b.end) - b.start);\n  var applied = applyStringDiff(targetText, a, b);\n  var sliceEnd = Math.max(b.start + b.text.length, a.start + a.text.length + (a.start + a.text.length > b.start ? b.text.length : 0) - overlap);\n  var text = applied.slice(start, sliceEnd);\n  var end = Math.max(a.end, b.end - a.text.length + (a.end - a.start));\n  return normalizeStringDiff(targetText, {\n    start,\n    end,\n    text\n  });\n}\n/**\n * Get the slate range the text diff spans.\n */\nfunction targetRange(textDiff) {\n  var {\n    path,\n    diff\n  } = textDiff;\n  return {\n    anchor: {\n      path,\n      offset: diff.start\n    },\n    focus: {\n      path,\n      offset: diff.end\n    }\n  };\n}\n/**\n * Normalize a 'pending point' a.k.a a point based on the dom state before applying\n * the pending diffs. Since the pending diffs might have been inserted with different\n * marks we have to 'walk' the offset from the starting position to ensure we still\n * have a valid point inside the document\n */\nfunction normalizePoint(editor, point) {\n  var {\n    path,\n    offset\n  } = point;\n  if (!slate__WEBPACK_IMPORTED_MODULE_1__.Editor.hasPath(editor, path)) {\n    return null;\n  }\n  var leaf = slate__WEBPACK_IMPORTED_MODULE_1__.Node.get(editor, path);\n  if (!slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(leaf)) {\n    return null;\n  }\n  var parentBlock = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.above(editor, {\n    match: n => slate__WEBPACK_IMPORTED_MODULE_1__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isBlock(editor, n),\n    at: path\n  });\n  if (!parentBlock) {\n    return null;\n  }\n  while (offset > leaf.text.length) {\n    var entry = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.next(editor, {\n      at: path,\n      match: slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText\n    });\n    if (!entry || !slate__WEBPACK_IMPORTED_MODULE_1__.Path.isDescendant(entry[1], parentBlock[1])) {\n      return null;\n    }\n    offset -= leaf.text.length;\n    leaf = entry[0];\n    path = entry[1];\n  }\n  return {\n    path,\n    offset\n  };\n}\n/**\n * Normalize a 'pending selection' to ensure it's valid in the current document state.\n */\nfunction normalizeRange(editor, range) {\n  var anchor = normalizePoint(editor, range.anchor);\n  if (!anchor) {\n    return null;\n  }\n  if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(range)) {\n    return {\n      anchor,\n      focus: anchor\n    };\n  }\n  var focus = normalizePoint(editor, range.focus);\n  if (!focus) {\n    return null;\n  }\n  return {\n    anchor,\n    focus\n  };\n}\nfunction transformPendingPoint(editor, point, op) {\n  var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n  var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find(_ref => {\n    var {\n      path\n    } = _ref;\n    return slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(path, point.path);\n  });\n  if (!textDiff || point.offset <= textDiff.diff.start) {\n    return slate__WEBPACK_IMPORTED_MODULE_1__.Point.transform(point, op, {\n      affinity: 'backward'\n    });\n  }\n  var {\n    diff\n  } = textDiff;\n  // Point references location inside the diff => transform the point based on the location\n  // the diff will be applied to and add the offset inside the diff.\n  if (point.offset <= diff.start + diff.text.length) {\n    var _anchor = {\n      path: point.path,\n      offset: diff.start\n    };\n    var _transformed = slate__WEBPACK_IMPORTED_MODULE_1__.Point.transform(_anchor, op, {\n      affinity: 'backward'\n    });\n    if (!_transformed) {\n      return null;\n    }\n    return {\n      path: _transformed.path,\n      offset: _transformed.offset + point.offset - diff.start\n    };\n  }\n  // Point references location after the diff\n  var anchor = {\n    path: point.path,\n    offset: point.offset - diff.text.length + diff.end - diff.start\n  };\n  var transformed = slate__WEBPACK_IMPORTED_MODULE_1__.Point.transform(anchor, op, {\n    affinity: 'backward'\n  });\n  if (!transformed) {\n    return null;\n  }\n  if (op.type === 'split_node' && slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(op.path, point.path) && anchor.offset < op.position && diff.start < op.position) {\n    return transformed;\n  }\n  return {\n    path: transformed.path,\n    offset: transformed.offset + diff.text.length - diff.end + diff.start\n  };\n}\nfunction transformPendingRange(editor, range, op) {\n  var anchor = transformPendingPoint(editor, range.anchor, op);\n  if (!anchor) {\n    return null;\n  }\n  if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(range)) {\n    return {\n      anchor,\n      focus: anchor\n    };\n  }\n  var focus = transformPendingPoint(editor, range.focus, op);\n  if (!focus) {\n    return null;\n  }\n  return {\n    anchor,\n    focus\n  };\n}\nfunction transformTextDiff(textDiff, op) {\n  var {\n    path,\n    diff,\n    id\n  } = textDiff;\n  switch (op.type) {\n    case 'insert_text':\n      {\n        if (!slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n        if (op.offset <= diff.start) {\n          return {\n            diff: {\n              start: op.text.length + diff.start,\n              end: op.text.length + diff.end,\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end + op.text.length,\n            text: diff.text\n          },\n          id,\n          path\n        };\n      }\n    case 'remove_text':\n      {\n        if (!slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n        if (op.offset + op.text.length <= diff.start) {\n          return {\n            diff: {\n              start: diff.start - op.text.length,\n              end: diff.end - op.text.length,\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end - op.text.length,\n            text: diff.text\n          },\n          id,\n          path\n        };\n      }\n    case 'split_node':\n      {\n        if (!slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(op.path, path) || op.position >= diff.end) {\n          return {\n            diff,\n            id,\n            path: slate__WEBPACK_IMPORTED_MODULE_1__.Path.transform(path, op, {\n              affinity: 'backward'\n            })\n          };\n        }\n        if (op.position > diff.start) {\n          return {\n            diff: {\n              start: diff.start,\n              end: Math.min(op.position, diff.end),\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start - op.position,\n            end: diff.end - op.position,\n            text: diff.text\n          },\n          id,\n          path: slate__WEBPACK_IMPORTED_MODULE_1__.Path.transform(path, op, {\n            affinity: 'forward'\n          })\n        };\n      }\n    case 'merge_node':\n      {\n        if (!slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(op.path, path)) {\n          return {\n            diff,\n            id,\n            path: slate__WEBPACK_IMPORTED_MODULE_1__.Path.transform(path, op)\n          };\n        }\n        return {\n          diff: {\n            start: diff.start + op.position,\n            end: diff.end + op.position,\n            text: diff.text\n          },\n          id,\n          path: slate__WEBPACK_IMPORTED_MODULE_1__.Path.transform(path, op)\n        };\n      }\n  }\n  var newPath = slate__WEBPACK_IMPORTED_MODULE_1__.Path.transform(path, op);\n  if (!newPath) {\n    return null;\n  }\n  return {\n    diff,\n    path: newPath,\n    id\n  };\n}\n\n/**\n * Utilities for single-line deletion\n */\nvar doRectsIntersect = (rect, compareRect) => {\n  var middle = (compareRect.top + compareRect.bottom) / 2;\n  return rect.top <= middle && rect.bottom >= middle;\n};\nvar areRangesSameLine = (editor, range1, range2) => {\n  var rect1 = DOMEditor.toDOMRange(editor, range1).getBoundingClientRect();\n  var rect2 = DOMEditor.toDOMRange(editor, range2).getBoundingClientRect();\n  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);\n};\n/**\n * A helper utility that returns the end portion of a `Range`\n * which is located on a single line.\n *\n * @param {Editor} editor The editor object to compare against\n * @param {Range} parentRange The parent range to compare against\n * @returns {Range} A valid portion of the parentRange which is one a single line\n */\nvar findCurrentLineRange = (editor, parentRange) => {\n  var parentRangeBoundary = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, slate__WEBPACK_IMPORTED_MODULE_1__.Range.end(parentRange));\n  var positions = Array.from(slate__WEBPACK_IMPORTED_MODULE_1__.Editor.positions(editor, {\n    at: parentRange\n  }));\n  var left = 0;\n  var right = positions.length;\n  var middle = Math.floor(right / 2);\n  if (areRangesSameLine(editor, slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, positions[left]), parentRangeBoundary)) {\n    return slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, positions[left], parentRangeBoundary);\n  }\n  if (positions.length < 2) {\n    return slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);\n  }\n  while (middle !== positions.length && middle !== left) {\n    if (areRangesSameLine(editor, slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n      right = middle;\n    } else {\n      left = middle;\n    }\n    middle = Math.floor((left + right) / 2);\n  }\n  return slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, positions[right], parentRangeBoundary);\n};\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/**\n * `withDOM` adds DOM specific behaviors to the editor.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\nvar withDOM = function withDOM(editor) {\n  var clipboardFormatKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x-slate-fragment';\n  var e = editor;\n  var {\n    apply,\n    onChange,\n    deleteBackward,\n    addMark,\n    removeMark\n  } = e;\n  // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n  // avoid collisions between editors in the DOM that share the same value.\n  EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap());\n  e.addMark = (key, value) => {\n    var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e)) === null || _EDITOR_TO_SCHEDULE_F === void 0 || _EDITOR_TO_SCHEDULE_F();\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n    EDITOR_TO_USER_MARKS.delete(e);\n    addMark(key, value);\n  };\n  e.removeMark = key => {\n    var _EDITOR_TO_PENDING_DI2;\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n    EDITOR_TO_USER_MARKS.delete(e);\n    removeMark(key);\n  };\n  e.deleteBackward = unit => {\n    if (unit !== 'line') {\n      return deleteBackward(unit);\n    }\n    if (e.selection && slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(e.selection)) {\n      var parentBlockEntry = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.above(e, {\n        match: n => slate__WEBPACK_IMPORTED_MODULE_1__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isBlock(e, n),\n        at: e.selection\n      });\n      if (parentBlockEntry) {\n        var [, parentBlockPath] = parentBlockEntry;\n        var parentElementRange = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(e, parentBlockPath, e.selection.anchor);\n        var currentLineRange = findCurrentLineRange(e, parentElementRange);\n        if (!slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(currentLineRange)) {\n          slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.delete(e, {\n            at: currentLineRange\n          });\n        }\n      }\n    }\n  };\n  // This attempts to reset the NODE_TO_KEY entry to the correct value\n  // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n  e.apply = op => {\n    var matches = [];\n    var pathRefMatches = [];\n    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e);\n    if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {\n      var transformed = pendingDiffs.map(textDiff => transformTextDiff(textDiff, op)).filter(Boolean);\n      EDITOR_TO_PENDING_DIFFS.set(e, transformed);\n    }\n    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e);\n    if (pendingSelection) {\n      EDITOR_TO_PENDING_SELECTION.set(e, transformPendingRange(e, pendingSelection, op));\n    }\n    var pendingAction = EDITOR_TO_PENDING_ACTION.get(e);\n    if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {\n      var at = slate__WEBPACK_IMPORTED_MODULE_1__.Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e, pendingAction.at, op) : transformPendingRange(e, pendingAction.at, op);\n      EDITOR_TO_PENDING_ACTION.set(e, at ? _objectSpread(_objectSpread({}, pendingAction), {}, {\n        at\n      }) : null);\n    }\n    switch (op.type) {\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_node':\n      case 'split_node':\n        {\n          matches.push(...getMatches(e, op.path));\n          break;\n        }\n      case 'set_selection':\n        {\n          var _EDITOR_TO_USER_SELEC;\n          // Selection was manually set, don't restore the user selection after the change.\n          (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e)) === null || _EDITOR_TO_USER_SELEC === void 0 || _EDITOR_TO_USER_SELEC.unref();\n          EDITOR_TO_USER_SELECTION.delete(e);\n          break;\n        }\n      case 'insert_node':\n      case 'remove_node':\n        {\n          matches.push(...getMatches(e, slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(op.path)));\n          break;\n        }\n      case 'merge_node':\n        {\n          var prevPath = slate__WEBPACK_IMPORTED_MODULE_1__.Path.previous(op.path);\n          matches.push(...getMatches(e, prevPath));\n          break;\n        }\n      case 'move_node':\n        {\n          var commonPath = slate__WEBPACK_IMPORTED_MODULE_1__.Path.common(slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(op.path), slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(op.newPath));\n          matches.push(...getMatches(e, commonPath));\n          var changedPath;\n          if (slate__WEBPACK_IMPORTED_MODULE_1__.Path.isBefore(op.path, op.newPath)) {\n            matches.push(...getMatches(e, slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(op.path)));\n            changedPath = op.newPath;\n          } else {\n            matches.push(...getMatches(e, slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(op.newPath)));\n            changedPath = op.path;\n          }\n          var changedNode = slate__WEBPACK_IMPORTED_MODULE_1__.Node.get(editor, slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(changedPath));\n          var changedNodeKey = DOMEditor.findKey(e, changedNode);\n          var changedPathRef = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.pathRef(e, slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(changedPath));\n          pathRefMatches.push([changedPathRef, changedNodeKey]);\n          break;\n        }\n    }\n    apply(op);\n    switch (op.type) {\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'move_node':\n      case 'split_node':\n        {\n          IS_NODE_MAP_DIRTY.set(e, true);\n        }\n    }\n    for (var [path, key] of matches) {\n      var [node] = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.node(e, path);\n      NODE_TO_KEY.set(node, key);\n    }\n    for (var [pathRef, _key] of pathRefMatches) {\n      if (pathRef.current) {\n        var [_node] = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.node(e, pathRef.current);\n        NODE_TO_KEY.set(_node, _key);\n      }\n      pathRef.unref();\n    }\n  };\n  e.setFragmentData = data => {\n    var {\n      selection\n    } = e;\n    if (!selection) {\n      return;\n    }\n    var [start, end] = slate__WEBPACK_IMPORTED_MODULE_1__.Range.edges(selection);\n    var startVoid = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.void(e, {\n      at: start.path\n    });\n    var endVoid = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.void(e, {\n      at: end.path\n    });\n    if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(selection) && !startVoid) {\n      return;\n    }\n    // Create a fake selection so that we can add a Base64-encoded copy of the\n    // fragment to the HTML, to decode on future pastes.\n    var domRange = DOMEditor.toDOMRange(e, selection);\n    var contents = domRange.cloneContents();\n    var attach = contents.childNodes[0];\n    // Make sure attach is non-empty, since empty nodes will not get copied.\n    contents.childNodes.forEach(node => {\n      if (node.textContent && node.textContent.trim() !== '') {\n        attach = node;\n      }\n    });\n    // COMPAT: If the end node is a void node, we need to move the end of the\n    // range from the void node's spacer span, to the end of the void node's\n    // content, since the spacer is before void's content in the DOM.\n    if (endVoid) {\n      var [voidNode] = endVoid;\n      var r = domRange.cloneRange();\n      var domNode = DOMEditor.toDOMNode(e, voidNode);\n      r.setEndAfter(domNode);\n      contents = r.cloneContents();\n    }\n    // COMPAT: If the start node is a void node, we need to attach the encoded\n    // fragment to the void node's content node instead of the spacer, because\n    // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n    // most browsers. (2018/04/27)\n    if (startVoid) {\n      attach = contents.querySelector('[data-slate-spacer]');\n    }\n    // Remove any zero-width space spans from the cloned DOM so that they don't\n    // show up elsewhere when pasted.\n    Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(zw => {\n      var isNewline = zw.getAttribute('data-slate-zero-width') === 'n';\n      zw.textContent = isNewline ? '\\n' : '';\n    });\n    // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n    // in the HTML, and can be used for intra-Slate pasting. If it's a text\n    // node, wrap it in a `<span>` so we have something to set an attribute on.\n    if (isDOMText(attach)) {\n      var span = attach.ownerDocument.createElement('span');\n      // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n      // then leading and trailing spaces will be ignored. (2017/09/21)\n      span.style.whiteSpace = 'pre';\n      span.appendChild(attach);\n      contents.appendChild(span);\n      attach = span;\n    }\n    var fragment = e.getFragment();\n    var string = JSON.stringify(fragment);\n    var encoded = window.btoa(encodeURIComponent(string));\n    attach.setAttribute('data-slate-fragment', encoded);\n    data.setData(\"application/\".concat(clipboardFormatKey), encoded);\n    // Add the content to a <div> so that we can get its inner HTML.\n    var div = contents.ownerDocument.createElement('div');\n    div.appendChild(contents);\n    div.setAttribute('hidden', 'true');\n    contents.ownerDocument.body.appendChild(div);\n    data.setData('text/html', div.innerHTML);\n    data.setData('text/plain', getPlainText(div));\n    contents.ownerDocument.body.removeChild(div);\n    return data;\n  };\n  e.insertData = data => {\n    if (!e.insertFragmentData(data)) {\n      e.insertTextData(data);\n    }\n  };\n  e.insertFragmentData = data => {\n    /**\n     * Checking copied fragment from application/x-slate-fragment or data-slate-fragment\n     */\n    var fragment = data.getData(\"application/\".concat(clipboardFormatKey)) || getSlateFragmentAttribute(data);\n    if (fragment) {\n      var decoded = decodeURIComponent(window.atob(fragment));\n      var parsed = JSON.parse(decoded);\n      e.insertFragment(parsed);\n      return true;\n    }\n    return false;\n  };\n  e.insertTextData = data => {\n    var text = data.getData('text/plain');\n    if (text) {\n      var lines = text.split(/\\r\\n|\\r|\\n/);\n      var split = false;\n      for (var line of lines) {\n        if (split) {\n          slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.splitNodes(e, {\n            always: true\n          });\n        }\n        e.insertText(line);\n        split = true;\n      }\n      return true;\n    }\n    return false;\n  };\n  e.onChange = options => {\n    var onContextChange = EDITOR_TO_ON_CHANGE.get(e);\n    if (onContextChange) {\n      onContextChange(options);\n    }\n    onChange(options);\n  };\n  return e;\n};\nvar getMatches = (e, path) => {\n  var matches = [];\n  for (var [n, p] of slate__WEBPACK_IMPORTED_MODULE_1__.Editor.levels(e, {\n    at: path\n  })) {\n    var key = DOMEditor.findKey(e, n);\n    matches.push([p, key]);\n  }\n  return matches;\n};\n\nvar TRIPLE_CLICK = 3;\n\n/**\n * Hotkey mappings for each platform.\n */\nvar HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  moveBackward: 'left',\n  moveForward: 'right',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  italic: 'mod+i',\n  insertSoftBreak: 'shift+enter',\n  splitBlock: 'enter',\n  undo: 'mod+z'\n};\nvar APPLE_HOTKEYS = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t'\n};\nvar WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z']\n};\n/**\n * Create a platform-aware hotkey checker.\n */\nvar create = key => {\n  var generic = HOTKEYS[key];\n  var apple = APPLE_HOTKEYS[key];\n  var windows = WINDOWS_HOTKEYS[key];\n  var isGeneric = generic && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_0__.isHotkey)(generic);\n  var isApple = apple && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_0__.isHotkey)(apple);\n  var isWindows = windows && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_0__.isHotkey)(windows);\n  return event => {\n    if (isGeneric && isGeneric(event)) return true;\n    if (IS_APPLE && isApple && isApple(event)) return true;\n    if (!IS_APPLE && isWindows && isWindows(event)) return true;\n    return false;\n  };\n};\n/**\n * Hotkeys.\n */\nvar hotkeys = {\n  isBold: create('bold'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isItalic: create('italic'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isRedo: create('redo'),\n  isSoftBreak: create('insertSoftBreak'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo')\n};\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nvar _excluded = [\"anchor\", \"focus\"],\n  _excluded2 = [\"anchor\", \"focus\"];\nvar shallowCompare = (obj1, obj2) => Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every(key => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);\nvar isDecorationFlagsEqual = (range, other) => {\n  var rangeOwnProps = _objectWithoutProperties(range, _excluded);\n  var otherOwnProps = _objectWithoutProperties(other, _excluded2);\n  return range[PLACEHOLDER_SYMBOL] === other[PLACEHOLDER_SYMBOL] && shallowCompare(rangeOwnProps, otherOwnProps);\n};\n/**\n * Check if a list of decorator ranges are equal to another.\n *\n * PERF: this requires the two lists to also have the ranges inside them in the\n * same order, but this is an okay constraint for us since decorations are\n * kept in order, and the odd case where they aren't is okay to re-render for.\n */\nvar isElementDecorationsEqual = (list, another) => {\n  if (list.length !== another.length) {\n    return false;\n  }\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i];\n    if (!slate__WEBPACK_IMPORTED_MODULE_1__.Range.equals(range, other) || !isDecorationFlagsEqual(range, other)) {\n      return false;\n    }\n  }\n  return true;\n};\n/**\n * Check if a list of decorator ranges are equal to another.\n *\n * PERF: this requires the two lists to also have the ranges inside them in the\n * same order, but this is an okay constraint for us since decorations are\n * kept in order, and the odd case where they aren't is okay to re-render for.\n */\nvar isTextDecorationsEqual = (list, another) => {\n  if (list.length !== another.length) {\n    return false;\n  }\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i];\n    // compare only offsets because paths doesn't matter for text\n    if (range.anchor.offset !== other.anchor.offset || range.focus.offset !== other.focus.offset || !isDecorationFlagsEqual(range, other)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2xhdGUtZG9tL2Rpc3QvaW5kZXguZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEY7QUFDekQ7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNklBQTZJO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtREFBUTtBQUNyQyx5QkFBeUIsbURBQVE7QUFDakMsNkJBQTZCLG1EQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBLFNBQVMsd0NBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5bkM7QUFDem5DIiwic291cmNlcyI6WyJEOlxcU09XTl9HSUFJQ1xcTkVYVC1XT1JLXFxIQUNLQVRIT04tM1xcVUktVVgtSEFDS0FUSE9OLU5leHRKUy1EZXNpZ24tSmFtLTIwMjQtKE1ZLUNMT05FLVBST0pFQ1QpXFxub2RlX21vZHVsZXNcXHNsYXRlLWRvbVxcZGlzdFxcaW5kZXguZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHJhbnNmb3JtcywgRWxlbWVudCwgRWRpdG9yLCBTY3J1YmJlciwgUmFuZ2UsIE5vZGUsIFRleHQsIFBhdGgsIFBvaW50IH0gZnJvbSAnc2xhdGUnO1xuaW1wb3J0IHsgaXNIb3RrZXkgfSBmcm9tICdpcy1ob3RrZXknO1xuXG4vKipcbiAqIFR5cGVzLlxuICovXG4vLyBDT01QQVQ6IFRoaXMgaXMgcmVxdWlyZWQgdG8gcHJldmVudCBUeXBlU2NyaXB0IGFsaWFzZXMgZnJvbSBkb2luZyBzb21lIHZlcnlcbi8vIHdlaXJkIHRoaW5ncyBmb3IgU2xhdGUncyB0eXBlcyB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgZ2xvYmFscy4gKDIwMTkvMTEvMjcpXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzM1MDAyXG52YXIgRE9NTm9kZSA9IGdsb2JhbFRoaXMuTm9kZTtcbnZhciBET01FbGVtZW50ID0gZ2xvYmFsVGhpcy5FbGVtZW50O1xudmFyIERPTVRleHQgPSBnbG9iYWxUaGlzLlRleHQ7XG52YXIgRE9NUmFuZ2UgPSBnbG9iYWxUaGlzLlJhbmdlO1xudmFyIERPTVNlbGVjdGlvbiA9IGdsb2JhbFRoaXMuU2VsZWN0aW9uO1xudmFyIERPTVN0YXRpY1JhbmdlID0gZ2xvYmFsVGhpcy5TdGF0aWNSYW5nZTtcbi8qKlxuICogUmV0dXJucyB0aGUgaG9zdCB3aW5kb3cgb2YgYSBET00gbm9kZVxuICovXG52YXIgZ2V0RGVmYXVsdFZpZXcgPSB2YWx1ZSA9PiB7XG4gIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5vd25lckRvY3VtZW50ICYmIHZhbHVlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgbnVsbDtcbn07XG4vKipcbiAqIENoZWNrIGlmIGEgRE9NIG5vZGUgaXMgYSBjb21tZW50IG5vZGUuXG4gKi9cbnZhciBpc0RPTUNvbW1lbnQgPSB2YWx1ZSA9PiB7XG4gIHJldHVybiBpc0RPTU5vZGUodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSA4O1xufTtcbi8qKlxuICogQ2hlY2sgaWYgYSBET00gbm9kZSBpcyBhbiBlbGVtZW50IG5vZGUuXG4gKi9cbnZhciBpc0RPTUVsZW1lbnQgPSB2YWx1ZSA9PiB7XG4gIHJldHVybiBpc0RPTU5vZGUodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxO1xufTtcbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIERPTSBub2RlLlxuICovXG52YXIgaXNET01Ob2RlID0gdmFsdWUgPT4ge1xuICB2YXIgd2luZG93ID0gZ2V0RGVmYXVsdFZpZXcodmFsdWUpO1xuICByZXR1cm4gISF3aW5kb3cgJiYgdmFsdWUgaW5zdGFuY2VvZiB3aW5kb3cuTm9kZTtcbn07XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBET00gc2VsZWN0aW9uLlxuICovXG52YXIgaXNET01TZWxlY3Rpb24gPSB2YWx1ZSA9PiB7XG4gIHZhciB3aW5kb3cgPSB2YWx1ZSAmJiB2YWx1ZS5hbmNob3JOb2RlICYmIGdldERlZmF1bHRWaWV3KHZhbHVlLmFuY2hvck5vZGUpO1xuICByZXR1cm4gISF3aW5kb3cgJiYgdmFsdWUgaW5zdGFuY2VvZiB3aW5kb3cuU2VsZWN0aW9uO1xufTtcbi8qKlxuICogQ2hlY2sgaWYgYSBET00gbm9kZSBpcyBhbiBlbGVtZW50IG5vZGUuXG4gKi9cbnZhciBpc0RPTVRleHQgPSB2YWx1ZSA9PiB7XG4gIHJldHVybiBpc0RPTU5vZGUodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAzO1xufTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBwYXN0ZSBldmVudCBpcyBhIHBsYWludGV4dC1vbmx5IGV2ZW50LlxuICovXG52YXIgaXNQbGFpblRleHRPbmx5UGFzdGUgPSBldmVudCA9PiB7XG4gIHJldHVybiBldmVudC5jbGlwYm9hcmREYXRhICYmIGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpICE9PSAnJyAmJiBldmVudC5jbGlwYm9hcmREYXRhLnR5cGVzLmxlbmd0aCA9PT0gMTtcbn07XG4vKipcbiAqIE5vcm1hbGl6ZSBhIERPTSBwb2ludCBzbyB0aGF0IGl0IGFsd2F5cyByZWZlcnMgdG8gYSB0ZXh0IG5vZGUuXG4gKi9cbnZhciBub3JtYWxpemVET01Qb2ludCA9IGRvbVBvaW50ID0+IHtcbiAgdmFyIFtub2RlLCBvZmZzZXRdID0gZG9tUG9pbnQ7XG4gIC8vIElmIGl0J3MgYW4gZWxlbWVudCBub2RlLCBpdHMgb2Zmc2V0IHJlZmVycyB0byB0aGUgaW5kZXggb2YgaXRzIGNoaWxkcmVuXG4gIC8vIGluY2x1ZGluZyBjb21tZW50IG5vZGVzLCBzbyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgdGV4dCBjaGlsZCBub2RlLlxuICBpZiAoaXNET01FbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICB2YXIgaXNMYXN0ID0gb2Zmc2V0ID09PSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IGlzTGFzdCA/IG9mZnNldCAtIDEgOiBvZmZzZXQ7XG4gICAgW25vZGUsIGluZGV4XSA9IGdldEVkaXRhYmxlQ2hpbGRBbmRJbmRleChub2RlLCBpbmRleCwgaXNMYXN0ID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJyk7XG4gICAgLy8gSWYgdGhlIGVkaXRhYmxlIGNoaWxkIGZvdW5kIGlzIGluIGZyb250IG9mIGlucHV0IG9mZnNldCwgd2UgaW5zdGVhZCBzZWVrIHRvIGl0cyBlbmRcbiAgICBpc0xhc3QgPSBpbmRleCA8IG9mZnNldDtcbiAgICAvLyBJZiB0aGUgbm9kZSBoYXMgY2hpbGRyZW4sIHRyYXZlcnNlIHVudGlsIHdlIGhhdmUgYSBsZWFmIG5vZGUuIExlYWYgbm9kZXNcbiAgICAvLyBjYW4gYmUgZWl0aGVyIHRleHQgbm9kZXMsIG9yIG90aGVyIHZvaWQgRE9NIG5vZGVzLlxuICAgIHdoaWxlIChpc0RPTUVsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgdmFyIGkgPSBpc0xhc3QgPyBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMSA6IDA7XG4gICAgICBub2RlID0gZ2V0RWRpdGFibGVDaGlsZChub2RlLCBpLCBpc0xhc3QgPyAnYmFja3dhcmQnIDogJ2ZvcndhcmQnKTtcbiAgICB9XG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBuZXcgb2Zmc2V0IGluc2lkZSB0aGUgdGV4dCBub2RlLlxuICAgIG9mZnNldCA9IGlzTGFzdCAmJiBub2RlLnRleHRDb250ZW50ICE9IG51bGwgPyBub2RlLnRleHRDb250ZW50Lmxlbmd0aCA6IDA7XG4gIH1cbiAgLy8gUmV0dXJuIHRoZSBub2RlIGFuZCBvZmZzZXQuXG4gIHJldHVybiBbbm9kZSwgb2Zmc2V0XTtcbn07XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgYWN0aXZlIGVsZW1lbnQgaXMgbmVzdGVkIHdpdGhpbiBhIHNoYWRvd1Jvb3RcbiAqL1xudmFyIGhhc1NoYWRvd1Jvb3QgPSBub2RlID0+IHtcbiAgdmFyIHBhcmVudCA9IG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC50b1N0cmluZygpID09PSAnW29iamVjdCBTaGFkb3dSb290XScpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG4gKiBHZXQgdGhlIG5lYXJlc3QgZWRpdGFibGUgY2hpbGQgYW5kIGluZGV4IGF0IGBpbmRleGAgaW4gYSBgcGFyZW50YCwgcHJlZmVycmluZ1xuICogYGRpcmVjdGlvbmAuXG4gKi9cbnZhciBnZXRFZGl0YWJsZUNoaWxkQW5kSW5kZXggPSAocGFyZW50LCBpbmRleCwgZGlyZWN0aW9uKSA9PiB7XG4gIHZhciB7XG4gICAgY2hpbGROb2Rlc1xuICB9ID0gcGFyZW50O1xuICB2YXIgY2hpbGQgPSBjaGlsZE5vZGVzW2luZGV4XTtcbiAgdmFyIGkgPSBpbmRleDtcbiAgdmFyIHRyaWVkRm9yd2FyZCA9IGZhbHNlO1xuICB2YXIgdHJpZWRCYWNrd2FyZCA9IGZhbHNlO1xuICAvLyBXaGlsZSB0aGUgY2hpbGQgaXMgYSBjb21tZW50IG5vZGUsIG9yIGFuIGVsZW1lbnQgbm9kZSB3aXRoIG5vIGNoaWxkcmVuLFxuICAvLyBrZWVwIGl0ZXJhdGluZyB0byBmaW5kIGEgc2libGluZyBub24tdm9pZCwgbm9uLWNvbW1lbnQgbm9kZS5cbiAgd2hpbGUgKGlzRE9NQ29tbWVudChjaGlsZCkgfHwgaXNET01FbGVtZW50KGNoaWxkKSAmJiBjaGlsZC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCB8fCBpc0RPTUVsZW1lbnQoY2hpbGQpICYmIGNoaWxkLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICdmYWxzZScpIHtcbiAgICBpZiAodHJpZWRGb3J3YXJkICYmIHRyaWVkQmFja3dhcmQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoaSA+PSBjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgdHJpZWRGb3J3YXJkID0gdHJ1ZTtcbiAgICAgIGkgPSBpbmRleCAtIDE7XG4gICAgICBkaXJlY3Rpb24gPSAnYmFja3dhcmQnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpIDwgMCkge1xuICAgICAgdHJpZWRCYWNrd2FyZCA9IHRydWU7XG4gICAgICBpID0gaW5kZXggKyAxO1xuICAgICAgZGlyZWN0aW9uID0gJ2ZvcndhcmQnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNoaWxkID0gY2hpbGROb2Rlc1tpXTtcbiAgICBpbmRleCA9IGk7XG4gICAgaSArPSBkaXJlY3Rpb24gPT09ICdmb3J3YXJkJyA/IDEgOiAtMTtcbiAgfVxuICByZXR1cm4gW2NoaWxkLCBpbmRleF07XG59O1xuLyoqXG4gKiBHZXQgdGhlIG5lYXJlc3QgZWRpdGFibGUgY2hpbGQgYXQgYGluZGV4YCBpbiBhIGBwYXJlbnRgLCBwcmVmZXJyaW5nXG4gKiBgZGlyZWN0aW9uYC5cbiAqL1xudmFyIGdldEVkaXRhYmxlQ2hpbGQgPSAocGFyZW50LCBpbmRleCwgZGlyZWN0aW9uKSA9PiB7XG4gIHZhciBbY2hpbGRdID0gZ2V0RWRpdGFibGVDaGlsZEFuZEluZGV4KHBhcmVudCwgaW5kZXgsIGRpcmVjdGlvbik7XG4gIHJldHVybiBjaGlsZDtcbn07XG4vKipcbiAqIEdldCBhIHBsYWludGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29udGVudCBvZiBhIG5vZGUsIGFjY291bnRpbmcgZm9yIGJsb2NrXG4gKiBlbGVtZW50cyB3aGljaCBnZXQgYSBuZXdsaW5lIGFwcGVuZGVkLlxuICpcbiAqIFRoZSBkb21Ob2RlIG11c3QgYmUgYXR0YWNoZWQgdG8gdGhlIERPTS5cbiAqL1xudmFyIGdldFBsYWluVGV4dCA9IGRvbU5vZGUgPT4ge1xuICB2YXIgdGV4dCA9ICcnO1xuICBpZiAoaXNET01UZXh0KGRvbU5vZGUpICYmIGRvbU5vZGUubm9kZVZhbHVlKSB7XG4gICAgcmV0dXJuIGRvbU5vZGUubm9kZVZhbHVlO1xuICB9XG4gIGlmIChpc0RPTUVsZW1lbnQoZG9tTm9kZSkpIHtcbiAgICBmb3IgKHZhciBjaGlsZE5vZGUgb2YgQXJyYXkuZnJvbShkb21Ob2RlLmNoaWxkTm9kZXMpKSB7XG4gICAgICB0ZXh0ICs9IGdldFBsYWluVGV4dChjaGlsZE5vZGUpO1xuICAgIH1cbiAgICB2YXIgZGlzcGxheSA9IGdldENvbXB1dGVkU3R5bGUoZG9tTm9kZSkuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpO1xuICAgIGlmIChkaXNwbGF5ID09PSAnYmxvY2snIHx8IGRpc3BsYXkgPT09ICdsaXN0JyB8fCBkb21Ob2RlLnRhZ05hbWUgPT09ICdCUicpIHtcbiAgICAgIHRleHQgKz0gJ1xcbic7XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZXh0O1xufTtcbi8qKlxuICogR2V0IHgtc2xhdGUtZnJhZ21lbnQgYXR0cmlidXRlIGZyb20gZGF0YS1zbGF0ZS1mcmFnbWVudFxuICovXG52YXIgY2F0Y2hTbGF0ZUZyYWdtZW50ID0gL2RhdGEtc2xhdGUtZnJhZ21lbnQ9XCIoLis/KVwiL207XG52YXIgZ2V0U2xhdGVGcmFnbWVudEF0dHJpYnV0ZSA9IGRhdGFUcmFuc2ZlciA9PiB7XG4gIHZhciBodG1sRGF0YSA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L2h0bWwnKTtcbiAgdmFyIFssIGZyYWdtZW50XSA9IGh0bWxEYXRhLm1hdGNoKGNhdGNoU2xhdGVGcmFnbWVudCkgfHwgW107XG4gIHJldHVybiBmcmFnbWVudDtcbn07XG4vKipcbiAqIEdldCB0aGUgZG9tIHNlbGVjdGlvbiBmcm9tIFNoYWRvdyBSb290IGlmIHBvc3NpYmxlLCBvdGhlcndpc2UgZnJvbSB0aGUgZG9jdW1lbnRcbiAqL1xudmFyIGdldFNlbGVjdGlvbiA9IHJvb3QgPT4ge1xuICBpZiAocm9vdC5nZXRTZWxlY3Rpb24gIT0gbnVsbCkge1xuICAgIHJldHVybiByb290LmdldFNlbGVjdGlvbigpO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbn07XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSBtdXRhdGlvbiBvcmlnaW5hdGVzIGZyb20gYSBlZGl0YWJsZSBlbGVtZW50IGluc2lkZSB0aGUgZWRpdG9yLlxuICovXG52YXIgaXNUcmFja2VkTXV0YXRpb24gPSAoZWRpdG9yLCBtdXRhdGlvbiwgYmF0Y2gpID0+IHtcbiAgdmFyIHtcbiAgICB0YXJnZXRcbiAgfSA9IG11dGF0aW9uO1xuICBpZiAoaXNET01FbGVtZW50KHRhcmdldCkgJiYgdGFyZ2V0Lm1hdGNoZXMoJ1tjb250ZW50RWRpdGFibGU9XCJmYWxzZVwiXScpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB7XG4gICAgZG9jdW1lbnRcbiAgfSA9IERPTUVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcbiAgaWYgKGRvY3VtZW50LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICByZXR1cm4gRE9NRWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCB0YXJnZXQsIHtcbiAgICAgIGVkaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgdmFyIHBhcmVudE11dGF0aW9uID0gYmF0Y2guZmluZChfcmVmID0+IHtcbiAgICB2YXIge1xuICAgICAgYWRkZWROb2RlcyxcbiAgICAgIHJlbW92ZWROb2Rlc1xuICAgIH0gPSBfcmVmO1xuICAgIGZvciAodmFyIG5vZGUgb2YgYWRkZWROb2Rlcykge1xuICAgICAgaWYgKG5vZGUgPT09IHRhcmdldCB8fCBub2RlLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIF9ub2RlIG9mIHJlbW92ZWROb2Rlcykge1xuICAgICAgaWYgKF9ub2RlID09PSB0YXJnZXQgfHwgX25vZGUuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBpZiAoIXBhcmVudE11dGF0aW9uIHx8IHBhcmVudE11dGF0aW9uID09PSBtdXRhdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUYXJnZXQgYWRkL3JlbW92ZSBpcyB0cmFja2VkLiBUcmFjayB0aGUgbXV0YXRpb24gaWYgd2UgdHJhY2sgdGhlIHBhcmVudCBtdXRhdGlvbi5cbiAgcmV0dXJuIGlzVHJhY2tlZE11dGF0aW9uKGVkaXRvciwgcGFyZW50TXV0YXRpb24sIGJhdGNoKTtcbn07XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgZGVlcGVzdCBhY3RpdmUgZWxlbWVudCBpbiB0aGUgRE9NLCBjb25zaWRlcmluZyBuZXN0ZWQgc2hhZG93IERPTXMuXG4gKi9cbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gKCkgPT4ge1xuICB2YXIgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gIHdoaWxlICgoX2FjdGl2ZUVsZW1lbnQgPSBhY3RpdmVFbGVtZW50KSAhPT0gbnVsbCAmJiBfYWN0aXZlRWxlbWVudCAhPT0gdm9pZCAwICYmIF9hY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QgJiYgKF9hY3RpdmVFbGVtZW50JHNoYWRvdyA9IGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdCkgIT09IG51bGwgJiYgX2FjdGl2ZUVsZW1lbnQkc2hhZG93ICE9PSB2b2lkIDAgJiYgX2FjdGl2ZUVsZW1lbnQkc2hhZG93LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICB2YXIgX2FjdGl2ZUVsZW1lbnQsIF9hY3RpdmVFbGVtZW50JHNoYWRvdywgX2FjdGl2ZUVsZW1lbnQyO1xuICAgIGFjdGl2ZUVsZW1lbnQgPSAoX2FjdGl2ZUVsZW1lbnQyID0gYWN0aXZlRWxlbWVudCkgPT09IG51bGwgfHwgX2FjdGl2ZUVsZW1lbnQyID09PSB2b2lkIDAgfHwgKF9hY3RpdmVFbGVtZW50MiA9IF9hY3RpdmVFbGVtZW50Mi5zaGFkb3dSb290KSA9PT0gbnVsbCB8fCBfYWN0aXZlRWxlbWVudDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hY3RpdmVFbGVtZW50Mi5hY3RpdmVFbGVtZW50O1xuICB9XG4gIHJldHVybiBhY3RpdmVFbGVtZW50O1xufTtcbi8qKlxuICogQHJldHVybnMgYHRydWVgIGlmIGBvdGhlck5vZGVgIGlzIGJlZm9yZSBgbm9kZWAgaW4gdGhlIGRvY3VtZW50OyBvdGhlcndpc2UsIGBmYWxzZWAuXG4gKi9cbnZhciBpc0JlZm9yZSA9IChub2RlLCBvdGhlck5vZGUpID0+IEJvb2xlYW4obm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihvdGhlck5vZGUpICYgRE9NTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkcpO1xuLyoqXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYG90aGVyTm9kZWAgaXMgYWZ0ZXIgYG5vZGVgIGluIHRoZSBkb2N1bWVudDsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxuICovXG52YXIgaXNBZnRlciA9IChub2RlLCBvdGhlck5vZGUpID0+IEJvb2xlYW4obm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihvdGhlck5vZGUpICYgRE9NTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcpO1xuXG52YXIgX25hdmlnYXRvciR1c2VyQWdlbnQkLCBfbmF2aWdhdG9yJHVzZXJBZ2VudCQyO1xudmFyIElTX0lPUyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF3aW5kb3cuTVNTdHJlYW07XG52YXIgSVNfQVBQTEUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvTWFjIE9TIFgvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSVNfQU5EUk9JRCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9BbmRyb2lkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIElTX0ZJUkVGT1ggPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvXig/IS4qU2VhbW9ua2V5KSg/PS4qRmlyZWZveCkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSVNfV0VCS0lUID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0FwcGxlV2ViS2l0KD8hLipDaHJvbWUpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8vIFwibW9kZXJuXCIgRWRnZSB3YXMgcmVsZWFzZWQgYXQgNzkueFxudmFyIElTX0VER0VfTEVHQUNZID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0VkZ2U/XFwvKD86WzAtNl1bMC05XXxbMC03XVswLThdKSg/OlxcLikvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIElTX0NIUk9NRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9DaHJvbWUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLy8gTmF0aXZlIGBiZWZvcmVJbnB1dGAgZXZlbnRzIGRvbid0IHdvcmsgd2VsbCB3aXRoIHJlYWN0IG9uIENocm9tZSA3NVxuLy8gYW5kIG9sZGVyLCBDaHJvbWUgNzYrIGNhbiB1c2UgYGJlZm9yZUlucHV0YCB0aG91Z2guXG52YXIgSVNfQ0hST01FX0xFR0FDWSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9DaHJvbWU/XFwvKD86WzAtN11bMC01XXxbMC02XVswLTldKSg/OlxcLikvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIElTX0FORFJPSURfQ0hST01FX0xFR0FDWSA9IElTX0FORFJPSUQgJiYgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0Nocm9tZT9cXC8oPzpbMC01XT9cXGQpKD86XFwuKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4vLyBGaXJlZm94IGRpZCBub3Qgc3VwcG9ydCBgYmVmb3JlSW5wdXRgIHVudGlsIGB2ODdgLlxudmFyIElTX0ZJUkVGT1hfTEVHQUNZID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL14oPyEuKlNlYW1vbmtleSkoPz0uKkZpcmVmb3hcXC8oPzpbMC03XVswLTldfFswLThdWzAtNl0pKD86XFwuKSkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4vLyBVQyBtb2JpbGUgYnJvd3NlclxudmFyIElTX1VDX01PQklMRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC8uKlVDQnJvd3Nlci8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8vIFdlY2hhdCBicm93c2VyIChub3QgaW5jbHVkaW5nIG1hYyB3ZWNoYXQpXG52YXIgSVNfV0VDSEFUQlJPV1NFUiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC8uKldlY2hhdC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhLy4qTWFjV2VjaGF0Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyBhdm9pZCBsb29rYmVoaW5kIChidWdneSBpbiBzYWZhcmkgPCAxNi40KVxuLy8gQ2hlY2sgaWYgRE9NIGlzIGF2YWlsYWJsZSBhcyBSZWFjdCBkb2VzIGludGVybmFsbHkuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9tYXN0ZXIvcGFja2FnZXMvc2hhcmVkL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzXG52YXIgQ0FOX1VTRV9ET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnKTtcbi8vIENoZWNrIGlmIHRoZSBicm93c2VyIGlzIFNhZmFyaSBhbmQgb2xkZXIgdGhhbiAxN1xudHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL1NhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAvVmVyc2lvblxcLyhcXGQrKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAoKF9uYXZpZ2F0b3IkdXNlckFnZW50JCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1ZlcnNpb25cXC8oXFxkKykvKSkgIT09IG51bGwgJiYgX25hdmlnYXRvciR1c2VyQWdlbnQkICE9PSB2b2lkIDAgJiYgX25hdmlnYXRvciR1c2VyQWdlbnQkWzFdID8gcGFyc2VJbnQoKF9uYXZpZ2F0b3IkdXNlckFnZW50JDIgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvKFxcZCspLykpID09PSBudWxsIHx8IF9uYXZpZ2F0b3IkdXNlckFnZW50JDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9uYXZpZ2F0b3IkdXNlckFnZW50JDJbMV0sIDEwKSA8IDE3IDogZmFsc2UpO1xuLy8gQ09NUEFUOiBGaXJlZm94L0VkZ2UgTGVnYWN5IGRvbid0IHN1cHBvcnQgdGhlIGBiZWZvcmVpbnB1dGAgZXZlbnRcbi8vIENocm9tZSBMZWdhY3kgZG9lc24ndCBzdXBwb3J0IGBiZWZvcmVpbnB1dGAgY29ycmVjdGx5XG52YXIgSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUID0gKCFJU19DSFJPTUVfTEVHQUNZIHx8ICFJU19BTkRST0lEX0NIUk9NRV9MRUdBQ1kpICYmICFJU19FREdFX0xFR0FDWSAmJlxuLy8gZ2xvYmFsVGhpcyBpcyB1bmRlZmluZWQgaW4gb2xkZXIgYnJvd3NlcnNcbnR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzLklucHV0RXZlbnQgJiZcbi8vIEB0cy1pZ25vcmUgVGhlIGBnZXRUYXJnZXRSYW5nZXNgIHByb3BlcnR5IGlzbid0IHJlY29nbml6ZWQuXG50eXBlb2YgZ2xvYmFsVGhpcy5JbnB1dEV2ZW50LnByb3RvdHlwZS5nZXRUYXJnZXRSYW5nZXMgPT09ICdmdW5jdGlvbic7XG5cbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2Yobyk7XG59XG5cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcbiAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKF90eXBlb2YocmVzKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG59XG5cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEFuIGF1dG8taW5jcmVtZW50aW5nIGlkZW50aWZpZXIgZm9yIGtleXMuXG4gKi9cbnZhciBuID0gMDtcbi8qKlxuICogQSBjbGFzcyB0aGF0IGtlZXBzIHRyYWNrIG9mIGEga2V5IHN0cmluZy4gV2UgdXNlIGEgZnVsbCBjbGFzcyBoZXJlIGJlY2F1c2Ugd2VcbiAqIHdhbnQgdG8gYmUgYWJsZSB0byB1c2UgdGhlbSBhcyBrZXlzIGluIGBXZWFrTWFwYCBvYmplY3RzLlxuICovXG5jbGFzcyBLZXkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCB2b2lkIDApO1xuICAgIHRoaXMuaWQgPSBcIlwiLmNvbmNhdChuKyspO1xuICB9XG59XG5cbi8qKlxuICogVHdvIHdlYWsgbWFwcyB0aGF0IGFsbG93IHVzIHJlYnVpbGQgYSBwYXRoIGdpdmVuIGEgbm9kZS4gVGhleSBhcmUgcG9wdWxhdGVkXG4gKiBhdCByZW5kZXIgdGltZSBzdWNoIHRoYXQgYWZ0ZXIgYSByZW5kZXIgb2NjdXJzIHdlIGNhbiBhbHdheXMgYmFja3RyYWNrLlxuICovXG52YXIgSVNfTk9ERV9NQVBfRElSVFkgPSBuZXcgV2Vha01hcCgpO1xudmFyIE5PREVfVE9fSU5ERVggPSBuZXcgV2Vha01hcCgpO1xudmFyIE5PREVfVE9fUEFSRU5UID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogV2VhayBtYXBzIHRoYXQgYWxsb3cgdXMgdG8gZ28gYmV0d2VlbiBTbGF0ZSBub2RlcyBhbmQgRE9NIG5vZGVzLiBUaGVzZVxuICogYXJlIHVzZWQgdG8gcmVzb2x2ZSBET00gZXZlbnQtcmVsYXRlZCBsb2dpYyBpbnRvIFNsYXRlIGFjdGlvbnMuXG4gKi9cbnZhciBFRElUT1JfVE9fV0lORE9XID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fRUxFTUVOVCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX1BMQUNFSE9MREVSX0VMRU1FTlQgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVMRU1FTlRfVE9fTk9ERSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTk9ERV9UT19FTEVNRU5UID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT0RFX1RPX0tFWSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX0tFWV9UT19FTEVNRU5UID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogV2VhayBtYXBzIGZvciBzdG9yaW5nIGVkaXRvci1yZWxhdGVkIHN0YXRlLlxuICovXG52YXIgSVNfUkVBRF9PTkxZID0gbmV3IFdlYWtNYXAoKTtcbnZhciBJU19GT0NVU0VEID0gbmV3IFdlYWtNYXAoKTtcbnZhciBJU19DT01QT1NJTkcgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19VU0VSX1NFTEVDVElPTiA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIFdlYWsgbWFwIGZvciBhc3NvY2lhdGluZyB0aGUgY29udGV4dCBgb25DaGFuZ2VgIGNvbnRleHQgd2l0aCB0aGUgcGx1Z2luLlxuICovXG52YXIgRURJVE9SX1RPX09OX0NIQU5HRSA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIFdlYWsgbWFwcyBmb3Igc2F2aW5nIHBlbmRpbmcgc3RhdGUgb24gY29tcG9zaXRpb24gc3RhZ2UuXG4gKi9cbnZhciBFRElUT1JfVE9fU0NIRURVTEVfRkxVU0ggPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX1VTRVJfTUFSS1MgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBBbmRyb2lkIGlucHV0IGhhbmRsaW5nIHNwZWNpZmljIHdlYWstbWFwc1xuICovXG52YXIgRURJVE9SX1RPX1BFTkRJTkdfRElGRlMgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19QRU5ESU5HX0FDVElPTiA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fRk9SQ0VfUkVOREVSID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogU3ltYm9scy5cbiAqL1xudmFyIFBMQUNFSE9MREVSX1NZTUJPTCA9IFN5bWJvbCgncGxhY2Vob2xkZXInKTtcbnZhciBNQVJLX1BMQUNFSE9MREVSX1NZTUJPTCA9IFN5bWJvbCgnbWFyay1wbGFjZWhvbGRlcicpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgRE9NRWRpdG9yID0ge1xuICBhbmRyb2lkUGVuZGluZ0RpZmZzOiBlZGl0b3IgPT4gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvciksXG4gIGFuZHJvaWRTY2hlZHVsZUZsdXNoOiBlZGl0b3IgPT4ge1xuICAgIHZhciBfRURJVE9SX1RPX1NDSEVEVUxFX0Y7XG4gICAgKF9FRElUT1JfVE9fU0NIRURVTEVfRiA9IEVESVRPUl9UT19TQ0hFRFVMRV9GTFVTSC5nZXQoZWRpdG9yKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19TQ0hFRFVMRV9GID09PSB2b2lkIDAgfHwgX0VESVRPUl9UT19TQ0hFRFVMRV9GKCk7XG4gIH0sXG4gIGJsdXI6IGVkaXRvciA9PiB7XG4gICAgdmFyIGVsID0gRE9NRWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgdmFyIHJvb3QgPSBET01FZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcik7XG4gICAgSVNfRk9DVVNFRC5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgaWYgKHJvb3QuYWN0aXZlRWxlbWVudCA9PT0gZWwpIHtcbiAgICAgIGVsLmJsdXIoKTtcbiAgICB9XG4gIH0sXG4gIGRlc2VsZWN0OiBlZGl0b3IgPT4ge1xuICAgIHZhciB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gZWRpdG9yO1xuICAgIHZhciByb290ID0gRE9NRWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgIHZhciBkb21TZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24ocm9vdCk7XG4gICAgaWYgKGRvbVNlbGVjdGlvbiAmJiBkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDApIHtcbiAgICAgIGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICB9XG4gICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpO1xuICAgIH1cbiAgfSxcbiAgZmluZERvY3VtZW50T3JTaGFkb3dSb290OiBlZGl0b3IgPT4ge1xuICAgIHZhciBlbCA9IERPTUVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgIHZhciByb290ID0gZWwuZ2V0Um9vdE5vZGUoKTtcbiAgICBpZiAocm9vdCBpbnN0YW5jZW9mIERvY3VtZW50IHx8IHJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG4gICAgcmV0dXJuIGVsLm93bmVyRG9jdW1lbnQ7XG4gIH0sXG4gIGZpbmRFdmVudFJhbmdlOiAoZWRpdG9yLCBldmVudCkgPT4ge1xuICAgIGlmICgnbmF0aXZlRXZlbnQnIGluIGV2ZW50KSB7XG4gICAgICBldmVudCA9IGV2ZW50Lm5hdGl2ZUV2ZW50O1xuICAgIH1cbiAgICB2YXIge1xuICAgICAgY2xpZW50WDogeCxcbiAgICAgIGNsaWVudFk6IHksXG4gICAgICB0YXJnZXRcbiAgICB9ID0gZXZlbnQ7XG4gICAgaWYgKHggPT0gbnVsbCB8fCB5ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgU2xhdGUgcmFuZ2UgZnJvbSBhIERPTSBldmVudDogXCIuY29uY2F0KGV2ZW50KSk7XG4gICAgfVxuICAgIHZhciBub2RlID0gRE9NRWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgZXZlbnQudGFyZ2V0KTtcbiAgICB2YXIgcGF0aCA9IERPTUVkaXRvci5maW5kUGF0aChlZGl0b3IsIG5vZGUpO1xuICAgIC8vIElmIHRoZSBkcm9wIHRhcmdldCBpcyBpbnNpZGUgYSB2b2lkIG5vZGUsIG1vdmUgaXQgaW50byBlaXRoZXIgdGhlXG4gICAgLy8gbmV4dCBvciBwcmV2aW91cyBub2RlLCBkZXBlbmRpbmcgb24gd2hpY2ggc2lkZSB0aGUgYHhgIGFuZCBgeWBcbiAgICAvLyBjb29yZGluYXRlcyBhcmUgY2xvc2VzdCB0by5cbiAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICB2YXIgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBpc1ByZXYgPSBlZGl0b3IuaXNJbmxpbmUobm9kZSkgPyB4IC0gcmVjdC5sZWZ0IDwgcmVjdC5sZWZ0ICsgcmVjdC53aWR0aCAtIHggOiB5IC0gcmVjdC50b3AgPCByZWN0LnRvcCArIHJlY3QuaGVpZ2h0IC0geTtcbiAgICAgIHZhciBlZGdlID0gRWRpdG9yLnBvaW50KGVkaXRvciwgcGF0aCwge1xuICAgICAgICBlZGdlOiBpc1ByZXYgPyAnc3RhcnQnIDogJ2VuZCdcbiAgICAgIH0pO1xuICAgICAgdmFyIHBvaW50ID0gaXNQcmV2ID8gRWRpdG9yLmJlZm9yZShlZGl0b3IsIGVkZ2UpIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgZWRnZSk7XG4gICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgdmFyIF9yYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHBvaW50KTtcbiAgICAgICAgcmV0dXJuIF9yYW5nZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRWxzZSByZXNvbHZlIGEgcmFuZ2UgZnJvbSB0aGUgY2FyZXQgcG9zaXRpb24gd2hlcmUgdGhlIGRyb3Agb2NjdXJlZC5cbiAgICB2YXIgZG9tUmFuZ2U7XG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50XG4gICAgfSA9IERPTUVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcbiAgICAvLyBDT01QQVQ6IEluIEZpcmVmb3gsIGBjYXJldFJhbmdlRnJvbVBvaW50YCBkb2Vzbid0IGV4aXN0LiAoMjAxNi8wNy8yNSlcbiAgICBpZiAoZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCkge1xuICAgICAgZG9tUmFuZ2UgPSBkb2N1bWVudC5jYXJldFJhbmdlRnJvbVBvaW50KHgsIHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSBkb2N1bWVudC5jYXJldFBvc2l0aW9uRnJvbVBvaW50KHgsIHkpO1xuICAgICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICAgIGRvbVJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgZG9tUmFuZ2Uuc2V0U3RhcnQocG9zaXRpb24ub2Zmc2V0Tm9kZSwgcG9zaXRpb24ub2Zmc2V0KTtcbiAgICAgICAgZG9tUmFuZ2Uuc2V0RW5kKHBvc2l0aW9uLm9mZnNldE5vZGUsIHBvc2l0aW9uLm9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZG9tUmFuZ2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgU2xhdGUgcmFuZ2UgZnJvbSBhIERPTSBldmVudDogXCIuY29uY2F0KGV2ZW50KSk7XG4gICAgfVxuICAgIC8vIFJlc29sdmUgYSBTbGF0ZSByYW5nZSBmcm9tIHRoZSBET00gcmFuZ2UuXG4gICAgdmFyIHJhbmdlID0gRE9NRWRpdG9yLnRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVJhbmdlLCB7XG4gICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgIHN1cHByZXNzVGhyb3c6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9LFxuICBmaW5kS2V5OiAoZWRpdG9yLCBub2RlKSA9PiB7XG4gICAgdmFyIGtleSA9IE5PREVfVE9fS0VZLmdldChub2RlKTtcbiAgICBpZiAoIWtleSkge1xuICAgICAga2V5ID0gbmV3IEtleSgpO1xuICAgICAgTk9ERV9UT19LRVkuc2V0KG5vZGUsIGtleSk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0sXG4gIGZpbmRQYXRoOiAoZWRpdG9yLCBub2RlKSA9PiB7XG4gICAgdmFyIHBhdGggPSBbXTtcbiAgICB2YXIgY2hpbGQgPSBub2RlO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgcGFyZW50ID0gTk9ERV9UT19QQVJFTlQuZ2V0KGNoaWxkKTtcbiAgICAgIGlmIChwYXJlbnQgPT0gbnVsbCkge1xuICAgICAgICBpZiAoRWRpdG9yLmlzRWRpdG9yKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaSA9IE5PREVfVE9fSU5ERVguZ2V0KGNoaWxkKTtcbiAgICAgIGlmIChpID09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwYXRoLnVuc2hpZnQoaSk7XG4gICAgICBjaGlsZCA9IHBhcmVudDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgdGhlIHBhdGggZm9yIFNsYXRlIG5vZGU6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgfSxcbiAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgICByZXRyaWVzOiA1XG4gICAgfTtcbiAgICAvLyBSZXR1cm4gaWYgYWxyZWFkeSBmb2N1c2VkXG4gICAgaWYgKElTX0ZPQ1VTRUQuZ2V0KGVkaXRvcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmV0cnkgc2V0dGluZyBmb2N1cyBpZiB0aGUgZWRpdG9yIGhhcyBwZW5kaW5nIG9wZXJhdGlvbnMuXG4gICAgLy8gVGhlIERPTSAoc2VsZWN0aW9uKSBpcyB1bnN0YWJsZSB3aGlsZSBjaGFuZ2VzIGFyZSBhcHBsaWVkLlxuICAgIC8vIFJldHJ5IHVudGlsIHJldHJpZXMgYXJlIGV4aGF1c3RlZCBvciBlZGl0b3IgaXMgZm9jdXNlZC5cbiAgICBpZiAob3B0aW9ucy5yZXRyaWVzIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHNldCBmb2N1cywgZWRpdG9yIHNlZW1zIHN0dWNrIHdpdGggcGVuZGluZyBvcGVyYXRpb25zJyk7XG4gICAgfVxuICAgIGlmIChlZGl0b3Iub3BlcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgRE9NRWRpdG9yLmZvY3VzKGVkaXRvciwge1xuICAgICAgICAgIHJldHJpZXM6IG9wdGlvbnMucmV0cmllcyAtIDFcbiAgICAgICAgfSk7XG4gICAgICB9LCAxMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBlbCA9IERPTUVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgIHZhciByb290ID0gRE9NRWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgIGlmIChyb290LmFjdGl2ZUVsZW1lbnQgIT09IGVsKSB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgRE9NIHNlbGVjdGlvbiBzdGF0ZSBpcyBzZXQgdG8gdGhlIGVkaXRvcidzIHNlbGVjdGlvblxuICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24gJiYgcm9vdCBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgICAgIHZhciBkb21TZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24ocm9vdCk7XG4gICAgICAgIHZhciBkb21SYW5nZSA9IERPTUVkaXRvci50b0RPTVJhbmdlKGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbik7XG4gICAgICAgIGRvbVNlbGVjdGlvbiA9PT0gbnVsbCB8fCBkb21TZWxlY3Rpb24gPT09IHZvaWQgMCB8fCBkb21TZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIGRvbVNlbGVjdGlvbiA9PT0gbnVsbCB8fCBkb21TZWxlY3Rpb24gPT09IHZvaWQgMCB8fCBkb21TZWxlY3Rpb24uYWRkUmFuZ2UoZG9tUmFuZ2UpO1xuICAgICAgfVxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IHNlbGVjdGlvbiBpbiB0aGUgdG9wIG9mIHRoZSBkb2N1bWVudCBpZiBtaXNzaW5nXG4gICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbXSkpO1xuICAgICAgfVxuICAgICAgLy8gSVNfRk9DVVNFRCBzaG91bGQgYmUgc2V0IGJlZm9yZSBjYWxsaW5nIGVsLmZvY3VzKCkgdG8gZW5zdXJlIHRoYXRcbiAgICAgIC8vIEZvY3VzZWRDb250ZXh0IGlzIHVwZGF0ZWQgdG8gdGhlIGNvcnJlY3QgdmFsdWVcbiAgICAgIElTX0ZPQ1VTRUQuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gICAgICBlbC5mb2N1cyh7XG4gICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgZ2V0V2luZG93OiBlZGl0b3IgPT4ge1xuICAgIHZhciB3aW5kb3cgPSBFRElUT1JfVE9fV0lORE9XLmdldChlZGl0b3IpO1xuICAgIGlmICghd2luZG93KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIGEgaG9zdCB3aW5kb3cgZWxlbWVudCBmb3IgdGhpcyBlZGl0b3InKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfSxcbiAgaGFzRE9NTm9kZTogZnVuY3Rpb24gaGFzRE9NTm9kZShlZGl0b3IsIHRhcmdldCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgZWRpdGFibGUgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBlZGl0b3JFbCA9IERPTUVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgIHZhciB0YXJnZXRFbDtcbiAgICAvLyBDT01QQVQ6IEluIEZpcmVmb3gsIHJlYWRpbmcgYHRhcmdldC5ub2RlVHlwZWAgd2lsbCB0aHJvdyBhbiBlcnJvciBpZlxuICAgIC8vIHRhcmdldCBpcyBvcmlnaW5hdGluZyBmcm9tIGFuIGludGVybmFsIFwicmVzdHJpY3RlZFwiIGVsZW1lbnQgKGUuZy4gYVxuICAgIC8vIHN0ZXBwZXIgYXJyb3cgb24gYSBudW1iZXIgaW5wdXQpLiAoMjAxOC8wNS8wNClcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaWFuc3Rvcm10YXlsb3Ivc2xhdGUvaXNzdWVzLzE4MTlcbiAgICB0cnkge1xuICAgICAgdGFyZ2V0RWwgPSBpc0RPTUVsZW1lbnQodGFyZ2V0KSA/IHRhcmdldCA6IHRhcmdldC5wYXJlbnRFbGVtZW50O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yICYmICFlcnIubWVzc2FnZS5pbmNsdWRlcygnUGVybWlzc2lvbiBkZW5pZWQgdG8gYWNjZXNzIHByb3BlcnR5IFwibm9kZVR5cGVcIicpKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0YXJnZXRFbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0RWwuY2xvc2VzdChcIltkYXRhLXNsYXRlLWVkaXRvcl1cIikgPT09IGVkaXRvckVsICYmICghZWRpdGFibGUgfHwgdGFyZ2V0RWwuaXNDb250ZW50RWRpdGFibGUgPyB0cnVlIDogdHlwZW9mIHRhcmdldEVsLmlzQ29udGVudEVkaXRhYmxlID09PSAnYm9vbGVhbicgJiZcbiAgICAvLyBpc0NvbnRlbnRFZGl0YWJsZSBleGlzdHMgb25seSBvbiBIVE1MRWxlbWVudCwgYW5kIG9uIG90aGVyIG5vZGVzIGl0IHdpbGwgYmUgdW5kZWZpbmVkXG4gICAgLy8gdGhpcyBpcyB0aGUgY29yZSBsb2dpYyB0aGF0IGxldHMgeW91IGtub3cgeW91IGdvdCB0aGUgcmlnaHQgZWRpdG9yLnNlbGVjdGlvbiBpbnN0ZWFkIG9mIG51bGwgd2hlbiBlZGl0b3IgaXMgY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIihyZWFkT25seSlcbiAgICB0YXJnZXRFbC5jbG9zZXN0KCdbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0nKSA9PT0gZWRpdG9yRWwgfHwgISF0YXJnZXRFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpKTtcbiAgfSxcbiAgaGFzRWRpdGFibGVUYXJnZXQ6IChlZGl0b3IsIHRhcmdldCkgPT4gaXNET01Ob2RlKHRhcmdldCkgJiYgRE9NRWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCB0YXJnZXQsIHtcbiAgICBlZGl0YWJsZTogdHJ1ZVxuICB9KSxcbiAgaGFzUmFuZ2U6IChlZGl0b3IsIHJhbmdlKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHJhbmdlO1xuICAgIHJldHVybiBFZGl0b3IuaGFzUGF0aChlZGl0b3IsIGFuY2hvci5wYXRoKSAmJiBFZGl0b3IuaGFzUGF0aChlZGl0b3IsIGZvY3VzLnBhdGgpO1xuICB9LFxuICBoYXNTZWxlY3RhYmxlVGFyZ2V0OiAoZWRpdG9yLCB0YXJnZXQpID0+IERPTUVkaXRvci5oYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIHRhcmdldCkgfHwgRE9NRWRpdG9yLmlzVGFyZ2V0SW5zaWRlTm9uUmVhZG9ubHlWb2lkKGVkaXRvciwgdGFyZ2V0KSxcbiAgaGFzVGFyZ2V0OiAoZWRpdG9yLCB0YXJnZXQpID0+IGlzRE9NTm9kZSh0YXJnZXQpICYmIERPTUVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgdGFyZ2V0KSxcbiAgaW5zZXJ0RGF0YTogKGVkaXRvciwgZGF0YSkgPT4ge1xuICAgIGVkaXRvci5pbnNlcnREYXRhKGRhdGEpO1xuICB9LFxuICBpbnNlcnRGcmFnbWVudERhdGE6IChlZGl0b3IsIGRhdGEpID0+IGVkaXRvci5pbnNlcnRGcmFnbWVudERhdGEoZGF0YSksXG4gIGluc2VydFRleHREYXRhOiAoZWRpdG9yLCBkYXRhKSA9PiBlZGl0b3IuaW5zZXJ0VGV4dERhdGEoZGF0YSksXG4gIGlzQ29tcG9zaW5nOiBlZGl0b3IgPT4ge1xuICAgIHJldHVybiAhIUlTX0NPTVBPU0lORy5nZXQoZWRpdG9yKTtcbiAgfSxcbiAgaXNGb2N1c2VkOiBlZGl0b3IgPT4gISFJU19GT0NVU0VELmdldChlZGl0b3IpLFxuICBpc1JlYWRPbmx5OiBlZGl0b3IgPT4gISFJU19SRUFEX09OTFkuZ2V0KGVkaXRvciksXG4gIGlzVGFyZ2V0SW5zaWRlTm9uUmVhZG9ubHlWb2lkOiAoZWRpdG9yLCB0YXJnZXQpID0+IHtcbiAgICBpZiAoSVNfUkVBRF9PTkxZLmdldChlZGl0b3IpKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHNsYXRlTm9kZSA9IERPTUVkaXRvci5oYXNUYXJnZXQoZWRpdG9yLCB0YXJnZXQpICYmIERPTUVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIHRhcmdldCk7XG4gICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KHNsYXRlTm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIHNsYXRlTm9kZSk7XG4gIH0sXG4gIHNldEZyYWdtZW50RGF0YTogKGVkaXRvciwgZGF0YSwgb3JpZ2luRXZlbnQpID0+IGVkaXRvci5zZXRGcmFnbWVudERhdGEoZGF0YSwgb3JpZ2luRXZlbnQpLFxuICB0b0RPTU5vZGU6IChlZGl0b3IsIG5vZGUpID0+IHtcbiAgICB2YXIgS0VZX1RPX0VMRU1FTlQgPSBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQuZ2V0KGVkaXRvcik7XG4gICAgdmFyIGRvbU5vZGUgPSBFZGl0b3IuaXNFZGl0b3Iobm9kZSkgPyBFRElUT1JfVE9fRUxFTUVOVC5nZXQoZWRpdG9yKSA6IEtFWV9UT19FTEVNRU5UID09PSBudWxsIHx8IEtFWV9UT19FTEVNRU5UID09PSB2b2lkIDAgPyB2b2lkIDAgOiBLRVlfVE9fRUxFTUVOVC5nZXQoRE9NRWRpdG9yLmZpbmRLZXkoZWRpdG9yLCBub2RlKSk7XG4gICAgaWYgKCFkb21Ob2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIERPTSBub2RlIGZyb20gU2xhdGUgbm9kZTogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gZG9tTm9kZTtcbiAgfSxcbiAgdG9ET01Qb2ludDogKGVkaXRvciwgcG9pbnQpID0+IHtcbiAgICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwb2ludC5wYXRoKTtcbiAgICB2YXIgZWwgPSBET01FZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgbm9kZSk7XG4gICAgdmFyIGRvbVBvaW50O1xuICAgIC8vIElmIHdlJ3JlIGluc2lkZSBhIHZvaWQgbm9kZSwgZm9yY2UgdGhlIG9mZnNldCB0byAwLCBvdGhlcndpc2UgdGhlIHplcm9cbiAgICAvLyB3aWR0aCBzcGFjaW5nIGNoYXJhY3RlciB3aWxsIHJlc3VsdCBpbiBhbiBpbmNvcnJlY3Qgb2Zmc2V0IG9mIDFcbiAgICBpZiAoRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICBhdDogcG9pbnRcbiAgICB9KSkge1xuICAgICAgcG9pbnQgPSB7XG4gICAgICAgIHBhdGg6IHBvaW50LnBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gRm9yIGVhY2ggbGVhZiwgd2UgbmVlZCB0byBpc29sYXRlIGl0cyBjb250ZW50LCB3aGljaCBtZWFucyBmaWx0ZXJpbmdcbiAgICAvLyB0byBpdHMgZGlyZWN0IHRleHQgYW5kIHplcm8td2lkdGggc3BhbnMuIChXZSBoYXZlIHRvIGZpbHRlciBvdXQgYW55XG4gICAgLy8gb3RoZXIgc2libGluZ3MgdGhhdCBtYXkgaGF2ZSBiZWVuIHJlbmRlcmVkIGFsb25nc2lkZSB0aGVtLilcbiAgICB2YXIgc2VsZWN0b3IgPSBcIltkYXRhLXNsYXRlLXN0cmluZ10sIFtkYXRhLXNsYXRlLXplcm8td2lkdGhdXCI7XG4gICAgdmFyIHRleHRzID0gQXJyYXkuZnJvbShlbC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdGV4dCA9IHRleHRzW2ldO1xuICAgICAgdmFyIGRvbU5vZGUgPSB0ZXh0LmNoaWxkTm9kZXNbMF07XG4gICAgICBpZiAoZG9tTm9kZSA9PSBudWxsIHx8IGRvbU5vZGUudGV4dENvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciB7XG4gICAgICAgIGxlbmd0aFxuICAgICAgfSA9IGRvbU5vZGUudGV4dENvbnRlbnQ7XG4gICAgICB2YXIgYXR0ciA9IHRleHQuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLWxlbmd0aCcpO1xuICAgICAgdmFyIHRydWVMZW5ndGggPSBhdHRyID09IG51bGwgPyBsZW5ndGggOiBwYXJzZUludChhdHRyLCAxMCk7XG4gICAgICB2YXIgZW5kID0gc3RhcnQgKyB0cnVlTGVuZ3RoO1xuICAgICAgLy8gUHJlZmVyIHB1dHRpbmcgdGhlIHNlbGVjdGlvbiBpbnNpZGUgdGhlIG1hcmsgcGxhY2Vob2xkZXIgdG8gZW5zdXJlXG4gICAgICAvLyBjb21wb3NlZCB0ZXh0IGlzIGRpc3BsYXllZCB3aXRoIHRoZSBjb3JyZWN0IG1hcmtzLlxuICAgICAgdmFyIG5leHRUZXh0ID0gdGV4dHNbaSArIDFdO1xuICAgICAgaWYgKHBvaW50Lm9mZnNldCA9PT0gZW5kICYmIG5leHRUZXh0ICE9PSBudWxsICYmIG5leHRUZXh0ICE9PSB2b2lkIDAgJiYgbmV4dFRleHQuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLW1hcmstcGxhY2Vob2xkZXInKSkge1xuICAgICAgICB2YXIgX25leHRUZXh0JHRleHRDb250ZW50O1xuICAgICAgICB2YXIgZG9tVGV4dCA9IG5leHRUZXh0LmNoaWxkTm9kZXNbMF07XG4gICAgICAgIGRvbVBvaW50ID0gW1xuICAgICAgICAvLyBDT01QQVQ6IElmIHdlIGRvbid0IGV4cGxpY2l0eSBzZXQgdGhlIGRvbSBwb2ludCB0byBiZSBvbiB0aGUgYWN0dWFsXG4gICAgICAgIC8vIGRvbSB0ZXh0IGVsZW1lbnQsIGNocm9tZSB3aWxsIHB1dCB0aGUgc2VsZWN0aW9uIGJlaGluZCB0aGUgYWN0dWFsIGRvbVxuICAgICAgICAvLyB0ZXh0IGVsZW1lbnQsIGNhdXNpbmcgZG9tUmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgY2FsbHMgb24gYSBjb2xsYXBzZWRcbiAgICAgICAgLy8gc2VsZWN0aW9uIHRvIHJldHVybiBpbmNvcnJlY3QgemVybyB2YWx1ZXMgKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQzNTQzOClcbiAgICAgICAgLy8gd2hpY2ggd2lsbCBjYXVzZSBpc3N1ZXMgd2hlbiBzY3JvbGxpbmcgdG8gaXQuXG4gICAgICAgIGRvbVRleHQgaW5zdGFuY2VvZiBET01UZXh0ID8gZG9tVGV4dCA6IG5leHRUZXh0LCAoX25leHRUZXh0JHRleHRDb250ZW50ID0gbmV4dFRleHQudGV4dENvbnRlbnQpICE9PSBudWxsICYmIF9uZXh0VGV4dCR0ZXh0Q29udGVudCAhPT0gdm9pZCAwICYmIF9uZXh0VGV4dCR0ZXh0Q29udGVudC5zdGFydHNXaXRoKCdcXHVGRUZGJykgPyAxIDogMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHBvaW50Lm9mZnNldCA8PSBlbmQpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IE1hdGgubWluKGxlbmd0aCwgTWF0aC5tYXgoMCwgcG9pbnQub2Zmc2V0IC0gc3RhcnQpKTtcbiAgICAgICAgZG9tUG9pbnQgPSBbZG9tTm9kZSwgb2Zmc2V0XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGFydCA9IGVuZDtcbiAgICB9XG4gICAgaWYgKCFkb21Qb2ludCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBET00gcG9pbnQgZnJvbSBTbGF0ZSBwb2ludDogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShwb2ludCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbVBvaW50O1xuICB9LFxuICB0b0RPTVJhbmdlOiAoZWRpdG9yLCByYW5nZSkgPT4ge1xuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSByYW5nZTtcbiAgICB2YXIgaXNCYWNrd2FyZCA9IFJhbmdlLmlzQmFja3dhcmQocmFuZ2UpO1xuICAgIHZhciBkb21BbmNob3IgPSBET01FZGl0b3IudG9ET01Qb2ludChlZGl0b3IsIGFuY2hvcik7XG4gICAgdmFyIGRvbUZvY3VzID0gUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpID8gZG9tQW5jaG9yIDogRE9NRWRpdG9yLnRvRE9NUG9pbnQoZWRpdG9yLCBmb2N1cyk7XG4gICAgdmFyIHdpbmRvdyA9IERPTUVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcbiAgICB2YXIgZG9tUmFuZ2UgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICB2YXIgW3N0YXJ0Tm9kZSwgc3RhcnRPZmZzZXRdID0gaXNCYWNrd2FyZCA/IGRvbUZvY3VzIDogZG9tQW5jaG9yO1xuICAgIHZhciBbZW5kTm9kZSwgZW5kT2Zmc2V0XSA9IGlzQmFja3dhcmQgPyBkb21BbmNob3IgOiBkb21Gb2N1cztcbiAgICAvLyBBIHNsYXRlIFBvaW50IGF0IHplcm8td2lkdGggTGVhZiBhbHdheXMgaGFzIGFuIG9mZnNldCBvZiAwIGJ1dCBhIG5hdGl2ZSBET00gc2VsZWN0aW9uIGF0XG4gICAgLy8gemVyby13aWR0aCBub2RlIGhhcyBhbiBvZmZzZXQgb2YgMSBzbyB3ZSBoYXZlIHRvIGNoZWNrIGlmIHdlIGFyZSBpbiBhIHplcm8td2lkdGggbm9kZSBhbmRcbiAgICAvLyBhZGp1c3QgdGhlIG9mZnNldCBhY2NvcmRpbmdseS5cbiAgICB2YXIgc3RhcnRFbCA9IGlzRE9NRWxlbWVudChzdGFydE5vZGUpID8gc3RhcnROb2RlIDogc3RhcnROb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgdmFyIGlzU3RhcnRBdFplcm9XaWR0aCA9ICEhc3RhcnRFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpO1xuICAgIHZhciBlbmRFbCA9IGlzRE9NRWxlbWVudChlbmROb2RlKSA/IGVuZE5vZGUgOiBlbmROb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgdmFyIGlzRW5kQXRaZXJvV2lkdGggPSAhIWVuZEVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJyk7XG4gICAgZG9tUmFuZ2Uuc2V0U3RhcnQoc3RhcnROb2RlLCBpc1N0YXJ0QXRaZXJvV2lkdGggPyAxIDogc3RhcnRPZmZzZXQpO1xuICAgIGRvbVJhbmdlLnNldEVuZChlbmROb2RlLCBpc0VuZEF0WmVyb1dpZHRoID8gMSA6IGVuZE9mZnNldCk7XG4gICAgcmV0dXJuIGRvbVJhbmdlO1xuICB9LFxuICB0b1NsYXRlTm9kZTogKGVkaXRvciwgZG9tTm9kZSkgPT4ge1xuICAgIHZhciBkb21FbCA9IGlzRE9NRWxlbWVudChkb21Ob2RlKSA/IGRvbU5vZGUgOiBkb21Ob2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgaWYgKGRvbUVsICYmICFkb21FbC5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtbm9kZScpKSB7XG4gICAgICBkb21FbCA9IGRvbUVsLmNsb3Nlc3QoXCJbZGF0YS1zbGF0ZS1ub2RlXVwiKTtcbiAgICB9XG4gICAgdmFyIG5vZGUgPSBkb21FbCA/IEVMRU1FTlRfVE9fTk9ERS5nZXQoZG9tRWwpIDogbnVsbDtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgU2xhdGUgbm9kZSBmcm9tIERPTSBub2RlOiBcIi5jb25jYXQoZG9tRWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG4gIHRvU2xhdGVQb2ludDogKGVkaXRvciwgZG9tUG9pbnQsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIge1xuICAgICAgZXhhY3RNYXRjaCxcbiAgICAgIHN1cHByZXNzVGhyb3csXG4gICAgICBzZWFyY2hEaXJlY3Rpb24gPSAnYmFja3dhcmQnXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIFtuZWFyZXN0Tm9kZSwgbmVhcmVzdE9mZnNldF0gPSBleGFjdE1hdGNoID8gZG9tUG9pbnQgOiBub3JtYWxpemVET01Qb2ludChkb21Qb2ludCk7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBuZWFyZXN0Tm9kZS5wYXJlbnROb2RlO1xuICAgIHZhciB0ZXh0Tm9kZSA9IG51bGw7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgIHZhciBfZG9tTm9kZSR0ZXh0Q29udGVudCwgX2RvbU5vZGUkdGV4dENvbnRlbnQyO1xuICAgICAgdmFyIGVkaXRvckVsID0gRE9NRWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgICB2YXIgcG90ZW50aWFsVm9pZE5vZGUgPSBwYXJlbnROb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLXZvaWQ9XCJ0cnVlXCJdJyk7XG4gICAgICAvLyBOZWVkIHRvIGVuc3VyZSB0aGF0IHRoZSBjbG9zZXN0IHZvaWQgbm9kZSBpcyBhY3R1YWxseSBhIHZvaWQgbm9kZVxuICAgICAgLy8gd2l0aGluIHRoaXMgZWRpdG9yLCBhbmQgbm90IGEgdm9pZCBub2RlIHdpdGhpbiBzb21lIHBhcmVudCBlZGl0b3IuIFRoaXMgY2FuIGhhcHBlblxuICAgICAgLy8gaWYgdGhpcyBlZGl0b3IgaXMgd2l0aGluIGEgdm9pZCBub2RlIG9mIGFub3RoZXIgZWRpdG9yIChcIm5lc3RlZCBlZGl0b3JzXCIsIGxpa2UgaW5cbiAgICAgIC8vIHRoZSBcIkVkaXRhYmxlIFZvaWRzXCIgZXhhbXBsZSBvbiB0aGUgZG9jcyBzaXRlKS5cbiAgICAgIHZhciB2b2lkTm9kZSA9IHBvdGVudGlhbFZvaWROb2RlICYmIGVkaXRvckVsLmNvbnRhaW5zKHBvdGVudGlhbFZvaWROb2RlKSA/IHBvdGVudGlhbFZvaWROb2RlIDogbnVsbDtcbiAgICAgIHZhciBwb3RlbnRpYWxOb25FZGl0YWJsZU5vZGUgPSBwYXJlbnROb2RlLmNsb3Nlc3QoJ1tjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXScpO1xuICAgICAgdmFyIG5vbkVkaXRhYmxlTm9kZSA9IHBvdGVudGlhbE5vbkVkaXRhYmxlTm9kZSAmJiBlZGl0b3JFbC5jb250YWlucyhwb3RlbnRpYWxOb25FZGl0YWJsZU5vZGUpID8gcG90ZW50aWFsTm9uRWRpdGFibGVOb2RlIDogbnVsbDtcbiAgICAgIHZhciBsZWFmTm9kZSA9IHBhcmVudE5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbGVhZl0nKTtcbiAgICAgIHZhciBkb21Ob2RlID0gbnVsbDtcbiAgICAgIC8vIENhbGN1bGF0ZSBob3cgZmFyIGludG8gdGhlIHRleHQgbm9kZSB0aGUgYG5lYXJlc3ROb2RlYCBpcywgc28gdGhhdCB3ZVxuICAgICAgLy8gY2FuIGRldGVybWluZSB3aGF0IHRoZSBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIHRleHQgbm9kZSBpcy5cbiAgICAgIGlmIChsZWFmTm9kZSkge1xuICAgICAgICB0ZXh0Tm9kZSA9IGxlYWZOb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLW5vZGU9XCJ0ZXh0XCJdJyk7XG4gICAgICAgIGlmICh0ZXh0Tm9kZSkge1xuICAgICAgICAgIHZhciB3aW5kb3cgPSBET01FZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7XG4gICAgICAgICAgdmFyIHJhbmdlID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQodGV4dE5vZGUsIDApO1xuICAgICAgICAgIHJhbmdlLnNldEVuZChuZWFyZXN0Tm9kZSwgbmVhcmVzdE9mZnNldCk7XG4gICAgICAgICAgdmFyIGNvbnRlbnRzID0gcmFuZ2UuY2xvbmVDb250ZW50cygpO1xuICAgICAgICAgIHZhciByZW1vdmFscyA9IFsuLi5BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb250ZW50cy5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXScpKSwgLi4uQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGVudHMucXVlcnlTZWxlY3RvckFsbCgnW2NvbnRlbnRlZGl0YWJsZT1mYWxzZV0nKSldO1xuICAgICAgICAgIHJlbW92YWxzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgLy8gQ09NUEFUOiBXaGlsZSBjb21wb3NpbmcgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dCBub2RlLCBzb21lIGtleWJvYXJkcyBwdXRcbiAgICAgICAgICAgIC8vIHRoZSB0ZXh0IGNvbnRlbnQgaW5zaWRlIHRoZSB6ZXJvIHdpZHRoIHNwYWNlLlxuICAgICAgICAgICAgaWYgKElTX0FORFJPSUQgJiYgIWV4YWN0TWF0Y2ggJiYgZWwuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSAmJiBlbC50ZXh0Q29udGVudC5sZW5ndGggPiAwICYmIGVsLnRleHRDb250ZXh0ICE9PSAnXFx1RkVGRicpIHtcbiAgICAgICAgICAgICAgaWYgKGVsLnRleHRDb250ZW50LnN0YXJ0c1dpdGgoJ1xcdUZFRkYnKSkge1xuICAgICAgICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gZWwudGV4dENvbnRlbnQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gQ09NUEFUOiBFZGdlIGhhcyBhIGJ1ZyB3aGVyZSBSYW5nZS5wcm90b3R5cGUudG9TdHJpbmcoKSB3aWxsXG4gICAgICAgICAgLy8gY29udmVydCBcXG4gaW50byBcXHJcXG4uIFRoZSBidWcgY2F1c2VzIGEgbG9vcCB3aGVuIHNsYXRlLWRvbVxuICAgICAgICAgIC8vIGF0dGVtcHRzIHRvIHJlcG9zaXRpb24gaXRzIGN1cnNvciB0byBtYXRjaCB0aGUgbmF0aXZlIHBvc2l0aW9uLiBVc2VcbiAgICAgICAgICAvLyB0ZXh0Q29udGVudC5sZW5ndGggaW5zdGVhZC5cbiAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMDI5MTExNi9cbiAgICAgICAgICBvZmZzZXQgPSBjb250ZW50cy50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICAgICAgZG9tTm9kZSA9IHRleHROb2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHZvaWROb2RlKSB7XG4gICAgICAgIC8vIEZvciB2b2lkIG5vZGVzLCB0aGUgZWxlbWVudCB3aXRoIHRoZSBvZmZzZXQga2V5IHdpbGwgYmUgYSBjb3VzaW4sIG5vdCBhblxuICAgICAgICAvLyBhbmNlc3Rvciwgc28gZmluZCBpdCBieSBnb2luZyBkb3duIGZyb20gdGhlIG5lYXJlc3Qgdm9pZCBwYXJlbnQgYW5kIHRha2luZyB0aGVcbiAgICAgICAgLy8gZmlyc3Qgb25lIHRoYXQgaXNuJ3QgaW5zaWRlIGEgbmVzdGVkIGVkaXRvci5cbiAgICAgICAgdmFyIGxlYWZOb2RlcyA9IHZvaWROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNsYXRlLWxlYWZdJyk7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZWFmTm9kZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBsZWFmTm9kZXNbaW5kZXhdO1xuICAgICAgICAgIGlmIChET01FZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBsZWFmTm9kZSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ09NUEFUOiBJbiByZWFkLW9ubHkgZWRpdG9ycyB0aGUgbGVhZiBpcyBub3QgcmVuZGVyZWQuXG4gICAgICAgIGlmICghbGVhZk5vZGUpIHtcbiAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHROb2RlID0gbGVhZk5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbm9kZT1cInRleHRcIl0nKTtcbiAgICAgICAgICBkb21Ob2RlID0gbGVhZk5vZGU7XG4gICAgICAgICAgb2Zmc2V0ID0gZG9tTm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICAgICAgZG9tTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXScpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgb2Zmc2V0IC09IGVsLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub25FZGl0YWJsZU5vZGUpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgZWRnZSBvZiB0aGUgbmVhcmVzdCBsZWFmIGluIGBzZWFyY2hEaXJlY3Rpb25gXG4gICAgICAgIHZhciBnZXRMZWFmTm9kZXMgPSBub2RlID0+IG5vZGUgPyBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgIC8vIEV4Y2x1ZGUgbGVhZiBub2RlcyBpbiBuZXN0ZWQgZWRpdG9yc1xuICAgICAgICAnW2RhdGEtc2xhdGUtbGVhZl06bm90KDpzY29wZSBbZGF0YS1zbGF0ZS1lZGl0b3JdIFtkYXRhLXNsYXRlLWxlYWZdKScpIDogW107XG4gICAgICAgIHZhciBlbGVtZW50Tm9kZSA9IG5vbkVkaXRhYmxlTm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS1ub2RlPVwiZWxlbWVudFwiXScpO1xuICAgICAgICBpZiAoc2VhcmNoRGlyZWN0aW9uID09PSAnZm9yd2FyZCcpIHtcbiAgICAgICAgICB2YXIgX2xlYWZOb2RlcyRmaW5kO1xuICAgICAgICAgIHZhciBfbGVhZk5vZGVzID0gWy4uLmdldExlYWZOb2RlcyhlbGVtZW50Tm9kZSksIC4uLmdldExlYWZOb2RlcyhlbGVtZW50Tm9kZSA9PT0gbnVsbCB8fCBlbGVtZW50Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudE5vZGUubmV4dEVsZW1lbnRTaWJsaW5nKV07XG4gICAgICAgICAgbGVhZk5vZGUgPSAoX2xlYWZOb2RlcyRmaW5kID0gX2xlYWZOb2Rlcy5maW5kKGxlYWYgPT4gaXNBZnRlcihub25FZGl0YWJsZU5vZGUsIGxlYWYpKSkgIT09IG51bGwgJiYgX2xlYWZOb2RlcyRmaW5kICE9PSB2b2lkIDAgPyBfbGVhZk5vZGVzJGZpbmQgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfbGVhZk5vZGVzMiRmaW5kTGFzdDtcbiAgICAgICAgICB2YXIgX2xlYWZOb2RlczIgPSBbLi4uZ2V0TGVhZk5vZGVzKGVsZW1lbnROb2RlID09PSBudWxsIHx8IGVsZW1lbnROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbGVtZW50Tm9kZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSwgLi4uZ2V0TGVhZk5vZGVzKGVsZW1lbnROb2RlKV07XG4gICAgICAgICAgbGVhZk5vZGUgPSAoX2xlYWZOb2RlczIkZmluZExhc3QgPSBfbGVhZk5vZGVzMi5maW5kTGFzdChsZWFmID0+IGlzQmVmb3JlKG5vbkVkaXRhYmxlTm9kZSwgbGVhZikpKSAhPT0gbnVsbCAmJiBfbGVhZk5vZGVzMiRmaW5kTGFzdCAhPT0gdm9pZCAwID8gX2xlYWZOb2RlczIkZmluZExhc3QgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWFmTm9kZSkge1xuICAgICAgICAgIHRleHROb2RlID0gbGVhZk5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbm9kZT1cInRleHRcIl0nKTtcbiAgICAgICAgICBkb21Ob2RlID0gbGVhZk5vZGU7XG4gICAgICAgICAgaWYgKHNlYXJjaERpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBkb21Ob2RlLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIGRvbU5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2xhdGUtemVyby13aWR0aF0nKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAgb2Zmc2V0IC09IGVsLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRvbU5vZGUgJiYgb2Zmc2V0ID09PSBkb21Ob2RlLnRleHRDb250ZW50Lmxlbmd0aCAmJlxuICAgICAgLy8gQ09NUEFUOiBBbmRyb2lkIElNRXMgbWlnaHQgcmVtb3ZlIHRoZSB6ZXJvIHdpZHRoIHNwYWNlIHdoaWxlIGNvbXBvc2luZyxcbiAgICAgIC8vIGFuZCB3ZSBkb24ndCBhZGQgaXQgZm9yIGxpbmUtYnJlYWtzLlxuICAgICAgSVNfQU5EUk9JRCAmJiBkb21Ob2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykgPT09ICd6JyAmJiAoX2RvbU5vZGUkdGV4dENvbnRlbnQgPSBkb21Ob2RlLnRleHRDb250ZW50KSAhPT0gbnVsbCAmJiBfZG9tTm9kZSR0ZXh0Q29udGVudCAhPT0gdm9pZCAwICYmIF9kb21Ob2RlJHRleHRDb250ZW50LnN0YXJ0c1dpdGgoJ1xcdUZFRkYnKSAmJiAoXG4gICAgICAvLyBDT01QQVQ6IElmIHRoZSBwYXJlbnQgbm9kZSBpcyBhIFNsYXRlIHplcm8td2lkdGggc3BhY2UsIGVkaXRvciBpc1xuICAgICAgLy8gYmVjYXVzZSB0aGUgdGV4dCBub2RlIHNob3VsZCBoYXZlIG5vIGNoYXJhY3RlcnMuIEhvd2V2ZXIsIGR1cmluZyBJTUVcbiAgICAgIC8vIGNvbXBvc2l0aW9uIHRoZSBBU0NJSSBjaGFyYWN0ZXJzIHdpbGwgYmUgcHJlcGVuZGVkIHRvIHRoZSB6ZXJvLXdpZHRoXG4gICAgICAvLyBzcGFjZSwgc28gc3VidHJhY3QgMSBmcm9tIHRoZSBvZmZzZXQgdG8gYWNjb3VudCBmb3IgdGhlIHplcm8td2lkdGhcbiAgICAgIC8vIHNwYWNlIGNoYXJhY3Rlci5cbiAgICAgIHBhcmVudE5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSB8fFxuICAgICAgLy8gQ09NUEFUOiBJbiBGaXJlZm94LCBgcmFuZ2UuY2xvbmVDb250ZW50cygpYCByZXR1cm5zIGFuIGV4dHJhIHRyYWlsaW5nICdcXG4nXG4gICAgICAvLyB3aGVuIHRoZSBkb2N1bWVudCBlbmRzIHdpdGggYSBuZXctbGluZSBjaGFyYWN0ZXIuIFRoaXMgcmVzdWx0cyBpbiB0aGUgb2Zmc2V0XG4gICAgICAvLyBsZW5ndGggYmVpbmcgb2ZmIGJ5IG9uZSwgc28gd2UgbmVlZCB0byBzdWJ0cmFjdCBvbmUgdG8gYWNjb3VudCBmb3IgdGhpcy5cbiAgICAgIElTX0ZJUkVGT1ggJiYgKF9kb21Ob2RlJHRleHRDb250ZW50MiA9IGRvbU5vZGUudGV4dENvbnRlbnQpICE9PSBudWxsICYmIF9kb21Ob2RlJHRleHRDb250ZW50MiAhPT0gdm9pZCAwICYmIF9kb21Ob2RlJHRleHRDb250ZW50Mi5lbmRzV2l0aCgnXFxuXFxuJykpKSB7XG4gICAgICAgIG9mZnNldC0tO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoSVNfQU5EUk9JRCAmJiAhdGV4dE5vZGUgJiYgIWV4YWN0TWF0Y2gpIHtcbiAgICAgIHZhciBub2RlID0gcGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtbm9kZScpID8gcGFyZW50Tm9kZSA6IHBhcmVudE5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbm9kZV0nKTtcbiAgICAgIGlmIChub2RlICYmIERPTUVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgbm9kZSwge1xuICAgICAgICBlZGl0YWJsZTogdHJ1ZVxuICAgICAgfSkpIHtcbiAgICAgICAgdmFyIF9zbGF0ZU5vZGUgPSBET01FZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCBub2RlKTtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IF9vZmZzZXRcbiAgICAgICAgfSA9IEVkaXRvci5zdGFydChlZGl0b3IsIERPTUVkaXRvci5maW5kUGF0aChlZGl0b3IsIF9zbGF0ZU5vZGUpKTtcbiAgICAgICAgaWYgKCFub2RlLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXNsYXRlLWxlYWZdJykpIHtcbiAgICAgICAgICBfb2Zmc2V0ID0gbmVhcmVzdE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgIG9mZnNldDogX29mZnNldFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRleHROb2RlKSB7XG4gICAgICBpZiAoc3VwcHJlc3NUaHJvdykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgU2xhdGUgcG9pbnQgZnJvbSBET00gcG9pbnQ6IFwiLmNvbmNhdChkb21Qb2ludCkpO1xuICAgIH1cbiAgICAvLyBDT01QQVQ6IElmIHNvbWVvbmUgaXMgY2xpY2tpbmcgZnJvbSBvbmUgU2xhdGUgZWRpdG9yIGludG8gYW5vdGhlcixcbiAgICAvLyB0aGUgc2VsZWN0IGV2ZW50IGZpcmVzIHR3aWNlLCBvbmNlIGZvciB0aGUgb2xkIGVkaXRvcidzIGBlbGVtZW50YFxuICAgIC8vIGZpcnN0LCBhbmQgdGhlbiBhZnRlcndhcmRzIGZvciB0aGUgY29ycmVjdCBgZWxlbWVudGAuICgyMDE3LzAzLzAzKVxuICAgIHZhciBzbGF0ZU5vZGUgPSBET01FZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCB0ZXh0Tm9kZSk7XG4gICAgdmFyIHBhdGggPSBET01FZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBzbGF0ZU5vZGUpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgb2Zmc2V0XG4gICAgfTtcbiAgfSxcbiAgdG9TbGF0ZVJhbmdlOiAoZWRpdG9yLCBkb21SYW5nZSwgb3B0aW9ucykgPT4ge1xuICAgIHZhciBfZm9jdXNOb2RlJHRleHRDb250ZW47XG4gICAgdmFyIHtcbiAgICAgIGV4YWN0TWF0Y2gsXG4gICAgICBzdXBwcmVzc1Rocm93XG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIGVsID0gaXNET01TZWxlY3Rpb24oZG9tUmFuZ2UpID8gZG9tUmFuZ2UuYW5jaG9yTm9kZSA6IGRvbVJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgIHZhciBhbmNob3JOb2RlO1xuICAgIHZhciBhbmNob3JPZmZzZXQ7XG4gICAgdmFyIGZvY3VzTm9kZTtcbiAgICB2YXIgZm9jdXNPZmZzZXQ7XG4gICAgdmFyIGlzQ29sbGFwc2VkO1xuICAgIGlmIChlbCkge1xuICAgICAgaWYgKGlzRE9NU2VsZWN0aW9uKGRvbVJhbmdlKSkge1xuICAgICAgICAvLyBDT01QQVQ6IEluIGZpcmVmb3ggdGhlIG5vcm1hbCBzZWxldGlvbiB3YXkgZG9lcyBub3Qgd29ya1xuICAgICAgICAvLyAoaHR0cHM6Ly9naXRodWIuY29tL2lhbnN0b3JtdGF5bG9yL3NsYXRlL3B1bGwvNTQ4NiNpc3N1ZS0xODIwNzIwMjIzKVxuICAgICAgICBpZiAoSVNfRklSRUZPWCAmJiBkb21SYW5nZS5yYW5nZUNvdW50ID4gMSkge1xuICAgICAgICAgIGZvY3VzTm9kZSA9IGRvbVJhbmdlLmZvY3VzTm9kZTsgLy8gRm9jdXMgbm9kZSB3b3JrcyBmaW5lXG4gICAgICAgICAgdmFyIGZpcnN0UmFuZ2UgPSBkb21SYW5nZS5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgIHZhciBsYXN0UmFuZ2UgPSBkb21SYW5nZS5nZXRSYW5nZUF0KGRvbVJhbmdlLnJhbmdlQ291bnQgLSAxKTtcbiAgICAgICAgICAvLyBIZXJlIHdlIGFyZSBpbiB0aGUgY29udGVudGVkaXRhYmxlIG1vZGUgb2YgYSB0YWJsZSBpbiBmaXJlZm94XG4gICAgICAgICAgaWYgKGZvY3VzTm9kZSBpbnN0YW5jZW9mIEhUTUxUYWJsZVJvd0VsZW1lbnQgJiYgZmlyc3RSYW5nZS5zdGFydENvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxUYWJsZVJvd0VsZW1lbnQgJiYgbGFzdFJhbmdlLnN0YXJ0Q29udGFpbmVyIGluc3RhbmNlb2YgSFRNTFRhYmxlUm93RWxlbWVudCkge1xuICAgICAgICAgICAgLy8gSFRNTEVsZW1lbnQsIGJlY291c2UgRWxlbWVudCBpcyBhIHNsYXRlIGVsZW1lbnRcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldExhc3RDaGlsZHJlbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50LmNoaWxkRWxlbWVudENvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRMYXN0Q2hpbGRyZW4oZWxlbWVudC5jaGlsZHJlblswXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmaXJzdE5vZGVSb3cgPSBmaXJzdFJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICAgICAgdmFyIGxhc3ROb2RlUm93ID0gbGFzdFJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgZmFpbCBhcyBcIlRoZSBIVE1MRWxlbWVudCBpbnRlcmZhY2UgcmVwcmVzZW50cyBhbnkgSFRNTCBlbGVtZW50LlwiXG4gICAgICAgICAgICB2YXIgZmlyc3ROb2RlID0gZ2V0TGFzdENoaWxkcmVuKGZpcnN0Tm9kZVJvdy5jaGlsZHJlbltmaXJzdFJhbmdlLnN0YXJ0T2Zmc2V0XSk7XG4gICAgICAgICAgICB2YXIgbGFzdE5vZGUgPSBnZXRMYXN0Q2hpbGRyZW4obGFzdE5vZGVSb3cuY2hpbGRyZW5bbGFzdFJhbmdlLnN0YXJ0T2Zmc2V0XSk7XG4gICAgICAgICAgICAvLyBaZXJvLCBhcyB3ZSBhbGx3YXlzIHRha2UgdGhlIHJpZ2h0IG9uZSBhcyB0aGUgYW5jaG9yIHBvaW50XG4gICAgICAgICAgICBmb2N1c09mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAobGFzdE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGFuY2hvck5vZGUgPSBsYXN0Tm9kZS5jaGlsZE5vZGVzWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYW5jaG9yTm9kZSA9IGxhc3ROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZm9jdXNOb2RlID0gZmlyc3ROb2RlLmNoaWxkTm9kZXNbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb2N1c05vZGUgPSBmaXJzdE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdE5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICBhbmNob3JPZmZzZXQgPSBsYXN0Tm9kZS5pbm5lckhUTUwubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgb3B0aW9uXG4gICAgICAgICAgICAgIGFuY2hvck9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHJlYWQgb25seSBtb2RlIG9mIGEgZmlyZWZveCB0YWJsZVxuICAgICAgICAgICAgLy8gUmlnaHQgdG8gbGVmdFxuICAgICAgICAgICAgaWYgKGZpcnN0UmFuZ2Uuc3RhcnRDb250YWluZXIgPT09IGZvY3VzTm9kZSkge1xuICAgICAgICAgICAgICBhbmNob3JOb2RlID0gbGFzdFJhbmdlLmVuZENvbnRhaW5lcjtcbiAgICAgICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gbGFzdFJhbmdlLmVuZE9mZnNldDtcbiAgICAgICAgICAgICAgZm9jdXNPZmZzZXQgPSBmaXJzdFJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTGVmdCB0byByaWdodFxuICAgICAgICAgICAgICBhbmNob3JOb2RlID0gZmlyc3RSYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gZmlyc3RSYW5nZS5lbmRPZmZzZXQ7XG4gICAgICAgICAgICAgIGZvY3VzT2Zmc2V0ID0gbGFzdFJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbmNob3JOb2RlID0gZG9tUmFuZ2UuYW5jaG9yTm9kZTtcbiAgICAgICAgICBhbmNob3JPZmZzZXQgPSBkb21SYW5nZS5hbmNob3JPZmZzZXQ7XG4gICAgICAgICAgZm9jdXNOb2RlID0gZG9tUmFuZ2UuZm9jdXNOb2RlO1xuICAgICAgICAgIGZvY3VzT2Zmc2V0ID0gZG9tUmFuZ2UuZm9jdXNPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ09NUEFUOiBUaGVyZSdzIGEgYnVnIGluIGNocm9tZSB0aGF0IGFsd2F5cyByZXR1cm5zIGB0cnVlYCBmb3JcbiAgICAgICAgLy8gYGlzQ29sbGFwc2VkYCBmb3IgYSBTZWxlY3Rpb24gdGhhdCBjb21lcyBmcm9tIGEgU2hhZG93Um9vdC5cbiAgICAgICAgLy8gKDIwMjAvMDgvMDgpXG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0NzUyM1xuICAgICAgICAvLyBJc0NvbGxhcHNlZCBtaWdodCBub3Qgd29yayBpbiBmaXJlZm94LCBidXQgdGhpcyB3aWxsXG4gICAgICAgIGlmIChJU19DSFJPTUUgJiYgaGFzU2hhZG93Um9vdChhbmNob3JOb2RlKSB8fCBJU19GSVJFRk9YKSB7XG4gICAgICAgICAgaXNDb2xsYXBzZWQgPSBkb21SYW5nZS5hbmNob3JOb2RlID09PSBkb21SYW5nZS5mb2N1c05vZGUgJiYgZG9tUmFuZ2UuYW5jaG9yT2Zmc2V0ID09PSBkb21SYW5nZS5mb2N1c09mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc0NvbGxhcHNlZCA9IGRvbVJhbmdlLmlzQ29sbGFwc2VkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmNob3JOb2RlID0gZG9tUmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgIGFuY2hvck9mZnNldCA9IGRvbVJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgICBmb2N1c05vZGUgPSBkb21SYW5nZS5lbmRDb250YWluZXI7XG4gICAgICAgIGZvY3VzT2Zmc2V0ID0gZG9tUmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgICBpc0NvbGxhcHNlZCA9IGRvbVJhbmdlLmNvbGxhcHNlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFuY2hvck5vZGUgPT0gbnVsbCB8fCBmb2N1c05vZGUgPT0gbnVsbCB8fCBhbmNob3JPZmZzZXQgPT0gbnVsbCB8fCBmb2N1c09mZnNldCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIHJhbmdlIGZyb20gRE9NIHJhbmdlOiBcIi5jb25jYXQoZG9tUmFuZ2UpKTtcbiAgICB9XG4gICAgLy8gQ09NUEFUOiBGaXJlZm94IHNvbWV0aW1lcyBpbmNsdWRlcyBhbiBleHRyYSBcXG4gKHJlbmRlcmVkIGJ5IFRleHRTdHJpbmdcbiAgICAvLyB3aGVuIGlzVHJhaWxpbmcgaXMgdHJ1ZSkgaW4gdGhlIGZvY3VzT2Zmc2V0LCByZXN1bHRpbmcgaW4gYW4gaW52YWxpZFxuICAgIC8vIFNsYXRlIHBvaW50LiAoMjAyMy8xMS8wMSlcbiAgICBpZiAoSVNfRklSRUZPWCAmJiAoX2ZvY3VzTm9kZSR0ZXh0Q29udGVuID0gZm9jdXNOb2RlLnRleHRDb250ZW50KSAhPT0gbnVsbCAmJiBfZm9jdXNOb2RlJHRleHRDb250ZW4gIT09IHZvaWQgMCAmJiBfZm9jdXNOb2RlJHRleHRDb250ZW4uZW5kc1dpdGgoJ1xcblxcbicpICYmIGZvY3VzT2Zmc2V0ID09PSBmb2N1c05vZGUudGV4dENvbnRlbnQubGVuZ3RoKSB7XG4gICAgICBmb2N1c09mZnNldC0tO1xuICAgIH1cbiAgICB2YXIgYW5jaG9yID0gRE9NRWRpdG9yLnRvU2xhdGVQb2ludChlZGl0b3IsIFthbmNob3JOb2RlLCBhbmNob3JPZmZzZXRdLCB7XG4gICAgICBleGFjdE1hdGNoLFxuICAgICAgc3VwcHJlc3NUaHJvd1xuICAgIH0pO1xuICAgIGlmICghYW5jaG9yKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGZvY3VzQmVmb3JlQW5jaG9yID0gaXNCZWZvcmUoYW5jaG9yTm9kZSwgZm9jdXNOb2RlKSB8fCBhbmNob3JOb2RlID09PSBmb2N1c05vZGUgJiYgZm9jdXNPZmZzZXQgPCBhbmNob3JPZmZzZXQ7XG4gICAgdmFyIGZvY3VzID0gaXNDb2xsYXBzZWQgPyBhbmNob3IgOiBET01FZGl0b3IudG9TbGF0ZVBvaW50KGVkaXRvciwgW2ZvY3VzTm9kZSwgZm9jdXNPZmZzZXRdLCB7XG4gICAgICBleGFjdE1hdGNoLFxuICAgICAgc3VwcHJlc3NUaHJvdyxcbiAgICAgIHNlYXJjaERpcmVjdGlvbjogZm9jdXNCZWZvcmVBbmNob3IgPyAnZm9yd2FyZCcgOiAnYmFja3dhcmQnXG4gICAgfSk7XG4gICAgaWYgKCFmb2N1cykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciByYW5nZSA9IHtcbiAgICAgIGFuY2hvcjogYW5jaG9yLFxuICAgICAgZm9jdXM6IGZvY3VzXG4gICAgfTtcbiAgICAvLyBpZiB0aGUgc2VsZWN0aW9uIGlzIGEgaGFuZ2luZyByYW5nZSB0aGF0IGVuZHMgaW4gYSB2b2lkXG4gICAgLy8gYW5kIHRoZSBET00gZm9jdXMgaXMgYW4gRWxlbWVudFxuICAgIC8vIChtZWFuaW5nIHRoYXQgdGhlIHNlbGVjdGlvbiBlbmRzIGJlZm9yZSB0aGUgZWxlbWVudClcbiAgICAvLyB1bmhhbmcgdGhlIHJhbmdlIHRvIGF2b2lkIG1pc3Rha2VubHkgaW5jbHVkaW5nIHRoZSB2b2lkXG4gICAgaWYgKFJhbmdlLmlzRXhwYW5kZWQocmFuZ2UpICYmIFJhbmdlLmlzRm9yd2FyZChyYW5nZSkgJiYgaXNET01FbGVtZW50KGZvY3VzTm9kZSkgJiYgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICBhdDogcmFuZ2UuZm9jdXMsXG4gICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICB9KSkge1xuICAgICAgcmFuZ2UgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCByYW5nZSwge1xuICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgdGV4dCBkaWZmIHdhcyBhcHBsaWVkIGluIGEgd2F5IHdlIGNhbiBwZXJmb3JtIHRoZSBwZW5kaW5nIGFjdGlvbiBvbiAvXG4gKiByZWNvdmVyIHRoZSBwZW5kaW5nIHNlbGVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ5RGlmZlN0YXRlKGVkaXRvciwgdGV4dERpZmYpIHtcbiAgdmFyIHtcbiAgICBwYXRoLFxuICAgIGRpZmZcbiAgfSA9IHRleHREaWZmO1xuICBpZiAoIUVkaXRvci5oYXNQYXRoKGVkaXRvciwgcGF0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIG5vZGUgPSBOb2RlLmdldChlZGl0b3IsIHBhdGgpO1xuICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChkaWZmLnN0YXJ0ICE9PSBub2RlLnRleHQubGVuZ3RoIHx8IGRpZmYudGV4dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbm9kZS50ZXh0LnNsaWNlKGRpZmYuc3RhcnQsIGRpZmYuc3RhcnQgKyBkaWZmLnRleHQubGVuZ3RoKSA9PT0gZGlmZi50ZXh0O1xuICB9XG4gIHZhciBuZXh0UGF0aCA9IFBhdGgubmV4dChwYXRoKTtcbiAgaWYgKCFFZGl0b3IuaGFzUGF0aChlZGl0b3IsIG5leHRQYXRoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbmV4dE5vZGUgPSBOb2RlLmdldChlZGl0b3IsIG5leHRQYXRoKTtcbiAgcmV0dXJuIFRleHQuaXNUZXh0KG5leHROb2RlKSAmJiBuZXh0Tm9kZS50ZXh0LnN0YXJ0c1dpdGgoZGlmZi50ZXh0KTtcbn1cbmZ1bmN0aW9uIGFwcGx5U3RyaW5nRGlmZih0ZXh0KSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBkaWZmcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZGlmZnNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHJldHVybiBkaWZmcy5yZWR1Y2UoKHRleHQsIGRpZmYpID0+IHRleHQuc2xpY2UoMCwgZGlmZi5zdGFydCkgKyBkaWZmLnRleHQgKyB0ZXh0LnNsaWNlKGRpZmYuZW5kKSwgdGV4dCk7XG59XG5mdW5jdGlvbiBsb25nZXN0Q29tbW9uUHJlZml4TGVuZ3RoKHN0ciwgYW5vdGhlcikge1xuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgYW5vdGhlci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0ci5jaGFyQXQoaSkgIT09IGFub3RoZXIuY2hhckF0KGkpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn1cbmZ1bmN0aW9uIGxvbmdlc3RDb21tb25TdWZmaXhMZW5ndGgoc3RyLCBhbm90aGVyLCBtYXgpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGFub3RoZXIubGVuZ3RoLCBtYXgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIGkgLSAxKSAhPT0gYW5vdGhlci5jaGFyQXQoYW5vdGhlci5sZW5ndGggLSBpIC0gMSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGVuZ3RoO1xufVxuLyoqXG4gKiBSZW1vdmUgcmVkdW5kYW50IGNoYW5nZXMgZnJvbSB0aGUgZGlmZiBzbyB0aGF0IGl0IHNwYW5zIHRoZSBtaW5pbWFsIHBvc3NpYmxlIHJhbmdlXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ0RpZmYodGFyZ2V0VGV4dCwgZGlmZikge1xuICB2YXIge1xuICAgIHN0YXJ0LFxuICAgIGVuZCxcbiAgICB0ZXh0XG4gIH0gPSBkaWZmO1xuICB2YXIgcmVtb3ZlZFRleHQgPSB0YXJnZXRUZXh0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuICB2YXIgcHJlZml4TGVuZ3RoID0gbG9uZ2VzdENvbW1vblByZWZpeExlbmd0aChyZW1vdmVkVGV4dCwgdGV4dCk7XG4gIHZhciBtYXggPSBNYXRoLm1pbihyZW1vdmVkVGV4dC5sZW5ndGggLSBwcmVmaXhMZW5ndGgsIHRleHQubGVuZ3RoIC0gcHJlZml4TGVuZ3RoKTtcbiAgdmFyIHN1ZmZpeExlbmd0aCA9IGxvbmdlc3RDb21tb25TdWZmaXhMZW5ndGgocmVtb3ZlZFRleHQsIHRleHQsIG1heCk7XG4gIHZhciBub3JtYWxpemVkID0ge1xuICAgIHN0YXJ0OiBzdGFydCArIHByZWZpeExlbmd0aCxcbiAgICBlbmQ6IGVuZCAtIHN1ZmZpeExlbmd0aCxcbiAgICB0ZXh0OiB0ZXh0LnNsaWNlKHByZWZpeExlbmd0aCwgdGV4dC5sZW5ndGggLSBzdWZmaXhMZW5ndGgpXG4gIH07XG4gIGlmIChub3JtYWxpemVkLnN0YXJ0ID09PSBub3JtYWxpemVkLmVuZCAmJiBub3JtYWxpemVkLnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG4vKipcbiAqIFJldHVybiBhIHN0cmluZyBkaWZmIHRoYXQgaXMgZXF1aXZhbGVudCB0byBhcHBseWluZyBiIGFmdGVyIGEgc3Bhbm5pbmcgdGhlIHJhbmdlIG9mXG4gKiBib3RoIGNoYW5nZXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2VTdHJpbmdEaWZmcyh0YXJnZXRUZXh0LCBhLCBiKSB7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKGEuc3RhcnQsIGIuc3RhcnQpO1xuICB2YXIgb3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGEuc3RhcnQgKyBhLnRleHQubGVuZ3RoLCBiLmVuZCkgLSBiLnN0YXJ0KTtcbiAgdmFyIGFwcGxpZWQgPSBhcHBseVN0cmluZ0RpZmYodGFyZ2V0VGV4dCwgYSwgYik7XG4gIHZhciBzbGljZUVuZCA9IE1hdGgubWF4KGIuc3RhcnQgKyBiLnRleHQubGVuZ3RoLCBhLnN0YXJ0ICsgYS50ZXh0Lmxlbmd0aCArIChhLnN0YXJ0ICsgYS50ZXh0Lmxlbmd0aCA+IGIuc3RhcnQgPyBiLnRleHQubGVuZ3RoIDogMCkgLSBvdmVybGFwKTtcbiAgdmFyIHRleHQgPSBhcHBsaWVkLnNsaWNlKHN0YXJ0LCBzbGljZUVuZCk7XG4gIHZhciBlbmQgPSBNYXRoLm1heChhLmVuZCwgYi5lbmQgLSBhLnRleHQubGVuZ3RoICsgKGEuZW5kIC0gYS5zdGFydCkpO1xuICByZXR1cm4gbm9ybWFsaXplU3RyaW5nRGlmZih0YXJnZXRUZXh0LCB7XG4gICAgc3RhcnQsXG4gICAgZW5kLFxuICAgIHRleHRcbiAgfSk7XG59XG4vKipcbiAqIEdldCB0aGUgc2xhdGUgcmFuZ2UgdGhlIHRleHQgZGlmZiBzcGFucy5cbiAqL1xuZnVuY3Rpb24gdGFyZ2V0UmFuZ2UodGV4dERpZmYpIHtcbiAgdmFyIHtcbiAgICBwYXRoLFxuICAgIGRpZmZcbiAgfSA9IHRleHREaWZmO1xuICByZXR1cm4ge1xuICAgIGFuY2hvcjoge1xuICAgICAgcGF0aCxcbiAgICAgIG9mZnNldDogZGlmZi5zdGFydFxuICAgIH0sXG4gICAgZm9jdXM6IHtcbiAgICAgIHBhdGgsXG4gICAgICBvZmZzZXQ6IGRpZmYuZW5kXG4gICAgfVxuICB9O1xufVxuLyoqXG4gKiBOb3JtYWxpemUgYSAncGVuZGluZyBwb2ludCcgYS5rLmEgYSBwb2ludCBiYXNlZCBvbiB0aGUgZG9tIHN0YXRlIGJlZm9yZSBhcHBseWluZ1xuICogdGhlIHBlbmRpbmcgZGlmZnMuIFNpbmNlIHRoZSBwZW5kaW5nIGRpZmZzIG1pZ2h0IGhhdmUgYmVlbiBpbnNlcnRlZCB3aXRoIGRpZmZlcmVudFxuICogbWFya3Mgd2UgaGF2ZSB0byAnd2FsaycgdGhlIG9mZnNldCBmcm9tIHRoZSBzdGFydGluZyBwb3NpdGlvbiB0byBlbnN1cmUgd2Ugc3RpbGxcbiAqIGhhdmUgYSB2YWxpZCBwb2ludCBpbnNpZGUgdGhlIGRvY3VtZW50XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBvaW50KGVkaXRvciwgcG9pbnQpIHtcbiAgdmFyIHtcbiAgICBwYXRoLFxuICAgIG9mZnNldFxuICB9ID0gcG9pbnQ7XG4gIGlmICghRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBwYXRoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBsZWFmID0gTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcbiAgaWYgKCFUZXh0LmlzVGV4dChsZWFmKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBwYXJlbnRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgIGF0OiBwYXRoXG4gIH0pO1xuICBpZiAoIXBhcmVudEJsb2NrKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgd2hpbGUgKG9mZnNldCA+IGxlYWYudGV4dC5sZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBFZGl0b3IubmV4dChlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXRoLFxuICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0XG4gICAgfSk7XG4gICAgaWYgKCFlbnRyeSB8fCAhUGF0aC5pc0Rlc2NlbmRhbnQoZW50cnlbMV0sIHBhcmVudEJsb2NrWzFdKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG9mZnNldCAtPSBsZWFmLnRleHQubGVuZ3RoO1xuICAgIGxlYWYgPSBlbnRyeVswXTtcbiAgICBwYXRoID0gZW50cnlbMV07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwYXRoLFxuICAgIG9mZnNldFxuICB9O1xufVxuLyoqXG4gKiBOb3JtYWxpemUgYSAncGVuZGluZyBzZWxlY3Rpb24nIHRvIGVuc3VyZSBpdCdzIHZhbGlkIGluIHRoZSBjdXJyZW50IGRvY3VtZW50IHN0YXRlLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVSYW5nZShlZGl0b3IsIHJhbmdlKSB7XG4gIHZhciBhbmNob3IgPSBub3JtYWxpemVQb2ludChlZGl0b3IsIHJhbmdlLmFuY2hvcik7XG4gIGlmICghYW5jaG9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1czogYW5jaG9yXG4gICAgfTtcbiAgfVxuICB2YXIgZm9jdXMgPSBub3JtYWxpemVQb2ludChlZGl0b3IsIHJhbmdlLmZvY3VzKTtcbiAgaWYgKCFmb2N1cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzXG4gIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1QZW5kaW5nUG9pbnQoZWRpdG9yLCBwb2ludCwgb3ApIHtcbiAgdmFyIHBlbmRpbmdEaWZmcyA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpO1xuICB2YXIgdGV4dERpZmYgPSBwZW5kaW5nRGlmZnMgPT09IG51bGwgfHwgcGVuZGluZ0RpZmZzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZW5kaW5nRGlmZnMuZmluZChfcmVmID0+IHtcbiAgICB2YXIge1xuICAgICAgcGF0aFxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiBQYXRoLmVxdWFscyhwYXRoLCBwb2ludC5wYXRoKTtcbiAgfSk7XG4gIGlmICghdGV4dERpZmYgfHwgcG9pbnQub2Zmc2V0IDw9IHRleHREaWZmLmRpZmYuc3RhcnQpIHtcbiAgICByZXR1cm4gUG9pbnQudHJhbnNmb3JtKHBvaW50LCBvcCwge1xuICAgICAgYWZmaW5pdHk6ICdiYWNrd2FyZCdcbiAgICB9KTtcbiAgfVxuICB2YXIge1xuICAgIGRpZmZcbiAgfSA9IHRleHREaWZmO1xuICAvLyBQb2ludCByZWZlcmVuY2VzIGxvY2F0aW9uIGluc2lkZSB0aGUgZGlmZiA9PiB0cmFuc2Zvcm0gdGhlIHBvaW50IGJhc2VkIG9uIHRoZSBsb2NhdGlvblxuICAvLyB0aGUgZGlmZiB3aWxsIGJlIGFwcGxpZWQgdG8gYW5kIGFkZCB0aGUgb2Zmc2V0IGluc2lkZSB0aGUgZGlmZi5cbiAgaWYgKHBvaW50Lm9mZnNldCA8PSBkaWZmLnN0YXJ0ICsgZGlmZi50ZXh0Lmxlbmd0aCkge1xuICAgIHZhciBfYW5jaG9yID0ge1xuICAgICAgcGF0aDogcG9pbnQucGF0aCxcbiAgICAgIG9mZnNldDogZGlmZi5zdGFydFxuICAgIH07XG4gICAgdmFyIF90cmFuc2Zvcm1lZCA9IFBvaW50LnRyYW5zZm9ybShfYW5jaG9yLCBvcCwge1xuICAgICAgYWZmaW5pdHk6ICdiYWNrd2FyZCdcbiAgICB9KTtcbiAgICBpZiAoIV90cmFuc2Zvcm1lZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBfdHJhbnNmb3JtZWQucGF0aCxcbiAgICAgIG9mZnNldDogX3RyYW5zZm9ybWVkLm9mZnNldCArIHBvaW50Lm9mZnNldCAtIGRpZmYuc3RhcnRcbiAgICB9O1xuICB9XG4gIC8vIFBvaW50IHJlZmVyZW5jZXMgbG9jYXRpb24gYWZ0ZXIgdGhlIGRpZmZcbiAgdmFyIGFuY2hvciA9IHtcbiAgICBwYXRoOiBwb2ludC5wYXRoLFxuICAgIG9mZnNldDogcG9pbnQub2Zmc2V0IC0gZGlmZi50ZXh0Lmxlbmd0aCArIGRpZmYuZW5kIC0gZGlmZi5zdGFydFxuICB9O1xuICB2YXIgdHJhbnNmb3JtZWQgPSBQb2ludC50cmFuc2Zvcm0oYW5jaG9yLCBvcCwge1xuICAgIGFmZmluaXR5OiAnYmFja3dhcmQnXG4gIH0pO1xuICBpZiAoIXRyYW5zZm9ybWVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG9wLnR5cGUgPT09ICdzcGxpdF9ub2RlJyAmJiBQYXRoLmVxdWFscyhvcC5wYXRoLCBwb2ludC5wYXRoKSAmJiBhbmNob3Iub2Zmc2V0IDwgb3AucG9zaXRpb24gJiYgZGlmZi5zdGFydCA8IG9wLnBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xuICB9XG4gIHJldHVybiB7XG4gICAgcGF0aDogdHJhbnNmb3JtZWQucGF0aCxcbiAgICBvZmZzZXQ6IHRyYW5zZm9ybWVkLm9mZnNldCArIGRpZmYudGV4dC5sZW5ndGggLSBkaWZmLmVuZCArIGRpZmYuc3RhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybVBlbmRpbmdSYW5nZShlZGl0b3IsIHJhbmdlLCBvcCkge1xuICB2YXIgYW5jaG9yID0gdHJhbnNmb3JtUGVuZGluZ1BvaW50KGVkaXRvciwgcmFuZ2UuYW5jaG9yLCBvcCk7XG4gIGlmICghYW5jaG9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1czogYW5jaG9yXG4gICAgfTtcbiAgfVxuICB2YXIgZm9jdXMgPSB0cmFuc2Zvcm1QZW5kaW5nUG9pbnQoZWRpdG9yLCByYW5nZS5mb2N1cywgb3ApO1xuICBpZiAoIWZvY3VzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybVRleHREaWZmKHRleHREaWZmLCBvcCkge1xuICB2YXIge1xuICAgIHBhdGgsXG4gICAgZGlmZixcbiAgICBpZFxuICB9ID0gdGV4dERpZmY7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSB8fCBvcC5vZmZzZXQgPj0gZGlmZi5lbmQpIHtcbiAgICAgICAgICByZXR1cm4gdGV4dERpZmY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wLm9mZnNldCA8PSBkaWZmLnN0YXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IG9wLnRleHQubGVuZ3RoICsgZGlmZi5zdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBvcC50ZXh0Lmxlbmd0aCArIGRpZmYuZW5kLFxuICAgICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhdGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgc3RhcnQ6IGRpZmYuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGRpZmYuZW5kICsgb3AudGV4dC5sZW5ndGgsXG4gICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHBhdGhcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICB7XG4gICAgICAgIGlmICghUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgfHwgb3Aub2Zmc2V0ID49IGRpZmYuZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHRleHREaWZmO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcC5vZmZzZXQgKyBvcC50ZXh0Lmxlbmd0aCA8PSBkaWZmLnN0YXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGRpZmYuc3RhcnQgLSBvcC50ZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCAtIG9wLnRleHQubGVuZ3RoLFxuICAgICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhdGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgc3RhcnQ6IGRpZmYuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGRpZmYuZW5kIC0gb3AudGV4dC5sZW5ndGgsXG4gICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHBhdGhcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSB8fCBvcC5wb3NpdGlvbiA+PSBkaWZmLmVuZCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWZmLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXRoOiBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwge1xuICAgICAgICAgICAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcC5wb3NpdGlvbiA+IGRpZmYuc3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBNYXRoLm1pbihvcC5wb3NpdGlvbiwgZGlmZi5lbmQpLFxuICAgICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhdGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgc3RhcnQ6IGRpZmYuc3RhcnQgLSBvcC5wb3NpdGlvbixcbiAgICAgICAgICAgIGVuZDogZGlmZi5lbmQgLSBvcC5wb3NpdGlvbixcbiAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGF0aDogUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIHtcbiAgICAgICAgICAgIGFmZmluaXR5OiAnZm9yd2FyZCdcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAge1xuICAgICAgICBpZiAoIVBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZmYsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhdGg6IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCArIG9wLnBvc2l0aW9uLFxuICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCArIG9wLnBvc2l0aW9uLFxuICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwYXRoOiBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgfVxuICB2YXIgbmV3UGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wKTtcbiAgaWYgKCFuZXdQYXRoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkaWZmLFxuICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgaWRcbiAgfTtcbn1cblxuLyoqXG4gKiBVdGlsaXRpZXMgZm9yIHNpbmdsZS1saW5lIGRlbGV0aW9uXG4gKi9cbnZhciBkb1JlY3RzSW50ZXJzZWN0ID0gKHJlY3QsIGNvbXBhcmVSZWN0KSA9PiB7XG4gIHZhciBtaWRkbGUgPSAoY29tcGFyZVJlY3QudG9wICsgY29tcGFyZVJlY3QuYm90dG9tKSAvIDI7XG4gIHJldHVybiByZWN0LnRvcCA8PSBtaWRkbGUgJiYgcmVjdC5ib3R0b20gPj0gbWlkZGxlO1xufTtcbnZhciBhcmVSYW5nZXNTYW1lTGluZSA9IChlZGl0b3IsIHJhbmdlMSwgcmFuZ2UyKSA9PiB7XG4gIHZhciByZWN0MSA9IERPTUVkaXRvci50b0RPTVJhbmdlKGVkaXRvciwgcmFuZ2UxKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHJlY3QyID0gRE9NRWRpdG9yLnRvRE9NUmFuZ2UoZWRpdG9yLCByYW5nZTIpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4gZG9SZWN0c0ludGVyc2VjdChyZWN0MSwgcmVjdDIpICYmIGRvUmVjdHNJbnRlcnNlY3QocmVjdDIsIHJlY3QxKTtcbn07XG4vKipcbiAqIEEgaGVscGVyIHV0aWxpdHkgdGhhdCByZXR1cm5zIHRoZSBlbmQgcG9ydGlvbiBvZiBhIGBSYW5nZWBcbiAqIHdoaWNoIGlzIGxvY2F0ZWQgb24gYSBzaW5nbGUgbGluZS5cbiAqXG4gKiBAcGFyYW0ge0VkaXRvcn0gZWRpdG9yIFRoZSBlZGl0b3Igb2JqZWN0IHRvIGNvbXBhcmUgYWdhaW5zdFxuICogQHBhcmFtIHtSYW5nZX0gcGFyZW50UmFuZ2UgVGhlIHBhcmVudCByYW5nZSB0byBjb21wYXJlIGFnYWluc3RcbiAqIEByZXR1cm5zIHtSYW5nZX0gQSB2YWxpZCBwb3J0aW9uIG9mIHRoZSBwYXJlbnRSYW5nZSB3aGljaCBpcyBvbmUgYSBzaW5nbGUgbGluZVxuICovXG52YXIgZmluZEN1cnJlbnRMaW5lUmFuZ2UgPSAoZWRpdG9yLCBwYXJlbnRSYW5nZSkgPT4ge1xuICB2YXIgcGFyZW50UmFuZ2VCb3VuZGFyeSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIFJhbmdlLmVuZChwYXJlbnRSYW5nZSkpO1xuICB2YXIgcG9zaXRpb25zID0gQXJyYXkuZnJvbShFZGl0b3IucG9zaXRpb25zKGVkaXRvciwge1xuICAgIGF0OiBwYXJlbnRSYW5nZVxuICB9KSk7XG4gIHZhciBsZWZ0ID0gMDtcbiAgdmFyIHJpZ2h0ID0gcG9zaXRpb25zLmxlbmd0aDtcbiAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IocmlnaHQgLyAyKTtcbiAgaWYgKGFyZVJhbmdlc1NhbWVMaW5lKGVkaXRvciwgRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW2xlZnRdKSwgcGFyZW50UmFuZ2VCb3VuZGFyeSkpIHtcbiAgICByZXR1cm4gRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW2xlZnRdLCBwYXJlbnRSYW5nZUJvdW5kYXJ5KTtcbiAgfVxuICBpZiAocG9zaXRpb25zLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW3Bvc2l0aW9ucy5sZW5ndGggLSAxXSwgcGFyZW50UmFuZ2VCb3VuZGFyeSk7XG4gIH1cbiAgd2hpbGUgKG1pZGRsZSAhPT0gcG9zaXRpb25zLmxlbmd0aCAmJiBtaWRkbGUgIT09IGxlZnQpIHtcbiAgICBpZiAoYXJlUmFuZ2VzU2FtZUxpbmUoZWRpdG9yLCBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwb3NpdGlvbnNbbWlkZGxlXSksIHBhcmVudFJhbmdlQm91bmRhcnkpKSB7XG4gICAgICByaWdodCA9IG1pZGRsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IG1pZGRsZTtcbiAgICB9XG4gICAgbWlkZGxlID0gTWF0aC5mbG9vcigobGVmdCArIHJpZ2h0KSAvIDIpO1xuICB9XG4gIHJldHVybiBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwb3NpdGlvbnNbcmlnaHRdLCBwYXJlbnRSYW5nZUJvdW5kYXJ5KTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuLyoqXG4gKiBgd2l0aERPTWAgYWRkcyBET00gc3BlY2lmaWMgYmVoYXZpb3JzIHRvIHRoZSBlZGl0b3IuXG4gKlxuICogSWYgeW91IGFyZSB1c2luZyBUeXBlU2NyaXB0LCB5b3UgbXVzdCBleHRlbmQgU2xhdGUncyBDdXN0b21UeXBlcyB0byB1c2VcbiAqIHRoaXMgcGx1Z2luLlxuICpcbiAqIFNlZSBodHRwczovL2RvY3Muc2xhdGVqcy5vcmcvY29uY2VwdHMvMTEtdHlwZXNjcmlwdCB0byBsZWFybiBob3cuXG4gKi9cbnZhciB3aXRoRE9NID0gZnVuY3Rpb24gd2l0aERPTShlZGl0b3IpIHtcbiAgdmFyIGNsaXBib2FyZEZvcm1hdEtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3gtc2xhdGUtZnJhZ21lbnQnO1xuICB2YXIgZSA9IGVkaXRvcjtcbiAgdmFyIHtcbiAgICBhcHBseSxcbiAgICBvbkNoYW5nZSxcbiAgICBkZWxldGVCYWNrd2FyZCxcbiAgICBhZGRNYXJrLFxuICAgIHJlbW92ZU1hcmtcbiAgfSA9IGU7XG4gIC8vIFRoZSBXZWFrTWFwIHdoaWNoIG1hcHMgYSBrZXkgdG8gYSBzcGVjaWZpYyBIVE1MRWxlbWVudCBtdXN0IGJlIHNjb3BlZCB0byB0aGUgZWRpdG9yIGluc3RhbmNlIHRvXG4gIC8vIGF2b2lkIGNvbGxpc2lvbnMgYmV0d2VlbiBlZGl0b3JzIGluIHRoZSBET00gdGhhdCBzaGFyZSB0aGUgc2FtZSB2YWx1ZS5cbiAgRURJVE9SX1RPX0tFWV9UT19FTEVNRU5ULnNldChlLCBuZXcgV2Vha01hcCgpKTtcbiAgZS5hZGRNYXJrID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICB2YXIgX0VESVRPUl9UT19TQ0hFRFVMRV9GLCBfRURJVE9SX1RPX1BFTkRJTkdfREk7XG4gICAgKF9FRElUT1JfVE9fU0NIRURVTEVfRiA9IEVESVRPUl9UT19TQ0hFRFVMRV9GTFVTSC5nZXQoZSkpID09PSBudWxsIHx8IF9FRElUT1JfVE9fU0NIRURVTEVfRiA9PT0gdm9pZCAwIHx8IF9FRElUT1JfVE9fU0NIRURVTEVfRigpO1xuICAgIGlmICghRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmdldChlKSAmJiAoX0VESVRPUl9UT19QRU5ESU5HX0RJID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGUpKSAhPT0gbnVsbCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREkgIT09IHZvaWQgMCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREkubGVuZ3RoKSB7XG4gICAgICAvLyBFbnN1cmUgdGhlIGN1cnJlbnQgcGVuZGluZyBkaWZmcyBvcmlnaW5hdGluZyBmcm9tIGNoYW5nZXMgYmVmb3JlIHRoZSBhZGRNYXJrXG4gICAgICAvLyBhcmUgYXBwbGllZCB3aXRoIHRoZSBjdXJyZW50IGZvcm1hdHRpbmdcbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5zZXQoZSwgbnVsbCk7XG4gICAgfVxuICAgIEVESVRPUl9UT19VU0VSX01BUktTLmRlbGV0ZShlKTtcbiAgICBhZGRNYXJrKGtleSwgdmFsdWUpO1xuICB9O1xuICBlLnJlbW92ZU1hcmsgPSBrZXkgPT4ge1xuICAgIHZhciBfRURJVE9SX1RPX1BFTkRJTkdfREkyO1xuICAgIGlmICghRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmdldChlKSAmJiAoX0VESVRPUl9UT19QRU5ESU5HX0RJMiA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlKSkgIT09IG51bGwgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJMiAhPT0gdm9pZCAwICYmIF9FRElUT1JfVE9fUEVORElOR19ESTIubGVuZ3RoKSB7XG4gICAgICAvLyBFbnN1cmUgdGhlIGN1cnJlbnQgcGVuZGluZyBkaWZmcyBvcmlnaW5hdGluZyBmcm9tIGNoYW5nZXMgYmVmb3JlIHRoZSBhZGRNYXJrXG4gICAgICAvLyBhcmUgYXBwbGllZCB3aXRoIHRoZSBjdXJyZW50IGZvcm1hdHRpbmdcbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5zZXQoZSwgbnVsbCk7XG4gICAgfVxuICAgIEVESVRPUl9UT19VU0VSX01BUktTLmRlbGV0ZShlKTtcbiAgICByZW1vdmVNYXJrKGtleSk7XG4gIH07XG4gIGUuZGVsZXRlQmFja3dhcmQgPSB1bml0ID0+IHtcbiAgICBpZiAodW5pdCAhPT0gJ2xpbmUnKSB7XG4gICAgICByZXR1cm4gZGVsZXRlQmFja3dhcmQodW5pdCk7XG4gICAgfVxuICAgIGlmIChlLnNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChlLnNlbGVjdGlvbikpIHtcbiAgICAgIHZhciBwYXJlbnRCbG9ja0VudHJ5ID0gRWRpdG9yLmFib3ZlKGUsIHtcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZSwgbiksXG4gICAgICAgIGF0OiBlLnNlbGVjdGlvblxuICAgICAgfSk7XG4gICAgICBpZiAocGFyZW50QmxvY2tFbnRyeSkge1xuICAgICAgICB2YXIgWywgcGFyZW50QmxvY2tQYXRoXSA9IHBhcmVudEJsb2NrRW50cnk7XG4gICAgICAgIHZhciBwYXJlbnRFbGVtZW50UmFuZ2UgPSBFZGl0b3IucmFuZ2UoZSwgcGFyZW50QmxvY2tQYXRoLCBlLnNlbGVjdGlvbi5hbmNob3IpO1xuICAgICAgICB2YXIgY3VycmVudExpbmVSYW5nZSA9IGZpbmRDdXJyZW50TGluZVJhbmdlKGUsIHBhcmVudEVsZW1lbnRSYW5nZSk7XG4gICAgICAgIGlmICghUmFuZ2UuaXNDb2xsYXBzZWQoY3VycmVudExpbmVSYW5nZSkpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlLCB7XG4gICAgICAgICAgICBhdDogY3VycmVudExpbmVSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBUaGlzIGF0dGVtcHRzIHRvIHJlc2V0IHRoZSBOT0RFX1RPX0tFWSBlbnRyeSB0byB0aGUgY29ycmVjdCB2YWx1ZVxuICAvLyBhcyBhcHBseSgpIGNoYW5nZXMgdGhlIG9iamVjdCByZWZlcmVuY2UgYW5kIGhlbmNlIGludmFsaWRhdGVzIHRoZSBOT0RFX1RPX0tFWSBlbnRyeVxuICBlLmFwcGx5ID0gb3AgPT4ge1xuICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgdmFyIHBhdGhSZWZNYXRjaGVzID0gW107XG4gICAgdmFyIHBlbmRpbmdEaWZmcyA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlKTtcbiAgICBpZiAocGVuZGluZ0RpZmZzICE9PSBudWxsICYmIHBlbmRpbmdEaWZmcyAhPT0gdm9pZCAwICYmIHBlbmRpbmdEaWZmcy5sZW5ndGgpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1lZCA9IHBlbmRpbmdEaWZmcy5tYXAodGV4dERpZmYgPT4gdHJhbnNmb3JtVGV4dERpZmYodGV4dERpZmYsIG9wKSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuc2V0KGUsIHRyYW5zZm9ybWVkKTtcbiAgICB9XG4gICAgdmFyIHBlbmRpbmdTZWxlY3Rpb24gPSBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04uZ2V0KGUpO1xuICAgIGlmIChwZW5kaW5nU2VsZWN0aW9uKSB7XG4gICAgICBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04uc2V0KGUsIHRyYW5zZm9ybVBlbmRpbmdSYW5nZShlLCBwZW5kaW5nU2VsZWN0aW9uLCBvcCkpO1xuICAgIH1cbiAgICB2YXIgcGVuZGluZ0FjdGlvbiA9IEVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5nZXQoZSk7XG4gICAgaWYgKHBlbmRpbmdBY3Rpb24gIT09IG51bGwgJiYgcGVuZGluZ0FjdGlvbiAhPT0gdm9pZCAwICYmIHBlbmRpbmdBY3Rpb24uYXQpIHtcbiAgICAgIHZhciBhdCA9IFBvaW50LmlzUG9pbnQocGVuZGluZ0FjdGlvbiA9PT0gbnVsbCB8fCBwZW5kaW5nQWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZW5kaW5nQWN0aW9uLmF0KSA/IHRyYW5zZm9ybVBlbmRpbmdQb2ludChlLCBwZW5kaW5nQWN0aW9uLmF0LCBvcCkgOiB0cmFuc2Zvcm1QZW5kaW5nUmFuZ2UoZSwgcGVuZGluZ0FjdGlvbi5hdCwgb3ApO1xuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLnNldChlLCBhdCA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGVuZGluZ0FjdGlvbiksIHt9LCB7XG4gICAgICAgIGF0XG4gICAgICB9KSA6IG51bGwpO1xuICAgIH1cbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKC4uLmdldE1hdGNoZXMoZSwgb3AucGF0aCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdzZXRfc2VsZWN0aW9uJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfRURJVE9SX1RPX1VTRVJfU0VMRUM7XG4gICAgICAgICAgLy8gU2VsZWN0aW9uIHdhcyBtYW51YWxseSBzZXQsIGRvbid0IHJlc3RvcmUgdGhlIHVzZXIgc2VsZWN0aW9uIGFmdGVyIHRoZSBjaGFuZ2UuXG4gICAgICAgICAgKF9FRElUT1JfVE9fVVNFUl9TRUxFQyA9IEVESVRPUl9UT19VU0VSX1NFTEVDVElPTi5nZXQoZSkpID09PSBudWxsIHx8IF9FRElUT1JfVE9fVVNFUl9TRUxFQyA9PT0gdm9pZCAwIHx8IF9FRElUT1JfVE9fVVNFUl9TRUxFQy51bnJlZigpO1xuICAgICAgICAgIEVESVRPUl9UT19VU0VSX1NFTEVDVElPTi5kZWxldGUoZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXMucHVzaCguLi5nZXRNYXRjaGVzKGUsIFBhdGgucGFyZW50KG9wLnBhdGgpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByZXZQYXRoID0gUGF0aC5wcmV2aW91cyhvcC5wYXRoKTtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goLi4uZ2V0TWF0Y2hlcyhlLCBwcmV2UGF0aCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNvbW1vblBhdGggPSBQYXRoLmNvbW1vbihQYXRoLnBhcmVudChvcC5wYXRoKSwgUGF0aC5wYXJlbnQob3AubmV3UGF0aCkpO1xuICAgICAgICAgIG1hdGNoZXMucHVzaCguLi5nZXRNYXRjaGVzKGUsIGNvbW1vblBhdGgpKTtcbiAgICAgICAgICB2YXIgY2hhbmdlZFBhdGg7XG4gICAgICAgICAgaWYgKFBhdGguaXNCZWZvcmUob3AucGF0aCwgb3AubmV3UGF0aCkpIHtcbiAgICAgICAgICAgIG1hdGNoZXMucHVzaCguLi5nZXRNYXRjaGVzKGUsIFBhdGgucGFyZW50KG9wLnBhdGgpKSk7XG4gICAgICAgICAgICBjaGFuZ2VkUGF0aCA9IG9wLm5ld1BhdGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoZXMucHVzaCguLi5nZXRNYXRjaGVzKGUsIFBhdGgucGFyZW50KG9wLm5ld1BhdGgpKSk7XG4gICAgICAgICAgICBjaGFuZ2VkUGF0aCA9IG9wLnBhdGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjaGFuZ2VkTm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgUGF0aC5wYXJlbnQoY2hhbmdlZFBhdGgpKTtcbiAgICAgICAgICB2YXIgY2hhbmdlZE5vZGVLZXkgPSBET01FZGl0b3IuZmluZEtleShlLCBjaGFuZ2VkTm9kZSk7XG4gICAgICAgICAgdmFyIGNoYW5nZWRQYXRoUmVmID0gRWRpdG9yLnBhdGhSZWYoZSwgUGF0aC5wYXJlbnQoY2hhbmdlZFBhdGgpKTtcbiAgICAgICAgICBwYXRoUmVmTWF0Y2hlcy5wdXNoKFtjaGFuZ2VkUGF0aFJlZiwgY2hhbmdlZE5vZGVLZXldKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseShvcCk7XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIElTX05PREVfTUFQX0RJUlRZLnNldChlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBbcGF0aCwga2V5XSBvZiBtYXRjaGVzKSB7XG4gICAgICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZSwgcGF0aCk7XG4gICAgICBOT0RFX1RPX0tFWS5zZXQobm9kZSwga2V5KTtcbiAgICB9XG4gICAgZm9yICh2YXIgW3BhdGhSZWYsIF9rZXldIG9mIHBhdGhSZWZNYXRjaGVzKSB7XG4gICAgICBpZiAocGF0aFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHZhciBbX25vZGVdID0gRWRpdG9yLm5vZGUoZSwgcGF0aFJlZi5jdXJyZW50KTtcbiAgICAgICAgTk9ERV9UT19LRVkuc2V0KF9ub2RlLCBfa2V5KTtcbiAgICAgIH1cbiAgICAgIHBhdGhSZWYudW5yZWYoKTtcbiAgICB9XG4gIH07XG4gIGUuc2V0RnJhZ21lbnREYXRhID0gZGF0YSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlO1xuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhzZWxlY3Rpb24pO1xuICAgIHZhciBzdGFydFZvaWQgPSBFZGl0b3Iudm9pZChlLCB7XG4gICAgICBhdDogc3RhcnQucGF0aFxuICAgIH0pO1xuICAgIHZhciBlbmRWb2lkID0gRWRpdG9yLnZvaWQoZSwge1xuICAgICAgYXQ6IGVuZC5wYXRoXG4gICAgfSk7XG4gICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikgJiYgIXN0YXJ0Vm9pZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBmYWtlIHNlbGVjdGlvbiBzbyB0aGF0IHdlIGNhbiBhZGQgYSBCYXNlNjQtZW5jb2RlZCBjb3B5IG9mIHRoZVxuICAgIC8vIGZyYWdtZW50IHRvIHRoZSBIVE1MLCB0byBkZWNvZGUgb24gZnV0dXJlIHBhc3Rlcy5cbiAgICB2YXIgZG9tUmFuZ2UgPSBET01FZGl0b3IudG9ET01SYW5nZShlLCBzZWxlY3Rpb24pO1xuICAgIHZhciBjb250ZW50cyA9IGRvbVJhbmdlLmNsb25lQ29udGVudHMoKTtcbiAgICB2YXIgYXR0YWNoID0gY29udGVudHMuY2hpbGROb2Rlc1swXTtcbiAgICAvLyBNYWtlIHN1cmUgYXR0YWNoIGlzIG5vbi1lbXB0eSwgc2luY2UgZW1wdHkgbm9kZXMgd2lsbCBub3QgZ2V0IGNvcGllZC5cbiAgICBjb250ZW50cy5jaGlsZE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICBpZiAobm9kZS50ZXh0Q29udGVudCAmJiBub2RlLnRleHRDb250ZW50LnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgYXR0YWNoID0gbm9kZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBDT01QQVQ6IElmIHRoZSBlbmQgbm9kZSBpcyBhIHZvaWQgbm9kZSwgd2UgbmVlZCB0byBtb3ZlIHRoZSBlbmQgb2YgdGhlXG4gICAgLy8gcmFuZ2UgZnJvbSB0aGUgdm9pZCBub2RlJ3Mgc3BhY2VyIHNwYW4sIHRvIHRoZSBlbmQgb2YgdGhlIHZvaWQgbm9kZSdzXG4gICAgLy8gY29udGVudCwgc2luY2UgdGhlIHNwYWNlciBpcyBiZWZvcmUgdm9pZCdzIGNvbnRlbnQgaW4gdGhlIERPTS5cbiAgICBpZiAoZW5kVm9pZCkge1xuICAgICAgdmFyIFt2b2lkTm9kZV0gPSBlbmRWb2lkO1xuICAgICAgdmFyIHIgPSBkb21SYW5nZS5jbG9uZVJhbmdlKCk7XG4gICAgICB2YXIgZG9tTm9kZSA9IERPTUVkaXRvci50b0RPTU5vZGUoZSwgdm9pZE5vZGUpO1xuICAgICAgci5zZXRFbmRBZnRlcihkb21Ob2RlKTtcbiAgICAgIGNvbnRlbnRzID0gci5jbG9uZUNvbnRlbnRzKCk7XG4gICAgfVxuICAgIC8vIENPTVBBVDogSWYgdGhlIHN0YXJ0IG5vZGUgaXMgYSB2b2lkIG5vZGUsIHdlIG5lZWQgdG8gYXR0YWNoIHRoZSBlbmNvZGVkXG4gICAgLy8gZnJhZ21lbnQgdG8gdGhlIHZvaWQgbm9kZSdzIGNvbnRlbnQgbm9kZSBpbnN0ZWFkIG9mIHRoZSBzcGFjZXIsIGJlY2F1c2VcbiAgICAvLyBhdHRhY2hpbmcgaXQgdG8gZW1wdHkgYDxkaXY+LzxzcGFuPmAgbm9kZXMgd2lsbCBlbmQgdXAgaGF2aW5nIGl0IGVyYXNlZCBieVxuICAgIC8vIG1vc3QgYnJvd3NlcnMuICgyMDE4LzA0LzI3KVxuICAgIGlmIChzdGFydFZvaWQpIHtcbiAgICAgIGF0dGFjaCA9IGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXNsYXRlLXNwYWNlcl0nKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGFueSB6ZXJvLXdpZHRoIHNwYWNlIHNwYW5zIGZyb20gdGhlIGNsb25lZCBET00gc28gdGhhdCB0aGV5IGRvbid0XG4gICAgLy8gc2hvdyB1cCBlbHNld2hlcmUgd2hlbiBwYXN0ZWQuXG4gICAgQXJyYXkuZnJvbShjb250ZW50cy5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXScpKS5mb3JFYWNoKHp3ID0+IHtcbiAgICAgIHZhciBpc05ld2xpbmUgPSB6dy5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpID09PSAnbic7XG4gICAgICB6dy50ZXh0Q29udGVudCA9IGlzTmV3bGluZSA/ICdcXG4nIDogJyc7XG4gICAgfSk7XG4gICAgLy8gU2V0IGEgYGRhdGEtc2xhdGUtZnJhZ21lbnRgIGF0dHJpYnV0ZSBvbiBhIG5vbi1lbXB0eSBub2RlLCBzbyBpdCBzaG93cyB1cFxuICAgIC8vIGluIHRoZSBIVE1MLCBhbmQgY2FuIGJlIHVzZWQgZm9yIGludHJhLVNsYXRlIHBhc3RpbmcuIElmIGl0J3MgYSB0ZXh0XG4gICAgLy8gbm9kZSwgd3JhcCBpdCBpbiBhIGA8c3Bhbj5gIHNvIHdlIGhhdmUgc29tZXRoaW5nIHRvIHNldCBhbiBhdHRyaWJ1dGUgb24uXG4gICAgaWYgKGlzRE9NVGV4dChhdHRhY2gpKSB7XG4gICAgICB2YXIgc3BhbiA9IGF0dGFjaC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIC8vIENPTVBBVDogSW4gQ2hyb21lIGFuZCBTYWZhcmksIGlmIHdlIGRvbid0IGFkZCB0aGUgYHdoaXRlLXNwYWNlYCBzdHlsZVxuICAgICAgLy8gdGhlbiBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXMgd2lsbCBiZSBpZ25vcmVkLiAoMjAxNy8wOS8yMSlcbiAgICAgIHNwYW4uc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUnO1xuICAgICAgc3Bhbi5hcHBlbmRDaGlsZChhdHRhY2gpO1xuICAgICAgY29udGVudHMuYXBwZW5kQ2hpbGQoc3Bhbik7XG4gICAgICBhdHRhY2ggPSBzcGFuO1xuICAgIH1cbiAgICB2YXIgZnJhZ21lbnQgPSBlLmdldEZyYWdtZW50KCk7XG4gICAgdmFyIHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGZyYWdtZW50KTtcbiAgICB2YXIgZW5jb2RlZCA9IHdpbmRvdy5idG9hKGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmcpKTtcbiAgICBhdHRhY2guc2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLWZyYWdtZW50JywgZW5jb2RlZCk7XG4gICAgZGF0YS5zZXREYXRhKFwiYXBwbGljYXRpb24vXCIuY29uY2F0KGNsaXBib2FyZEZvcm1hdEtleSksIGVuY29kZWQpO1xuICAgIC8vIEFkZCB0aGUgY29udGVudCB0byBhIDxkaXY+IHNvIHRoYXQgd2UgY2FuIGdldCBpdHMgaW5uZXIgSFRNTC5cbiAgICB2YXIgZGl2ID0gY29udGVudHMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQoY29udGVudHMpO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2hpZGRlbicsICd0cnVlJyk7XG4gICAgY29udGVudHMub3duZXJEb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgZGF0YS5zZXREYXRhKCd0ZXh0L2h0bWwnLCBkaXYuaW5uZXJIVE1MKTtcbiAgICBkYXRhLnNldERhdGEoJ3RleHQvcGxhaW4nLCBnZXRQbGFpblRleHQoZGl2KSk7XG4gICAgY29udGVudHMub3duZXJEb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG4gIGUuaW5zZXJ0RGF0YSA9IGRhdGEgPT4ge1xuICAgIGlmICghZS5pbnNlcnRGcmFnbWVudERhdGEoZGF0YSkpIHtcbiAgICAgIGUuaW5zZXJ0VGV4dERhdGEoZGF0YSk7XG4gICAgfVxuICB9O1xuICBlLmluc2VydEZyYWdtZW50RGF0YSA9IGRhdGEgPT4ge1xuICAgIC8qKlxuICAgICAqIENoZWNraW5nIGNvcGllZCBmcmFnbWVudCBmcm9tIGFwcGxpY2F0aW9uL3gtc2xhdGUtZnJhZ21lbnQgb3IgZGF0YS1zbGF0ZS1mcmFnbWVudFxuICAgICAqL1xuICAgIHZhciBmcmFnbWVudCA9IGRhdGEuZ2V0RGF0YShcImFwcGxpY2F0aW9uL1wiLmNvbmNhdChjbGlwYm9hcmRGb3JtYXRLZXkpKSB8fCBnZXRTbGF0ZUZyYWdtZW50QXR0cmlidXRlKGRhdGEpO1xuICAgIGlmIChmcmFnbWVudCkge1xuICAgICAgdmFyIGRlY29kZWQgPSBkZWNvZGVVUklDb21wb25lbnQod2luZG93LmF0b2IoZnJhZ21lbnQpKTtcbiAgICAgIHZhciBwYXJzZWQgPSBKU09OLnBhcnNlKGRlY29kZWQpO1xuICAgICAgZS5pbnNlcnRGcmFnbWVudChwYXJzZWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgZS5pbnNlcnRUZXh0RGF0YSA9IGRhdGEgPT4ge1xuICAgIHZhciB0ZXh0ID0gZGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJyk7XG4gICAgaWYgKHRleHQpIHtcbiAgICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoL1xcclxcbnxcXHJ8XFxuLyk7XG4gICAgICB2YXIgc3BsaXQgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgaWYgKHNwbGl0KSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGUsIHtcbiAgICAgICAgICAgIGFsd2F5czogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGUuaW5zZXJ0VGV4dChsaW5lKTtcbiAgICAgICAgc3BsaXQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgZS5vbkNoYW5nZSA9IG9wdGlvbnMgPT4ge1xuICAgIHZhciBvbkNvbnRleHRDaGFuZ2UgPSBFRElUT1JfVE9fT05fQ0hBTkdFLmdldChlKTtcbiAgICBpZiAob25Db250ZXh0Q2hhbmdlKSB7XG4gICAgICBvbkNvbnRleHRDaGFuZ2Uob3B0aW9ucyk7XG4gICAgfVxuICAgIG9uQ2hhbmdlKG9wdGlvbnMpO1xuICB9O1xuICByZXR1cm4gZTtcbn07XG52YXIgZ2V0TWF0Y2hlcyA9IChlLCBwYXRoKSA9PiB7XG4gIHZhciBtYXRjaGVzID0gW107XG4gIGZvciAodmFyIFtuLCBwXSBvZiBFZGl0b3IubGV2ZWxzKGUsIHtcbiAgICBhdDogcGF0aFxuICB9KSkge1xuICAgIHZhciBrZXkgPSBET01FZGl0b3IuZmluZEtleShlLCBuKTtcbiAgICBtYXRjaGVzLnB1c2goW3AsIGtleV0pO1xuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufTtcblxudmFyIFRSSVBMRV9DTElDSyA9IDM7XG5cbi8qKlxuICogSG90a2V5IG1hcHBpbmdzIGZvciBlYWNoIHBsYXRmb3JtLlxuICovXG52YXIgSE9US0VZUyA9IHtcbiAgYm9sZDogJ21vZCtiJyxcbiAgY29tcG9zZTogWydkb3duJywgJ2xlZnQnLCAncmlnaHQnLCAndXAnLCAnYmFja3NwYWNlJywgJ2VudGVyJ10sXG4gIG1vdmVCYWNrd2FyZDogJ2xlZnQnLFxuICBtb3ZlRm9yd2FyZDogJ3JpZ2h0JyxcbiAgbW92ZVdvcmRCYWNrd2FyZDogJ2N0cmwrbGVmdCcsXG4gIG1vdmVXb3JkRm9yd2FyZDogJ2N0cmwrcmlnaHQnLFxuICBkZWxldGVCYWNrd2FyZDogJ3NoaWZ0PytiYWNrc3BhY2UnLFxuICBkZWxldGVGb3J3YXJkOiAnc2hpZnQ/K2RlbGV0ZScsXG4gIGV4dGVuZEJhY2t3YXJkOiAnc2hpZnQrbGVmdCcsXG4gIGV4dGVuZEZvcndhcmQ6ICdzaGlmdCtyaWdodCcsXG4gIGl0YWxpYzogJ21vZCtpJyxcbiAgaW5zZXJ0U29mdEJyZWFrOiAnc2hpZnQrZW50ZXInLFxuICBzcGxpdEJsb2NrOiAnZW50ZXInLFxuICB1bmRvOiAnbW9kK3onXG59O1xudmFyIEFQUExFX0hPVEtFWVMgPSB7XG4gIG1vdmVMaW5lQmFja3dhcmQ6ICdvcHQrdXAnLFxuICBtb3ZlTGluZUZvcndhcmQ6ICdvcHQrZG93bicsXG4gIG1vdmVXb3JkQmFja3dhcmQ6ICdvcHQrbGVmdCcsXG4gIG1vdmVXb3JkRm9yd2FyZDogJ29wdCtyaWdodCcsXG4gIGRlbGV0ZUJhY2t3YXJkOiBbJ2N0cmwrYmFja3NwYWNlJywgJ2N0cmwraCddLFxuICBkZWxldGVGb3J3YXJkOiBbJ2N0cmwrZGVsZXRlJywgJ2N0cmwrZCddLFxuICBkZWxldGVMaW5lQmFja3dhcmQ6ICdjbWQrc2hpZnQ/K2JhY2tzcGFjZScsXG4gIGRlbGV0ZUxpbmVGb3J3YXJkOiBbJ2NtZCtzaGlmdD8rZGVsZXRlJywgJ2N0cmwrayddLFxuICBkZWxldGVXb3JkQmFja3dhcmQ6ICdvcHQrc2hpZnQ/K2JhY2tzcGFjZScsXG4gIGRlbGV0ZVdvcmRGb3J3YXJkOiAnb3B0K3NoaWZ0PytkZWxldGUnLFxuICBleHRlbmRMaW5lQmFja3dhcmQ6ICdvcHQrc2hpZnQrdXAnLFxuICBleHRlbmRMaW5lRm9yd2FyZDogJ29wdCtzaGlmdCtkb3duJyxcbiAgcmVkbzogJ2NtZCtzaGlmdCt6JyxcbiAgdHJhbnNwb3NlQ2hhcmFjdGVyOiAnY3RybCt0J1xufTtcbnZhciBXSU5ET1dTX0hPVEtFWVMgPSB7XG4gIGRlbGV0ZVdvcmRCYWNrd2FyZDogJ2N0cmwrc2hpZnQ/K2JhY2tzcGFjZScsXG4gIGRlbGV0ZVdvcmRGb3J3YXJkOiAnY3RybCtzaGlmdD8rZGVsZXRlJyxcbiAgcmVkbzogWydjdHJsK3knLCAnY3RybCtzaGlmdCt6J11cbn07XG4vKipcbiAqIENyZWF0ZSBhIHBsYXRmb3JtLWF3YXJlIGhvdGtleSBjaGVja2VyLlxuICovXG52YXIgY3JlYXRlID0ga2V5ID0+IHtcbiAgdmFyIGdlbmVyaWMgPSBIT1RLRVlTW2tleV07XG4gIHZhciBhcHBsZSA9IEFQUExFX0hPVEtFWVNba2V5XTtcbiAgdmFyIHdpbmRvd3MgPSBXSU5ET1dTX0hPVEtFWVNba2V5XTtcbiAgdmFyIGlzR2VuZXJpYyA9IGdlbmVyaWMgJiYgaXNIb3RrZXkoZ2VuZXJpYyk7XG4gIHZhciBpc0FwcGxlID0gYXBwbGUgJiYgaXNIb3RrZXkoYXBwbGUpO1xuICB2YXIgaXNXaW5kb3dzID0gd2luZG93cyAmJiBpc0hvdGtleSh3aW5kb3dzKTtcbiAgcmV0dXJuIGV2ZW50ID0+IHtcbiAgICBpZiAoaXNHZW5lcmljICYmIGlzR2VuZXJpYyhldmVudCkpIHJldHVybiB0cnVlO1xuICAgIGlmIChJU19BUFBMRSAmJiBpc0FwcGxlICYmIGlzQXBwbGUoZXZlbnQpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIUlTX0FQUExFICYmIGlzV2luZG93cyAmJiBpc1dpbmRvd3MoZXZlbnQpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59O1xuLyoqXG4gKiBIb3RrZXlzLlxuICovXG52YXIgaG90a2V5cyA9IHtcbiAgaXNCb2xkOiBjcmVhdGUoJ2JvbGQnKSxcbiAgaXNDb21wb3NlOiBjcmVhdGUoJ2NvbXBvc2UnKSxcbiAgaXNNb3ZlQmFja3dhcmQ6IGNyZWF0ZSgnbW92ZUJhY2t3YXJkJyksXG4gIGlzTW92ZUZvcndhcmQ6IGNyZWF0ZSgnbW92ZUZvcndhcmQnKSxcbiAgaXNEZWxldGVCYWNrd2FyZDogY3JlYXRlKCdkZWxldGVCYWNrd2FyZCcpLFxuICBpc0RlbGV0ZUZvcndhcmQ6IGNyZWF0ZSgnZGVsZXRlRm9yd2FyZCcpLFxuICBpc0RlbGV0ZUxpbmVCYWNrd2FyZDogY3JlYXRlKCdkZWxldGVMaW5lQmFja3dhcmQnKSxcbiAgaXNEZWxldGVMaW5lRm9yd2FyZDogY3JlYXRlKCdkZWxldGVMaW5lRm9yd2FyZCcpLFxuICBpc0RlbGV0ZVdvcmRCYWNrd2FyZDogY3JlYXRlKCdkZWxldGVXb3JkQmFja3dhcmQnKSxcbiAgaXNEZWxldGVXb3JkRm9yd2FyZDogY3JlYXRlKCdkZWxldGVXb3JkRm9yd2FyZCcpLFxuICBpc0V4dGVuZEJhY2t3YXJkOiBjcmVhdGUoJ2V4dGVuZEJhY2t3YXJkJyksXG4gIGlzRXh0ZW5kRm9yd2FyZDogY3JlYXRlKCdleHRlbmRGb3J3YXJkJyksXG4gIGlzRXh0ZW5kTGluZUJhY2t3YXJkOiBjcmVhdGUoJ2V4dGVuZExpbmVCYWNrd2FyZCcpLFxuICBpc0V4dGVuZExpbmVGb3J3YXJkOiBjcmVhdGUoJ2V4dGVuZExpbmVGb3J3YXJkJyksXG4gIGlzSXRhbGljOiBjcmVhdGUoJ2l0YWxpYycpLFxuICBpc01vdmVMaW5lQmFja3dhcmQ6IGNyZWF0ZSgnbW92ZUxpbmVCYWNrd2FyZCcpLFxuICBpc01vdmVMaW5lRm9yd2FyZDogY3JlYXRlKCdtb3ZlTGluZUZvcndhcmQnKSxcbiAgaXNNb3ZlV29yZEJhY2t3YXJkOiBjcmVhdGUoJ21vdmVXb3JkQmFja3dhcmQnKSxcbiAgaXNNb3ZlV29yZEZvcndhcmQ6IGNyZWF0ZSgnbW92ZVdvcmRGb3J3YXJkJyksXG4gIGlzUmVkbzogY3JlYXRlKCdyZWRvJyksXG4gIGlzU29mdEJyZWFrOiBjcmVhdGUoJ2luc2VydFNvZnRCcmVhaycpLFxuICBpc1NwbGl0QmxvY2s6IGNyZWF0ZSgnc3BsaXRCbG9jaycpLFxuICBpc1RyYW5zcG9zZUNoYXJhY3RlcjogY3JlYXRlKCd0cmFuc3Bvc2VDaGFyYWN0ZXInKSxcbiAgaXNVbmRvOiBjcmVhdGUoJ3VuZG8nKVxufTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgdmFyIGtleSwgaTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxudmFyIF9leGNsdWRlZCA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdLFxuICBfZXhjbHVkZWQyID0gW1wiYW5jaG9yXCIsIFwiZm9jdXNcIl07XG52YXIgc2hhbGxvd0NvbXBhcmUgPSAob2JqMSwgb2JqMikgPT4gT2JqZWN0LmtleXMob2JqMSkubGVuZ3RoID09PSBPYmplY3Qua2V5cyhvYmoyKS5sZW5ndGggJiYgT2JqZWN0LmtleXMob2JqMSkuZXZlcnkoa2V5ID0+IG9iajIuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBvYmoxW2tleV0gPT09IG9iajJba2V5XSk7XG52YXIgaXNEZWNvcmF0aW9uRmxhZ3NFcXVhbCA9IChyYW5nZSwgb3RoZXIpID0+IHtcbiAgdmFyIHJhbmdlT3duUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocmFuZ2UsIF9leGNsdWRlZCk7XG4gIHZhciBvdGhlck93blByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG90aGVyLCBfZXhjbHVkZWQyKTtcbiAgcmV0dXJuIHJhbmdlW1BMQUNFSE9MREVSX1NZTUJPTF0gPT09IG90aGVyW1BMQUNFSE9MREVSX1NZTUJPTF0gJiYgc2hhbGxvd0NvbXBhcmUocmFuZ2VPd25Qcm9wcywgb3RoZXJPd25Qcm9wcyk7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhIGxpc3Qgb2YgZGVjb3JhdG9yIHJhbmdlcyBhcmUgZXF1YWwgdG8gYW5vdGhlci5cbiAqXG4gKiBQRVJGOiB0aGlzIHJlcXVpcmVzIHRoZSB0d28gbGlzdHMgdG8gYWxzbyBoYXZlIHRoZSByYW5nZXMgaW5zaWRlIHRoZW0gaW4gdGhlXG4gKiBzYW1lIG9yZGVyLCBidXQgdGhpcyBpcyBhbiBva2F5IGNvbnN0cmFpbnQgZm9yIHVzIHNpbmNlIGRlY29yYXRpb25zIGFyZVxuICoga2VwdCBpbiBvcmRlciwgYW5kIHRoZSBvZGQgY2FzZSB3aGVyZSB0aGV5IGFyZW4ndCBpcyBva2F5IHRvIHJlLXJlbmRlciBmb3IuXG4gKi9cbnZhciBpc0VsZW1lbnREZWNvcmF0aW9uc0VxdWFsID0gKGxpc3QsIGFub3RoZXIpID0+IHtcbiAgaWYgKGxpc3QubGVuZ3RoICE9PSBhbm90aGVyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmFuZ2UgPSBsaXN0W2ldO1xuICAgIHZhciBvdGhlciA9IGFub3RoZXJbaV07XG4gICAgaWYgKCFSYW5nZS5lcXVhbHMocmFuZ2UsIG90aGVyKSB8fCAhaXNEZWNvcmF0aW9uRmxhZ3NFcXVhbChyYW5nZSwgb3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogQ2hlY2sgaWYgYSBsaXN0IG9mIGRlY29yYXRvciByYW5nZXMgYXJlIGVxdWFsIHRvIGFub3RoZXIuXG4gKlxuICogUEVSRjogdGhpcyByZXF1aXJlcyB0aGUgdHdvIGxpc3RzIHRvIGFsc28gaGF2ZSB0aGUgcmFuZ2VzIGluc2lkZSB0aGVtIGluIHRoZVxuICogc2FtZSBvcmRlciwgYnV0IHRoaXMgaXMgYW4gb2theSBjb25zdHJhaW50IGZvciB1cyBzaW5jZSBkZWNvcmF0aW9ucyBhcmVcbiAqIGtlcHQgaW4gb3JkZXIsIGFuZCB0aGUgb2RkIGNhc2Ugd2hlcmUgdGhleSBhcmVuJ3QgaXMgb2theSB0byByZS1yZW5kZXIgZm9yLlxuICovXG52YXIgaXNUZXh0RGVjb3JhdGlvbnNFcXVhbCA9IChsaXN0LCBhbm90aGVyKSA9PiB7XG4gIGlmIChsaXN0Lmxlbmd0aCAhPT0gYW5vdGhlci5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJhbmdlID0gbGlzdFtpXTtcbiAgICB2YXIgb3RoZXIgPSBhbm90aGVyW2ldO1xuICAgIC8vIGNvbXBhcmUgb25seSBvZmZzZXRzIGJlY2F1c2UgcGF0aHMgZG9lc24ndCBtYXR0ZXIgZm9yIHRleHRcbiAgICBpZiAocmFuZ2UuYW5jaG9yLm9mZnNldCAhPT0gb3RoZXIuYW5jaG9yLm9mZnNldCB8fCByYW5nZS5mb2N1cy5vZmZzZXQgIT09IG90aGVyLmZvY3VzLm9mZnNldCB8fCAhaXNEZWNvcmF0aW9uRmxhZ3NFcXVhbChyYW5nZSwgb3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0IHsgQ0FOX1VTRV9ET00sIERPTUVkaXRvciwgRE9NRWxlbWVudCwgRE9NTm9kZSwgRE9NUmFuZ2UsIERPTVNlbGVjdGlvbiwgRE9NU3RhdGljUmFuZ2UsIERPTVRleHQsIEVESVRPUl9UT19FTEVNRU5ULCBFRElUT1JfVE9fRk9SQ0VfUkVOREVSLCBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQsIEVESVRPUl9UT19PTl9DSEFOR0UsIEVESVRPUl9UT19QRU5ESU5HX0FDVElPTiwgRURJVE9SX1RPX1BFTkRJTkdfRElGRlMsIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUywgRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLCBFRElUT1JfVE9fUExBQ0VIT0xERVJfRUxFTUVOVCwgRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNILCBFRElUT1JfVE9fVVNFUl9NQVJLUywgRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OLCBFRElUT1JfVE9fV0lORE9XLCBFTEVNRU5UX1RPX05PREUsIEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCwgaG90a2V5cyBhcyBIb3RrZXlzLCBJU19BTkRST0lELCBJU19DSFJPTUUsIElTX0NPTVBPU0lORywgSVNfRklSRUZPWCwgSVNfRklSRUZPWF9MRUdBQ1ksIElTX0ZPQ1VTRUQsIElTX0lPUywgSVNfTk9ERV9NQVBfRElSVFksIElTX1JFQURfT05MWSwgSVNfVUNfTU9CSUxFLCBJU19XRUJLSVQsIElTX1dFQ0hBVEJST1dTRVIsIEtleSwgTUFSS19QTEFDRUhPTERFUl9TWU1CT0wsIE5PREVfVE9fRUxFTUVOVCwgTk9ERV9UT19JTkRFWCwgTk9ERV9UT19LRVksIE5PREVfVE9fUEFSRU5ULCBQTEFDRUhPTERFUl9TWU1CT0wsIFRSSVBMRV9DTElDSywgYXBwbHlTdHJpbmdEaWZmLCBnZXRBY3RpdmVFbGVtZW50LCBnZXREZWZhdWx0VmlldywgZ2V0U2VsZWN0aW9uLCBoYXNTaGFkb3dSb290LCBpc0FmdGVyLCBpc0JlZm9yZSwgaXNET01FbGVtZW50LCBpc0RPTU5vZGUsIGlzRE9NU2VsZWN0aW9uLCBpc0VsZW1lbnREZWNvcmF0aW9uc0VxdWFsLCBpc1BsYWluVGV4dE9ubHlQYXN0ZSwgaXNUZXh0RGVjb3JhdGlvbnNFcXVhbCwgaXNUcmFja2VkTXV0YXRpb24sIG1lcmdlU3RyaW5nRGlmZnMsIG5vcm1hbGl6ZURPTVBvaW50LCBub3JtYWxpemVQb2ludCwgbm9ybWFsaXplUmFuZ2UsIG5vcm1hbGl6ZVN0cmluZ0RpZmYsIHRhcmdldFJhbmdlLCB2ZXJpZnlEaWZmU3RhdGUsIHdpdGhET00gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/slate-dom/dist/index.es.js\n");

/***/ })

};
;