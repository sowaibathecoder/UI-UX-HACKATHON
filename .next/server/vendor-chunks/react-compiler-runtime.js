/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-compiler-runtime";
exports.ids = ["vendor-chunks/react-compiler-runtime"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-compiler-runtime/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-compiler-runtime/dist/index.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @lightSyntaxTransform\n * @noflow\n * @nolint\n * @preventMunge\n * @preserve-invariant-messages\n */\n\n\"use no memo\";\n\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar index_exports = {};\n__export(index_exports, {\n  $dispatcherGuard: () => $dispatcherGuard,\n  $makeReadOnly: () => $makeReadOnly,\n  $reset: () => $reset,\n  $structuralCheck: () => $structuralCheck,\n  c: () => c,\n  clearRenderCounterRegistry: () => clearRenderCounterRegistry,\n  renderCounterRegistry: () => renderCounterRegistry,\n  useRenderCounter: () => useRenderCounter\n});\nmodule.exports = __toCommonJS(index_exports);\nvar React = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"));\nvar { useRef, useEffect, isValidElement } = React;\nvar _a;\nvar ReactSecretInternals = (\n  //@ts-ignore\n  (_a = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE) != null ? _a : React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n);\nvar $empty = Symbol.for(\"react.memo_cache_sentinel\");\nvar _a2;\nvar c = (\n  // @ts-expect-error\n  typeof ((_a2 = React.__COMPILER_RUNTIME) == null ? void 0 : _a2.c) === \"function\" ? (\n    // @ts-expect-error\n    React.__COMPILER_RUNTIME.c\n  ) : function c2(size) {\n    return React.useMemo(() => {\n      const $ = new Array(size);\n      for (let ii = 0; ii < size; ii++) {\n        $[ii] = $empty;\n      }\n      $[$empty] = true;\n      return $;\n    }, []);\n  }\n);\nvar LazyGuardDispatcher = {};\n[\n  \"readContext\",\n  \"useCallback\",\n  \"useContext\",\n  \"useEffect\",\n  \"useImperativeHandle\",\n  \"useInsertionEffect\",\n  \"useLayoutEffect\",\n  \"useMemo\",\n  \"useReducer\",\n  \"useRef\",\n  \"useState\",\n  \"useDebugValue\",\n  \"useDeferredValue\",\n  \"useTransition\",\n  \"useMutableSource\",\n  \"useSyncExternalStore\",\n  \"useId\",\n  \"unstable_isNewReconciler\",\n  \"getCacheSignal\",\n  \"getCacheForType\",\n  \"useCacheRefresh\"\n].forEach((name) => {\n  LazyGuardDispatcher[name] = () => {\n    throw new Error(\n      `[React] Unexpected React hook call (${name}) from a React compiled function. Check that all hooks are called directly and named according to convention ('use[A-Z]') `\n    );\n  };\n});\nvar originalDispatcher = null;\nLazyGuardDispatcher[\"useMemoCache\"] = (count) => {\n  if (originalDispatcher == null) {\n    throw new Error(\n      \"React Compiler internal invariant violation: unexpected null dispatcher\"\n    );\n  } else {\n    return originalDispatcher.useMemoCache(count);\n  }\n};\nfunction setCurrent(newDispatcher) {\n  ReactSecretInternals.ReactCurrentDispatcher.current = newDispatcher;\n  return ReactSecretInternals.ReactCurrentDispatcher.current;\n}\nvar guardFrames = [];\nfunction $dispatcherGuard(kind) {\n  const curr = ReactSecretInternals.ReactCurrentDispatcher.current;\n  if (kind === 0 /* PushGuardContext */) {\n    guardFrames.push(curr);\n    if (guardFrames.length === 1) {\n      originalDispatcher = curr;\n    }\n    if (curr === LazyGuardDispatcher) {\n      throw new Error(\n        `[React] Unexpected call to custom hook or component from a React compiled function. Check that (1) all hooks are called directly and named according to convention ('use[A-Z]') and (2) components are returned as JSX instead of being directly invoked.`\n      );\n    }\n    setCurrent(LazyGuardDispatcher);\n  } else if (kind === 1 /* PopGuardContext */) {\n    const lastFrame = guardFrames.pop();\n    if (lastFrame == null) {\n      throw new Error(\n        \"React Compiler internal error: unexpected null in guard stack\"\n      );\n    }\n    if (guardFrames.length === 0) {\n      originalDispatcher = null;\n    }\n    setCurrent(lastFrame);\n  } else if (kind === 2 /* PushExpectHook */) {\n    guardFrames.push(curr);\n    setCurrent(originalDispatcher);\n  } else if (kind === 3 /* PopExpectHook */) {\n    const lastFrame = guardFrames.pop();\n    if (lastFrame == null) {\n      throw new Error(\n        \"React Compiler internal error: unexpected null in guard stack\"\n      );\n    }\n    setCurrent(lastFrame);\n  } else {\n    throw new Error(\"React Compiler internal error: unreachable block\" + kind);\n  }\n}\nfunction $reset($) {\n  for (let ii = 0; ii < $.length; ii++) {\n    $[ii] = $empty;\n  }\n}\nfunction $makeReadOnly() {\n  throw new Error(\"TODO: implement $makeReadOnly in react-compiler-runtime\");\n}\nvar renderCounterRegistry = /* @__PURE__ */ new Map();\nfunction clearRenderCounterRegistry() {\n  for (const counters of renderCounterRegistry.values()) {\n    counters.forEach((counter) => {\n      counter.count = 0;\n    });\n  }\n}\nfunction registerRenderCounter(name, val) {\n  let counters = renderCounterRegistry.get(name);\n  if (counters == null) {\n    counters = /* @__PURE__ */ new Set();\n    renderCounterRegistry.set(name, counters);\n  }\n  counters.add(val);\n}\nfunction removeRenderCounter(name, val) {\n  const counters = renderCounterRegistry.get(name);\n  if (counters == null) {\n    return;\n  }\n  counters.delete(val);\n}\nfunction useRenderCounter(name) {\n  const val = useRef(null);\n  if (val.current != null) {\n    val.current.count += 1;\n  }\n  useEffect(() => {\n    if (val.current == null) {\n      const counter = { count: 0 };\n      registerRenderCounter(name, counter);\n      val.current = counter;\n    }\n    return () => {\n      if (val.current !== null) {\n        removeRenderCounter(name, val.current);\n      }\n    };\n  });\n}\nvar seenErrors = /* @__PURE__ */ new Set();\nfunction $structuralCheck(oldValue, newValue, variableName, fnName, kind, loc) {\n  function error(l, r, path, depth) {\n    const str = `${fnName}:${loc} [${kind}] ${variableName}${path} changed from ${l} to ${r} at depth ${depth}`;\n    if (seenErrors.has(str)) {\n      return;\n    }\n    seenErrors.add(str);\n    console.error(str);\n  }\n  const depthLimit = 2;\n  function recur(oldValue2, newValue2, path, depth) {\n    if (depth > depthLimit) {\n      return;\n    } else if (oldValue2 === newValue2) {\n      return;\n    } else if (typeof oldValue2 !== typeof newValue2) {\n      error(`type ${typeof oldValue2}`, `type ${typeof newValue2}`, path, depth);\n    } else if (typeof oldValue2 === \"object\") {\n      const oldArray = Array.isArray(oldValue2);\n      const newArray = Array.isArray(newValue2);\n      if (oldValue2 === null && newValue2 !== null) {\n        error(\"null\", `type ${typeof newValue2}`, path, depth);\n      } else if (newValue2 === null) {\n        error(`type ${typeof oldValue2}`, \"null\", path, depth);\n      } else if (oldValue2 instanceof Map) {\n        if (!(newValue2 instanceof Map)) {\n          error(`Map instance`, `other value`, path, depth);\n        } else if (oldValue2.size !== newValue2.size) {\n          error(\n            `Map instance with size ${oldValue2.size}`,\n            `Map instance with size ${newValue2.size}`,\n            path,\n            depth\n          );\n        } else {\n          for (const [k, v] of oldValue2) {\n            if (!newValue2.has(k)) {\n              error(\n                `Map instance with key ${k}`,\n                `Map instance without key ${k}`,\n                path,\n                depth\n              );\n            } else {\n              recur(v, newValue2.get(k), `${path}.get(${k})`, depth + 1);\n            }\n          }\n        }\n      } else if (newValue2 instanceof Map) {\n        error(\"other value\", `Map instance`, path, depth);\n      } else if (oldValue2 instanceof Set) {\n        if (!(newValue2 instanceof Set)) {\n          error(`Set instance`, `other value`, path, depth);\n        } else if (oldValue2.size !== newValue2.size) {\n          error(\n            `Set instance with size ${oldValue2.size}`,\n            `Set instance with size ${newValue2.size}`,\n            path,\n            depth\n          );\n        } else {\n          for (const v of newValue2) {\n            if (!oldValue2.has(v)) {\n              error(\n                `Set instance without element ${v}`,\n                `Set instance with element ${v}`,\n                path,\n                depth\n              );\n            }\n          }\n        }\n      } else if (newValue2 instanceof Set) {\n        error(\"other value\", `Set instance`, path, depth);\n      } else if (oldArray || newArray) {\n        if (oldArray !== newArray) {\n          error(\n            `type ${oldArray ? \"array\" : \"object\"}`,\n            `type ${newArray ? \"array\" : \"object\"}`,\n            path,\n            depth\n          );\n        } else if (oldValue2.length !== newValue2.length) {\n          error(\n            `array with length ${oldValue2.length}`,\n            `array with length ${newValue2.length}`,\n            path,\n            depth\n          );\n        } else {\n          for (let ii = 0; ii < oldValue2.length; ii++) {\n            recur(oldValue2[ii], newValue2[ii], `${path}[${ii}]`, depth + 1);\n          }\n        }\n      } else if (isValidElement(oldValue2) || isValidElement(newValue2)) {\n        if (isValidElement(oldValue2) !== isValidElement(newValue2)) {\n          error(\n            `type ${isValidElement(oldValue2) ? \"React element\" : \"object\"}`,\n            `type ${isValidElement(newValue2) ? \"React element\" : \"object\"}`,\n            path,\n            depth\n          );\n        } else if (oldValue2.type !== newValue2.type) {\n          error(\n            `React element of type ${oldValue2.type}`,\n            `React element of type ${newValue2.type}`,\n            path,\n            depth\n          );\n        } else {\n          recur(\n            oldValue2.props,\n            newValue2.props,\n            `[props of ${path}]`,\n            depth + 1\n          );\n        }\n      } else {\n        for (const key in newValue2) {\n          if (!(key in oldValue2)) {\n            error(\n              `object without key ${key}`,\n              `object with key ${key}`,\n              path,\n              depth\n            );\n          }\n        }\n        for (const key in oldValue2) {\n          if (!(key in newValue2)) {\n            error(\n              `object with key ${key}`,\n              `object without key ${key}`,\n              path,\n              depth\n            );\n          } else {\n            recur(oldValue2[key], newValue2[key], `${path}.${key}`, depth + 1);\n          }\n        }\n      }\n    } else if (typeof oldValue2 === \"function\") {\n      return;\n    } else if (isNaN(oldValue2) || isNaN(newValue2)) {\n      if (isNaN(oldValue2) !== isNaN(newValue2)) {\n        error(\n          `${isNaN(oldValue2) ? \"NaN\" : \"non-NaN value\"}`,\n          `${isNaN(newValue2) ? \"NaN\" : \"non-NaN value\"}`,\n          path,\n          depth\n        );\n      }\n    } else if (oldValue2 !== newValue2) {\n      error(oldValue2, newValue2, path, depth);\n    }\n  }\n  recur(oldValue, newValue, \"\", 0);\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtY29tcGlsZXItcnVudGltZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsaUdBQU87QUFDbkMsTUFBTSxvQ0FBb0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsS0FBSztBQUNsRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxhQUFhLDJDQUEyQztBQUN4RCxhQUFhLDJDQUEyQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBU0w7QUFDRCIsInNvdXJjZXMiOlsiRDpcXFNPV05fR0lBSUNcXE5FWFQtV09SS1xcSEFDS0FUSE9OLTNcXFVJLVVYLUhBQ0tBVEhPTi1OZXh0SlMtRGVzaWduLUphbS0yMDI0LShNWS1DTE9ORS1QUk9KRUNUKVxcbm9kZV9tb2R1bGVzXFxyZWFjdC1jb21waWxlci1ydW50aW1lXFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpZ2h0U3ludGF4VHJhbnNmb3JtXG4gKiBAbm9mbG93XG4gKiBAbm9saW50XG4gKiBAcHJldmVudE11bmdlXG4gKiBAcHJlc2VydmUtaW52YXJpYW50LW1lc3NhZ2VzXG4gKi9cblxuXCJ1c2Ugbm8gbWVtb1wiO1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9leHBvcnRzID0ge307XG5fX2V4cG9ydChpbmRleF9leHBvcnRzLCB7XG4gICRkaXNwYXRjaGVyR3VhcmQ6ICgpID0+ICRkaXNwYXRjaGVyR3VhcmQsXG4gICRtYWtlUmVhZE9ubHk6ICgpID0+ICRtYWtlUmVhZE9ubHksXG4gICRyZXNldDogKCkgPT4gJHJlc2V0LFxuICAkc3RydWN0dXJhbENoZWNrOiAoKSA9PiAkc3RydWN0dXJhbENoZWNrLFxuICBjOiAoKSA9PiBjLFxuICBjbGVhclJlbmRlckNvdW50ZXJSZWdpc3RyeTogKCkgPT4gY2xlYXJSZW5kZXJDb3VudGVyUmVnaXN0cnksXG4gIHJlbmRlckNvdW50ZXJSZWdpc3RyeTogKCkgPT4gcmVuZGVyQ291bnRlclJlZ2lzdHJ5LFxuICB1c2VSZW5kZXJDb3VudGVyOiAoKSA9PiB1c2VSZW5kZXJDb3VudGVyXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGluZGV4X2V4cG9ydHMpO1xudmFyIFJlYWN0ID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIHsgdXNlUmVmLCB1c2VFZmZlY3QsIGlzVmFsaWRFbGVtZW50IH0gPSBSZWFjdDtcbnZhciBfYTtcbnZhciBSZWFjdFNlY3JldEludGVybmFscyA9IChcbiAgLy9AdHMtaWdub3JlXG4gIChfYSA9IFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSkgIT0gbnVsbCA/IF9hIDogUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRURcbik7XG52YXIgJGVtcHR5ID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWxcIik7XG52YXIgX2EyO1xudmFyIGMgPSAoXG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgdHlwZW9mICgoX2EyID0gUmVhY3QuX19DT01QSUxFUl9SVU5USU1FKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmMpID09PSBcImZ1bmN0aW9uXCIgPyAoXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIFJlYWN0Ll9fQ09NUElMRVJfUlVOVElNRS5jXG4gICkgOiBmdW5jdGlvbiBjMihzaXplKSB7XG4gICAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgY29uc3QgJCA9IG5ldyBBcnJheShzaXplKTtcbiAgICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBzaXplOyBpaSsrKSB7XG4gICAgICAgICRbaWldID0gJGVtcHR5O1xuICAgICAgfVxuICAgICAgJFskZW1wdHldID0gdHJ1ZTtcbiAgICAgIHJldHVybiAkO1xuICAgIH0sIFtdKTtcbiAgfVxuKTtcbnZhciBMYXp5R3VhcmREaXNwYXRjaGVyID0ge307XG5bXG4gIFwicmVhZENvbnRleHRcIixcbiAgXCJ1c2VDYWxsYmFja1wiLFxuICBcInVzZUNvbnRleHRcIixcbiAgXCJ1c2VFZmZlY3RcIixcbiAgXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCIsXG4gIFwidXNlSW5zZXJ0aW9uRWZmZWN0XCIsXG4gIFwidXNlTGF5b3V0RWZmZWN0XCIsXG4gIFwidXNlTWVtb1wiLFxuICBcInVzZVJlZHVjZXJcIixcbiAgXCJ1c2VSZWZcIixcbiAgXCJ1c2VTdGF0ZVwiLFxuICBcInVzZURlYnVnVmFsdWVcIixcbiAgXCJ1c2VEZWZlcnJlZFZhbHVlXCIsXG4gIFwidXNlVHJhbnNpdGlvblwiLFxuICBcInVzZU11dGFibGVTb3VyY2VcIixcbiAgXCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVwiLFxuICBcInVzZUlkXCIsXG4gIFwidW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyXCIsXG4gIFwiZ2V0Q2FjaGVTaWduYWxcIixcbiAgXCJnZXRDYWNoZUZvclR5cGVcIixcbiAgXCJ1c2VDYWNoZVJlZnJlc2hcIlxuXS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gIExhenlHdWFyZERpc3BhdGNoZXJbbmFtZV0gPSAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFtSZWFjdF0gVW5leHBlY3RlZCBSZWFjdCBob29rIGNhbGwgKCR7bmFtZX0pIGZyb20gYSBSZWFjdCBjb21waWxlZCBmdW5jdGlvbi4gQ2hlY2sgdGhhdCBhbGwgaG9va3MgYXJlIGNhbGxlZCBkaXJlY3RseSBhbmQgbmFtZWQgYWNjb3JkaW5nIHRvIGNvbnZlbnRpb24gKCd1c2VbQS1aXScpIGBcbiAgICApO1xuICB9O1xufSk7XG52YXIgb3JpZ2luYWxEaXNwYXRjaGVyID0gbnVsbDtcbkxhenlHdWFyZERpc3BhdGNoZXJbXCJ1c2VNZW1vQ2FjaGVcIl0gPSAoY291bnQpID0+IHtcbiAgaWYgKG9yaWdpbmFsRGlzcGF0Y2hlciA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJSZWFjdCBDb21waWxlciBpbnRlcm5hbCBpbnZhcmlhbnQgdmlvbGF0aW9uOiB1bmV4cGVjdGVkIG51bGwgZGlzcGF0Y2hlclwiXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb3JpZ2luYWxEaXNwYXRjaGVyLnVzZU1lbW9DYWNoZShjb3VudCk7XG4gIH1cbn07XG5mdW5jdGlvbiBzZXRDdXJyZW50KG5ld0Rpc3BhdGNoZXIpIHtcbiAgUmVhY3RTZWNyZXRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbmV3RGlzcGF0Y2hlcjtcbiAgcmV0dXJuIFJlYWN0U2VjcmV0SW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcbn1cbnZhciBndWFyZEZyYW1lcyA9IFtdO1xuZnVuY3Rpb24gJGRpc3BhdGNoZXJHdWFyZChraW5kKSB7XG4gIGNvbnN0IGN1cnIgPSBSZWFjdFNlY3JldEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG4gIGlmIChraW5kID09PSAwIC8qIFB1c2hHdWFyZENvbnRleHQgKi8pIHtcbiAgICBndWFyZEZyYW1lcy5wdXNoKGN1cnIpO1xuICAgIGlmIChndWFyZEZyYW1lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIG9yaWdpbmFsRGlzcGF0Y2hlciA9IGN1cnI7XG4gICAgfVxuICAgIGlmIChjdXJyID09PSBMYXp5R3VhcmREaXNwYXRjaGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBbUmVhY3RdIFVuZXhwZWN0ZWQgY2FsbCB0byBjdXN0b20gaG9vayBvciBjb21wb25lbnQgZnJvbSBhIFJlYWN0IGNvbXBpbGVkIGZ1bmN0aW9uLiBDaGVjayB0aGF0ICgxKSBhbGwgaG9va3MgYXJlIGNhbGxlZCBkaXJlY3RseSBhbmQgbmFtZWQgYWNjb3JkaW5nIHRvIGNvbnZlbnRpb24gKCd1c2VbQS1aXScpIGFuZCAoMikgY29tcG9uZW50cyBhcmUgcmV0dXJuZWQgYXMgSlNYIGluc3RlYWQgb2YgYmVpbmcgZGlyZWN0bHkgaW52b2tlZC5gXG4gICAgICApO1xuICAgIH1cbiAgICBzZXRDdXJyZW50KExhenlHdWFyZERpc3BhdGNoZXIpO1xuICB9IGVsc2UgaWYgKGtpbmQgPT09IDEgLyogUG9wR3VhcmRDb250ZXh0ICovKSB7XG4gICAgY29uc3QgbGFzdEZyYW1lID0gZ3VhcmRGcmFtZXMucG9wKCk7XG4gICAgaWYgKGxhc3RGcmFtZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiUmVhY3QgQ29tcGlsZXIgaW50ZXJuYWwgZXJyb3I6IHVuZXhwZWN0ZWQgbnVsbCBpbiBndWFyZCBzdGFja1wiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZ3VhcmRGcmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBvcmlnaW5hbERpc3BhdGNoZXIgPSBudWxsO1xuICAgIH1cbiAgICBzZXRDdXJyZW50KGxhc3RGcmFtZSk7XG4gIH0gZWxzZSBpZiAoa2luZCA9PT0gMiAvKiBQdXNoRXhwZWN0SG9vayAqLykge1xuICAgIGd1YXJkRnJhbWVzLnB1c2goY3Vycik7XG4gICAgc2V0Q3VycmVudChvcmlnaW5hbERpc3BhdGNoZXIpO1xuICB9IGVsc2UgaWYgKGtpbmQgPT09IDMgLyogUG9wRXhwZWN0SG9vayAqLykge1xuICAgIGNvbnN0IGxhc3RGcmFtZSA9IGd1YXJkRnJhbWVzLnBvcCgpO1xuICAgIGlmIChsYXN0RnJhbWUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlJlYWN0IENvbXBpbGVyIGludGVybmFsIGVycm9yOiB1bmV4cGVjdGVkIG51bGwgaW4gZ3VhcmQgc3RhY2tcIlxuICAgICAgKTtcbiAgICB9XG4gICAgc2V0Q3VycmVudChsYXN0RnJhbWUpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWN0IENvbXBpbGVyIGludGVybmFsIGVycm9yOiB1bnJlYWNoYWJsZSBibG9ja1wiICsga2luZCk7XG4gIH1cbn1cbmZ1bmN0aW9uICRyZXNldCgkKSB7XG4gIGZvciAobGV0IGlpID0gMDsgaWkgPCAkLmxlbmd0aDsgaWkrKykge1xuICAgICRbaWldID0gJGVtcHR5O1xuICB9XG59XG5mdW5jdGlvbiAkbWFrZVJlYWRPbmx5KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJUT0RPOiBpbXBsZW1lbnQgJG1ha2VSZWFkT25seSBpbiByZWFjdC1jb21waWxlci1ydW50aW1lXCIpO1xufVxudmFyIHJlbmRlckNvdW50ZXJSZWdpc3RyeSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBjbGVhclJlbmRlckNvdW50ZXJSZWdpc3RyeSgpIHtcbiAgZm9yIChjb25zdCBjb3VudGVycyBvZiByZW5kZXJDb3VudGVyUmVnaXN0cnkudmFsdWVzKCkpIHtcbiAgICBjb3VudGVycy5mb3JFYWNoKChjb3VudGVyKSA9PiB7XG4gICAgICBjb3VudGVyLmNvdW50ID0gMDtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJSZW5kZXJDb3VudGVyKG5hbWUsIHZhbCkge1xuICBsZXQgY291bnRlcnMgPSByZW5kZXJDb3VudGVyUmVnaXN0cnkuZ2V0KG5hbWUpO1xuICBpZiAoY291bnRlcnMgPT0gbnVsbCkge1xuICAgIGNvdW50ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICByZW5kZXJDb3VudGVyUmVnaXN0cnkuc2V0KG5hbWUsIGNvdW50ZXJzKTtcbiAgfVxuICBjb3VudGVycy5hZGQodmFsKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVJlbmRlckNvdW50ZXIobmFtZSwgdmFsKSB7XG4gIGNvbnN0IGNvdW50ZXJzID0gcmVuZGVyQ291bnRlclJlZ2lzdHJ5LmdldChuYW1lKTtcbiAgaWYgKGNvdW50ZXJzID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY291bnRlcnMuZGVsZXRlKHZhbCk7XG59XG5mdW5jdGlvbiB1c2VSZW5kZXJDb3VudGVyKG5hbWUpIHtcbiAgY29uc3QgdmFsID0gdXNlUmVmKG51bGwpO1xuICBpZiAodmFsLmN1cnJlbnQgIT0gbnVsbCkge1xuICAgIHZhbC5jdXJyZW50LmNvdW50ICs9IDE7XG4gIH1cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodmFsLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgY29uc3QgY291bnRlciA9IHsgY291bnQ6IDAgfTtcbiAgICAgIHJlZ2lzdGVyUmVuZGVyQ291bnRlcihuYW1lLCBjb3VudGVyKTtcbiAgICAgIHZhbC5jdXJyZW50ID0gY291bnRlcjtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICh2YWwuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICByZW1vdmVSZW5kZXJDb3VudGVyKG5hbWUsIHZhbC5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cbnZhciBzZWVuRXJyb3JzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbmZ1bmN0aW9uICRzdHJ1Y3R1cmFsQ2hlY2sob2xkVmFsdWUsIG5ld1ZhbHVlLCB2YXJpYWJsZU5hbWUsIGZuTmFtZSwga2luZCwgbG9jKSB7XG4gIGZ1bmN0aW9uIGVycm9yKGwsIHIsIHBhdGgsIGRlcHRoKSB7XG4gICAgY29uc3Qgc3RyID0gYCR7Zm5OYW1lfToke2xvY30gWyR7a2luZH1dICR7dmFyaWFibGVOYW1lfSR7cGF0aH0gY2hhbmdlZCBmcm9tICR7bH0gdG8gJHtyfSBhdCBkZXB0aCAke2RlcHRofWA7XG4gICAgaWYgKHNlZW5FcnJvcnMuaGFzKHN0cikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VlbkVycm9ycy5hZGQoc3RyKTtcbiAgICBjb25zb2xlLmVycm9yKHN0cik7XG4gIH1cbiAgY29uc3QgZGVwdGhMaW1pdCA9IDI7XG4gIGZ1bmN0aW9uIHJlY3VyKG9sZFZhbHVlMiwgbmV3VmFsdWUyLCBwYXRoLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA+IGRlcHRoTGltaXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKG9sZFZhbHVlMiA9PT0gbmV3VmFsdWUyKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2xkVmFsdWUyICE9PSB0eXBlb2YgbmV3VmFsdWUyKSB7XG4gICAgICBlcnJvcihgdHlwZSAke3R5cGVvZiBvbGRWYWx1ZTJ9YCwgYHR5cGUgJHt0eXBlb2YgbmV3VmFsdWUyfWAsIHBhdGgsIGRlcHRoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvbGRWYWx1ZTIgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IG9sZEFycmF5ID0gQXJyYXkuaXNBcnJheShvbGRWYWx1ZTIpO1xuICAgICAgY29uc3QgbmV3QXJyYXkgPSBBcnJheS5pc0FycmF5KG5ld1ZhbHVlMik7XG4gICAgICBpZiAob2xkVmFsdWUyID09PSBudWxsICYmIG5ld1ZhbHVlMiAhPT0gbnVsbCkge1xuICAgICAgICBlcnJvcihcIm51bGxcIiwgYHR5cGUgJHt0eXBlb2YgbmV3VmFsdWUyfWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgIH0gZWxzZSBpZiAobmV3VmFsdWUyID09PSBudWxsKSB7XG4gICAgICAgIGVycm9yKGB0eXBlICR7dHlwZW9mIG9sZFZhbHVlMn1gLCBcIm51bGxcIiwgcGF0aCwgZGVwdGgpO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZTIgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgaWYgKCEobmV3VmFsdWUyIGluc3RhbmNlb2YgTWFwKSkge1xuICAgICAgICAgIGVycm9yKGBNYXAgaW5zdGFuY2VgLCBgb3RoZXIgdmFsdWVgLCBwYXRoLCBkZXB0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUyLnNpemUgIT09IG5ld1ZhbHVlMi5zaXplKSB7XG4gICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICBgTWFwIGluc3RhbmNlIHdpdGggc2l6ZSAke29sZFZhbHVlMi5zaXplfWAsXG4gICAgICAgICAgICBgTWFwIGluc3RhbmNlIHdpdGggc2l6ZSAke25ld1ZhbHVlMi5zaXplfWAsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgZGVwdGhcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIG9sZFZhbHVlMikge1xuICAgICAgICAgICAgaWYgKCFuZXdWYWx1ZTIuaGFzKGspKSB7XG4gICAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICAgIGBNYXAgaW5zdGFuY2Ugd2l0aCBrZXkgJHtrfWAsXG4gICAgICAgICAgICAgICAgYE1hcCBpbnN0YW5jZSB3aXRob3V0IGtleSAke2t9YCxcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIGRlcHRoXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWN1cih2LCBuZXdWYWx1ZTIuZ2V0KGspLCBgJHtwYXRofS5nZXQoJHtrfSlgLCBkZXB0aCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChuZXdWYWx1ZTIgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgZXJyb3IoXCJvdGhlciB2YWx1ZVwiLCBgTWFwIGluc3RhbmNlYCwgcGF0aCwgZGVwdGgpO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZTIgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgaWYgKCEobmV3VmFsdWUyIGluc3RhbmNlb2YgU2V0KSkge1xuICAgICAgICAgIGVycm9yKGBTZXQgaW5zdGFuY2VgLCBgb3RoZXIgdmFsdWVgLCBwYXRoLCBkZXB0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUyLnNpemUgIT09IG5ld1ZhbHVlMi5zaXplKSB7XG4gICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICBgU2V0IGluc3RhbmNlIHdpdGggc2l6ZSAke29sZFZhbHVlMi5zaXplfWAsXG4gICAgICAgICAgICBgU2V0IGluc3RhbmNlIHdpdGggc2l6ZSAke25ld1ZhbHVlMi5zaXplfWAsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgZGVwdGhcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBuZXdWYWx1ZTIpIHtcbiAgICAgICAgICAgIGlmICghb2xkVmFsdWUyLmhhcyh2KSkge1xuICAgICAgICAgICAgICBlcnJvcihcbiAgICAgICAgICAgICAgICBgU2V0IGluc3RhbmNlIHdpdGhvdXQgZWxlbWVudCAke3Z9YCxcbiAgICAgICAgICAgICAgICBgU2V0IGluc3RhbmNlIHdpdGggZWxlbWVudCAke3Z9YCxcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIGRlcHRoXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5ld1ZhbHVlMiBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBlcnJvcihcIm90aGVyIHZhbHVlXCIsIGBTZXQgaW5zdGFuY2VgLCBwYXRoLCBkZXB0aCk7XG4gICAgICB9IGVsc2UgaWYgKG9sZEFycmF5IHx8IG5ld0FycmF5KSB7XG4gICAgICAgIGlmIChvbGRBcnJheSAhPT0gbmV3QXJyYXkpIHtcbiAgICAgICAgICBlcnJvcihcbiAgICAgICAgICAgIGB0eXBlICR7b2xkQXJyYXkgPyBcImFycmF5XCIgOiBcIm9iamVjdFwifWAsXG4gICAgICAgICAgICBgdHlwZSAke25ld0FycmF5ID8gXCJhcnJheVwiIDogXCJvYmplY3RcIn1gLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIGRlcHRoXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZTIubGVuZ3RoICE9PSBuZXdWYWx1ZTIubGVuZ3RoKSB7XG4gICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICBgYXJyYXkgd2l0aCBsZW5ndGggJHtvbGRWYWx1ZTIubGVuZ3RofWAsXG4gICAgICAgICAgICBgYXJyYXkgd2l0aCBsZW5ndGggJHtuZXdWYWx1ZTIubGVuZ3RofWAsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgZGVwdGhcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBvbGRWYWx1ZTIubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICByZWN1cihvbGRWYWx1ZTJbaWldLCBuZXdWYWx1ZTJbaWldLCBgJHtwYXRofVske2lpfV1gLCBkZXB0aCArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChvbGRWYWx1ZTIpIHx8IGlzVmFsaWRFbGVtZW50KG5ld1ZhbHVlMikpIHtcbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KG9sZFZhbHVlMikgIT09IGlzVmFsaWRFbGVtZW50KG5ld1ZhbHVlMikpIHtcbiAgICAgICAgICBlcnJvcihcbiAgICAgICAgICAgIGB0eXBlICR7aXNWYWxpZEVsZW1lbnQob2xkVmFsdWUyKSA/IFwiUmVhY3QgZWxlbWVudFwiIDogXCJvYmplY3RcIn1gLFxuICAgICAgICAgICAgYHR5cGUgJHtpc1ZhbGlkRWxlbWVudChuZXdWYWx1ZTIpID8gXCJSZWFjdCBlbGVtZW50XCIgOiBcIm9iamVjdFwifWAsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgZGVwdGhcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlMi50eXBlICE9PSBuZXdWYWx1ZTIudHlwZSkge1xuICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgYFJlYWN0IGVsZW1lbnQgb2YgdHlwZSAke29sZFZhbHVlMi50eXBlfWAsXG4gICAgICAgICAgICBgUmVhY3QgZWxlbWVudCBvZiB0eXBlICR7bmV3VmFsdWUyLnR5cGV9YCxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBkZXB0aFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjdXIoXG4gICAgICAgICAgICBvbGRWYWx1ZTIucHJvcHMsXG4gICAgICAgICAgICBuZXdWYWx1ZTIucHJvcHMsXG4gICAgICAgICAgICBgW3Byb3BzIG9mICR7cGF0aH1dYCxcbiAgICAgICAgICAgIGRlcHRoICsgMVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5ld1ZhbHVlMikge1xuICAgICAgICAgIGlmICghKGtleSBpbiBvbGRWYWx1ZTIpKSB7XG4gICAgICAgICAgICBlcnJvcihcbiAgICAgICAgICAgICAgYG9iamVjdCB3aXRob3V0IGtleSAke2tleX1gLFxuICAgICAgICAgICAgICBgb2JqZWN0IHdpdGgga2V5ICR7a2V5fWAsXG4gICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgIGRlcHRoXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRWYWx1ZTIpIHtcbiAgICAgICAgICBpZiAoIShrZXkgaW4gbmV3VmFsdWUyKSkge1xuICAgICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAgIGBvYmplY3Qgd2l0aCBrZXkgJHtrZXl9YCxcbiAgICAgICAgICAgICAgYG9iamVjdCB3aXRob3V0IGtleSAke2tleX1gLFxuICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICBkZXB0aFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVjdXIob2xkVmFsdWUyW2tleV0sIG5ld1ZhbHVlMltrZXldLCBgJHtwYXRofS4ke2tleX1gLCBkZXB0aCArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9sZFZhbHVlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChpc05hTihvbGRWYWx1ZTIpIHx8IGlzTmFOKG5ld1ZhbHVlMikpIHtcbiAgICAgIGlmIChpc05hTihvbGRWYWx1ZTIpICE9PSBpc05hTihuZXdWYWx1ZTIpKSB7XG4gICAgICAgIGVycm9yKFxuICAgICAgICAgIGAke2lzTmFOKG9sZFZhbHVlMikgPyBcIk5hTlwiIDogXCJub24tTmFOIHZhbHVlXCJ9YCxcbiAgICAgICAgICBgJHtpc05hTihuZXdWYWx1ZTIpID8gXCJOYU5cIiA6IFwibm9uLU5hTiB2YWx1ZVwifWAsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBkZXB0aFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVmFsdWUyICE9PSBuZXdWYWx1ZTIpIHtcbiAgICAgIGVycm9yKG9sZFZhbHVlMiwgbmV3VmFsdWUyLCBwYXRoLCBkZXB0aCk7XG4gICAgfVxuICB9XG4gIHJlY3VyKG9sZFZhbHVlLCBuZXdWYWx1ZSwgXCJcIiwgMCk7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJGRpc3BhdGNoZXJHdWFyZCxcbiAgJG1ha2VSZWFkT25seSxcbiAgJHJlc2V0LFxuICAkc3RydWN0dXJhbENoZWNrLFxuICBjLFxuICBjbGVhclJlbmRlckNvdW50ZXJSZWdpc3RyeSxcbiAgcmVuZGVyQ291bnRlclJlZ2lzdHJ5LFxuICB1c2VSZW5kZXJDb3VudGVyXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-compiler-runtime/dist/index.js\n");

/***/ })

};
;