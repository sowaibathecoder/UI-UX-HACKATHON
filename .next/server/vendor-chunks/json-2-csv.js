"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/json-2-csv";
exports.ids = ["vendor-chunks/json-2-csv"];
exports.modules = {

/***/ "(ssr)/./node_modules/json-2-csv/lib/constants.js":
/*!**************************************************!*\
  !*** ./node_modules/json-2-csv/lib/constants.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.excelBOM = exports.defaultCsv2JsonOptions = exports.defaultJson2CsvOptions = exports.errors = void 0;\nexports.errors = {\n    optionsRequired: 'Options were not passed and are required.',\n    json2csv: {\n        cannotCallOn: 'Cannot call json2csv on',\n        dataCheckFailure: 'Data provided was not an array of documents.',\n        notSameSchema: 'Not all documents have the same schema.'\n    },\n    csv2json: {\n        cannotCallOn: 'Cannot call csv2json on',\n        dataCheckFailure: 'CSV is not a string.'\n    }\n};\nexports.defaultJson2CsvOptions = {\n    arrayIndexesAsKeys: false,\n    checkSchemaDifferences: false,\n    delimiter: {\n        field: ',',\n        wrap: '\"',\n        eol: '\\n'\n    },\n    emptyFieldValue: undefined,\n    escapeHeaderNestedDots: true,\n    excelBOM: false,\n    excludeKeys: [],\n    expandNestedObjects: true,\n    expandArrayObjects: false,\n    prependHeader: true,\n    preventCsvInjection: false,\n    sortHeader: false,\n    trimFieldValues: false,\n    trimHeaderFields: false,\n    unwindArrays: false,\n    useDateIso8601Format: false,\n    useLocaleFormat: false,\n    wrapBooleans: false,\n};\nexports.defaultCsv2JsonOptions = {\n    delimiter: {\n        field: ',',\n        wrap: '\"',\n        eol: '\\n'\n    },\n    excelBOM: false,\n    preventCsvInjection: false,\n    trimFieldValues: false,\n    trimHeaderFields: false,\n};\nexports.excelBOM = '\\ufeff';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLDhCQUE4QixHQUFHLDhCQUE4QixHQUFHLGNBQWM7QUFDbkcsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsiRDpcXFNPV05fR0lBSUNcXE5FWFQtV09SS1xcSEFDS0FUSE9OLTNcXFVJLVVYLUhBQ0tBVEhPTi1OZXh0SlMtRGVzaWduLUphbS0yMDI0LShNWS1DTE9ORS1QUk9KRUNUKVxcbm9kZV9tb2R1bGVzXFxqc29uLTItY3N2XFxsaWJcXGNvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4Y2VsQk9NID0gZXhwb3J0cy5kZWZhdWx0Q3N2Mkpzb25PcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0SnNvbjJDc3ZPcHRpb25zID0gZXhwb3J0cy5lcnJvcnMgPSB2b2lkIDA7XG5leHBvcnRzLmVycm9ycyA9IHtcbiAgICBvcHRpb25zUmVxdWlyZWQ6ICdPcHRpb25zIHdlcmUgbm90IHBhc3NlZCBhbmQgYXJlIHJlcXVpcmVkLicsXG4gICAganNvbjJjc3Y6IHtcbiAgICAgICAgY2Fubm90Q2FsbE9uOiAnQ2Fubm90IGNhbGwganNvbjJjc3Ygb24nLFxuICAgICAgICBkYXRhQ2hlY2tGYWlsdXJlOiAnRGF0YSBwcm92aWRlZCB3YXMgbm90IGFuIGFycmF5IG9mIGRvY3VtZW50cy4nLFxuICAgICAgICBub3RTYW1lU2NoZW1hOiAnTm90IGFsbCBkb2N1bWVudHMgaGF2ZSB0aGUgc2FtZSBzY2hlbWEuJ1xuICAgIH0sXG4gICAgY3N2Mmpzb246IHtcbiAgICAgICAgY2Fubm90Q2FsbE9uOiAnQ2Fubm90IGNhbGwgY3N2Mmpzb24gb24nLFxuICAgICAgICBkYXRhQ2hlY2tGYWlsdXJlOiAnQ1NWIGlzIG5vdCBhIHN0cmluZy4nXG4gICAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdEpzb24yQ3N2T3B0aW9ucyA9IHtcbiAgICBhcnJheUluZGV4ZXNBc0tleXM6IGZhbHNlLFxuICAgIGNoZWNrU2NoZW1hRGlmZmVyZW5jZXM6IGZhbHNlLFxuICAgIGRlbGltaXRlcjoge1xuICAgICAgICBmaWVsZDogJywnLFxuICAgICAgICB3cmFwOiAnXCInLFxuICAgICAgICBlb2w6ICdcXG4nXG4gICAgfSxcbiAgICBlbXB0eUZpZWxkVmFsdWU6IHVuZGVmaW5lZCxcbiAgICBlc2NhcGVIZWFkZXJOZXN0ZWREb3RzOiB0cnVlLFxuICAgIGV4Y2VsQk9NOiBmYWxzZSxcbiAgICBleGNsdWRlS2V5czogW10sXG4gICAgZXhwYW5kTmVzdGVkT2JqZWN0czogdHJ1ZSxcbiAgICBleHBhbmRBcnJheU9iamVjdHM6IGZhbHNlLFxuICAgIHByZXBlbmRIZWFkZXI6IHRydWUsXG4gICAgcHJldmVudENzdkluamVjdGlvbjogZmFsc2UsXG4gICAgc29ydEhlYWRlcjogZmFsc2UsXG4gICAgdHJpbUZpZWxkVmFsdWVzOiBmYWxzZSxcbiAgICB0cmltSGVhZGVyRmllbGRzOiBmYWxzZSxcbiAgICB1bndpbmRBcnJheXM6IGZhbHNlLFxuICAgIHVzZURhdGVJc284NjAxRm9ybWF0OiBmYWxzZSxcbiAgICB1c2VMb2NhbGVGb3JtYXQ6IGZhbHNlLFxuICAgIHdyYXBCb29sZWFuczogZmFsc2UsXG59O1xuZXhwb3J0cy5kZWZhdWx0Q3N2Mkpzb25PcHRpb25zID0ge1xuICAgIGRlbGltaXRlcjoge1xuICAgICAgICBmaWVsZDogJywnLFxuICAgICAgICB3cmFwOiAnXCInLFxuICAgICAgICBlb2w6ICdcXG4nXG4gICAgfSxcbiAgICBleGNlbEJPTTogZmFsc2UsXG4gICAgcHJldmVudENzdkluamVjdGlvbjogZmFsc2UsXG4gICAgdHJpbUZpZWxkVmFsdWVzOiBmYWxzZSxcbiAgICB0cmltSGVhZGVyRmllbGRzOiBmYWxzZSxcbn07XG5leHBvcnRzLmV4Y2VsQk9NID0gJ1xcdWZlZmYnO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/json-2-csv/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/json-2-csv/lib/converter.js":
/*!**************************************************!*\
  !*** ./node_modules/json-2-csv/lib/converter.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.csv2json = exports.json2csv = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/json-2-csv/lib/constants.js\");\nconst json2csv_1 = __webpack_require__(/*! ./json2csv */ \"(ssr)/./node_modules/json-2-csv/lib/json2csv.js\");\nconst csv2json_1 = __webpack_require__(/*! ./csv2json */ \"(ssr)/./node_modules/json-2-csv/lib/csv2json.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/json-2-csv/lib/utils.js\");\nfunction json2csv(data, options) {\n    const builtOptions = (0, utils_1.buildJ2COptions)(options ?? {});\n    // Validate the parameters before calling the converter's convert function\n    (0, utils_1.validate)(data, utils_1.isObject, constants_1.errors.json2csv);\n    return (0, json2csv_1.Json2Csv)(builtOptions).convert(data);\n}\nexports.json2csv = json2csv;\nfunction csv2json(data, options) {\n    const builtOptions = (0, utils_1.buildC2JOptions)(options ?? {});\n    // Validate the parameters before calling the converter's convert function\n    (0, utils_1.validate)(data, utils_1.isString, constants_1.errors.csv2json);\n    return (0, csv2json_1.Csv2Json)(builtOptions).convert(data);\n}\nexports.csv2json = csv2json;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvY29udmVydGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLGdCQUFnQjtBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyxxRUFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyxtRUFBWTtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyxtRUFBWTtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyw2REFBUztBQUNqQztBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsiRDpcXFNPV05fR0lBSUNcXE5FWFQtV09SS1xcSEFDS0FUSE9OLTNcXFVJLVVYLUhBQ0tBVEhPTi1OZXh0SlMtRGVzaWduLUphbS0yMDI0LShNWS1DTE9ORS1QUk9KRUNUKVxcbm9kZV9tb2R1bGVzXFxqc29uLTItY3N2XFxsaWJcXGNvbnZlcnRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNzdjJqc29uID0gZXhwb3J0cy5qc29uMmNzdiA9IHZvaWQgMDtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QganNvbjJjc3ZfMSA9IHJlcXVpcmUoXCIuL2pzb24yY3N2XCIpO1xuY29uc3QgY3N2Mmpzb25fMSA9IHJlcXVpcmUoXCIuL2NzdjJqc29uXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZnVuY3Rpb24ganNvbjJjc3YoZGF0YSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJ1aWx0T3B0aW9ucyA9ICgwLCB1dGlsc18xLmJ1aWxkSjJDT3B0aW9ucykob3B0aW9ucyA/PyB7fSk7XG4gICAgLy8gVmFsaWRhdGUgdGhlIHBhcmFtZXRlcnMgYmVmb3JlIGNhbGxpbmcgdGhlIGNvbnZlcnRlcidzIGNvbnZlcnQgZnVuY3Rpb25cbiAgICAoMCwgdXRpbHNfMS52YWxpZGF0ZSkoZGF0YSwgdXRpbHNfMS5pc09iamVjdCwgY29uc3RhbnRzXzEuZXJyb3JzLmpzb24yY3N2KTtcbiAgICByZXR1cm4gKDAsIGpzb24yY3N2XzEuSnNvbjJDc3YpKGJ1aWx0T3B0aW9ucykuY29udmVydChkYXRhKTtcbn1cbmV4cG9ydHMuanNvbjJjc3YgPSBqc29uMmNzdjtcbmZ1bmN0aW9uIGNzdjJqc29uKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBidWlsdE9wdGlvbnMgPSAoMCwgdXRpbHNfMS5idWlsZEMySk9wdGlvbnMpKG9wdGlvbnMgPz8ge30pO1xuICAgIC8vIFZhbGlkYXRlIHRoZSBwYXJhbWV0ZXJzIGJlZm9yZSBjYWxsaW5nIHRoZSBjb252ZXJ0ZXIncyBjb252ZXJ0IGZ1bmN0aW9uXG4gICAgKDAsIHV0aWxzXzEudmFsaWRhdGUpKGRhdGEsIHV0aWxzXzEuaXNTdHJpbmcsIGNvbnN0YW50c18xLmVycm9ycy5jc3YyanNvbik7XG4gICAgcmV0dXJuICgwLCBjc3YyanNvbl8xLkNzdjJKc29uKShidWlsdE9wdGlvbnMpLmNvbnZlcnQoZGF0YSk7XG59XG5leHBvcnRzLmNzdjJqc29uID0gY3N2Mmpzb247XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/json-2-csv/lib/converter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/json-2-csv/lib/csv2json.js":
/*!*************************************************!*\
  !*** ./node_modules/json-2-csv/lib/csv2json.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Csv2Json = void 0;\nconst doc_path_1 = __webpack_require__(/*! doc-path */ \"(ssr)/./node_modules/doc-path/lib/path.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/json-2-csv/lib/constants.js\");\nconst utils = __importStar(__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/json-2-csv/lib/utils.js\"));\nconst Csv2Json = function (options) {\n    const escapedWrapDelimiterRegex = new RegExp(options.delimiter.wrap + options.delimiter.wrap, 'g'), excelBOMRegex = new RegExp('^' + constants_1.excelBOM), valueParserFn = options.parseValue && typeof options.parseValue === 'function' ? options.parseValue : JSON.parse;\n    /**\n     * Trims the header key, if specified by the user via the provided options\n     */\n    function processHeaderKey(headerKey) {\n        headerKey = removeWrapDelimitersFromValue(headerKey);\n        if (options.trimHeaderFields) {\n            return headerKey.split('.')\n                .map((component) => component.trim())\n                .join('.');\n        }\n        return headerKey;\n    }\n    /**\n     * Generate the JSON heading from the CSV\n     */\n    function retrieveHeading(lines) {\n        let headerFields = [];\n        if (options.headerFields) {\n            headerFields = options.headerFields.map((headerField, index) => ({\n                value: processHeaderKey(headerField),\n                index\n            }));\n        }\n        else {\n            // Generate and return the heading keys\n            const headerRow = lines[0];\n            headerFields = headerRow.map((headerKey, index) => ({\n                value: processHeaderKey(headerKey),\n                index\n            }));\n            // If the user provided keys, filter the generated keys to just the user provided keys so we also have the key index\n            if (options.keys) {\n                const keys = options.keys; // TypeScript type checking work around to get it to recognize the option is not undefined\n                headerFields = headerFields.filter((headerKey) => keys.includes(headerKey.value));\n            }\n        }\n        return {\n            lines,\n            headerFields,\n            recordLines: [],\n        };\n    }\n    /**\n     * Removes the Excel BOM value, if specified by the options object\n     */\n    function stripExcelBOM(csv) {\n        if (options.excelBOM) {\n            return csv.replace(excelBOMRegex, '');\n        }\n        return csv;\n    }\n    /**\n     * Helper function that splits a line so that we can handle wrapped fields\n     */\n    function splitLines(csv) {\n        // Parse out the line...\n        const lines = [], lastCharacterIndex = csv.length - 1, eolDelimiterLength = options.delimiter.eol.length, stateVariables = {\n            insideWrapDelimiter: false,\n            parsingValue: true,\n            justParsedDoubleQuote: false,\n            startIndex: 0\n        };\n        let splitLine = [], character, charBefore, charAfter, nextNChar, index = 0;\n        // Loop through each character in the line to identify where to split the values\n        while (index < csv.length) {\n            // Current character\n            character = csv[index];\n            // Previous character\n            charBefore = index ? csv[index - 1] : '';\n            // Next character\n            charAfter = index < lastCharacterIndex ? csv[index + 1] : '';\n            // Next n characters, including the current character, where n = length(EOL delimiter)\n            // This allows for the checking of an EOL delimiter when if it is more than a single character (eg. '\\r\\n')\n            nextNChar = utils.getNCharacters(csv, index, eolDelimiterLength);\n            if ((nextNChar === options.delimiter.eol && !stateVariables.insideWrapDelimiter ||\n                index === lastCharacterIndex) && charBefore === options.delimiter.field) {\n                // If we reached an EOL delimiter or the end of the csv and the previous character is a field delimiter...\n                // If the start index is the current index (and since the previous character is a comma),\n                //   then the value being parsed is an empty value accordingly, add an empty string\n                if (nextNChar === options.delimiter.eol && stateVariables.startIndex === index) {\n                    splitLine.push('');\n                }\n                else if (character === options.delimiter.field) {\n                    // If we reached the end of the CSV, there's no new line, and the current character is a comma\n                    // then add an empty string for the current value\n                    splitLine.push('');\n                }\n                else {\n                    // Otherwise, there's a valid value, and the start index isn't the current index, grab the whole value\n                    splitLine.push(csv.substring(stateVariables.startIndex));\n                }\n                // Since the last character is a comma, there's still an additional implied field value trailing the comma.\n                //   Since this value is empty, we push an extra empty value\n                splitLine.push('');\n                // Finally, push the split line values into the lines array and clear the split line\n                lines.push(splitLine);\n                splitLine = [];\n                stateVariables.startIndex = index + eolDelimiterLength;\n                stateVariables.parsingValue = true;\n                stateVariables.insideWrapDelimiter = charAfter === options.delimiter.wrap;\n            }\n            else if (index === lastCharacterIndex && character === options.delimiter.field) {\n                // If we reach the end of the CSV and the current character is a field delimiter\n                // Parse the previously seen value and add it to the line\n                const parsedValue = csv.substring(stateVariables.startIndex, index);\n                splitLine.push(parsedValue);\n                // Then add an empty string to the line since the last character being a field delimiter indicates an empty field\n                splitLine.push('');\n                lines.push(splitLine);\n            }\n            else if (index === lastCharacterIndex || nextNChar === options.delimiter.eol &&\n                // if we aren't inside wrap delimiters or if we are but the character before was a wrap delimiter and we didn't just see two\n                (!stateVariables.insideWrapDelimiter ||\n                    stateVariables.insideWrapDelimiter && charBefore === options.delimiter.wrap && !stateVariables.justParsedDoubleQuote)) {\n                // Otherwise if we reached the end of the line or csv (and current character is not a field delimiter)\n                const toIndex = index !== lastCharacterIndex || charBefore === options.delimiter.wrap ? index : undefined;\n                // Retrieve the remaining value and add it to the split line list of values\n                splitLine.push(csv.substring(stateVariables.startIndex, toIndex));\n                // Finally, push the split line values into the lines array and clear the split line\n                lines.push(splitLine);\n                splitLine = [];\n                stateVariables.startIndex = index + eolDelimiterLength;\n                stateVariables.parsingValue = true;\n                stateVariables.insideWrapDelimiter = charAfter === options.delimiter.wrap;\n            }\n            else if (character === options.delimiter.wrap && charBefore === options.delimiter.field &&\n                !stateVariables.insideWrapDelimiter && !stateVariables.parsingValue) {\n                // If we reached a wrap delimiter after a comma and we aren't inside a wrap delimiter\n                stateVariables.startIndex = index;\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.parsingValue = true;\n                // If the next character(s) are an EOL delimiter, then skip them so we don't parse what we've seen as another value\n                if (utils.getNCharacters(csv, index + 1, eolDelimiterLength) === options.delimiter.eol) {\n                    index += options.delimiter.eol.length + 1; // Skip past EOL\n                }\n            }\n            else if (charBefore === options.delimiter.field && character === options.delimiter.wrap && charAfter === options.delimiter.eol) {\n                // We reached the start of a wrapped new field that begins with an EOL delimiter\n                // Retrieve the remaining value and add it to the split line list of values\n                splitLine.push(csv.substring(stateVariables.startIndex, index - 1));\n                stateVariables.startIndex = index;\n                stateVariables.parsingValue = true;\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.justParsedDoubleQuote = true;\n                index += 1;\n            }\n            else if ((charBefore !== options.delimiter.wrap || stateVariables.justParsedDoubleQuote && charBefore === options.delimiter.wrap) &&\n                character === options.delimiter.wrap && utils.getNCharacters(csv, index + 1, eolDelimiterLength) === options.delimiter.eol) {\n                // If we reach a wrap which is not preceded by a wrap delim and the next character is an EOL delim (ie. *\"\\n)\n                stateVariables.insideWrapDelimiter = false;\n                stateVariables.parsingValue = false;\n                // Next iteration will substring, add the value to the line, and push the line onto the array of lines\n            }\n            else if (character === options.delimiter.wrap && (index === 0 || utils.getNCharacters(csv, index - eolDelimiterLength, eolDelimiterLength) === options.delimiter.eol && !stateVariables.insideWrapDelimiter)) {\n                // If the line starts with a wrap delimiter (ie. \"*)\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.parsingValue = true;\n                stateVariables.startIndex = index;\n            }\n            else if (character === options.delimiter.wrap && charAfter === options.delimiter.field && stateVariables.insideWrapDelimiter) {\n                // If we reached a wrap delimiter with a field delimiter after it (ie. *\",)\n                splitLine.push(csv.substring(stateVariables.startIndex, index + 1));\n                stateVariables.startIndex = index + 2; // next value starts after the field delimiter\n                stateVariables.insideWrapDelimiter = false;\n                stateVariables.parsingValue = false;\n            }\n            else if (character === options.delimiter.wrap && charBefore === options.delimiter.field &&\n                !stateVariables.insideWrapDelimiter && stateVariables.parsingValue) {\n                // If we reached a wrap delimiter with a field delimiter after it (ie. ,\"*)\n                splitLine.push(csv.substring(stateVariables.startIndex, index - 1));\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.parsingValue = true;\n                stateVariables.startIndex = index;\n            }\n            else if (character === options.delimiter.wrap && charAfter === options.delimiter.wrap && index !== stateVariables.startIndex) {\n                // If we run into an escaped quote (ie. \"\") skip past the second quote\n                index += 2;\n                stateVariables.justParsedDoubleQuote = true;\n                continue;\n            }\n            else if (character === options.delimiter.field && charBefore !== options.delimiter.wrap &&\n                charAfter !== options.delimiter.wrap && !stateVariables.insideWrapDelimiter &&\n                stateVariables.parsingValue) {\n                // If we reached a field delimiter and are not inside the wrap delimiters (ie. *,*)\n                splitLine.push(csv.substring(stateVariables.startIndex, index));\n                stateVariables.startIndex = index + 1;\n            }\n            else if (character === options.delimiter.field && charBefore === options.delimiter.wrap &&\n                charAfter !== options.delimiter.wrap && !stateVariables.parsingValue) {\n                // If we reached a field delimiter, the previous character was a wrap delimiter, and the\n                //   next character is not a wrap delimiter (ie. \",*)\n                stateVariables.insideWrapDelimiter = false;\n                stateVariables.parsingValue = true;\n                stateVariables.startIndex = index + 1;\n            }\n            // Otherwise increment to the next character\n            index++;\n            // Reset the double quote state variable\n            stateVariables.justParsedDoubleQuote = false;\n        }\n        return lines;\n    }\n    /**\n     * Retrieves the record lines from the split CSV lines and sets it on the params object\n     */\n    function retrieveRecordLines(params) {\n        if (options.headerFields) { // This option is passed for instances where the CSV has no header line\n            params.recordLines = params.lines;\n        }\n        else { // All lines except for the header line\n            params.recordLines = params.lines.splice(1);\n        }\n        return params;\n    }\n    /**\n     * Retrieves the value for the record from the line at the provided key.\n     */\n    function retrieveRecordValueFromLine(headerField, line) {\n        // If there is a value at the key's index, use it; otherwise, null\n        const value = line[headerField.index];\n        // Perform any necessary value conversions on the record value\n        return processRecordValue(value);\n    }\n    /**\n     * Processes the record's value by parsing the data to ensure the CSV is\n     * converted to the JSON that created it.\n     */\n    function processRecordValue(fieldValue) {\n        // If the value is an array representation, convert it\n        const parsedJson = parseValue(fieldValue);\n        // If parsedJson is anything aside from an error, then we want to use the parsed value\n        // This allows us to interpret values like 'null' --> null, 'false' --> false\n        if (!utils.isError(parsedJson) && !utils.isInvalid(parsedJson)) {\n            return parsedJson;\n        }\n        else if (fieldValue === 'undefined') {\n            return undefined;\n        }\n        return fieldValue;\n    }\n    /**\n     * Trims the record value, if specified by the user via the options object\n     */\n    function trimRecordValue(fieldValue) {\n        if (options.trimFieldValues && fieldValue !== null) {\n            return fieldValue.trim();\n        }\n        return fieldValue;\n    }\n    /**\n     * Create a JSON document with the given keys (designated by the CSV header)\n     *   and the values (from the given line)\n     * @returns {Object} created json document\n     */\n    function createDocument(headerFields, line) {\n        // Reduce the keys into a JSON document representing the given line\n        return headerFields.reduce((document, headerField) => {\n            // If there is a value at the key's index in the line, set the value; otherwise null\n            const value = retrieveRecordValueFromLine(headerField, line);\n            try {\n                // Otherwise add the key and value to the document\n                return (0, doc_path_1.setPath)(document, headerField.value, value);\n            }\n            catch (error) {\n                // Catch any errors where key paths are null or '' and continue\n                return document;\n            }\n        }, {});\n    }\n    /**\n     * Removes the outermost wrap delimiters from a value, if they are present\n     * Otherwise, the non-wrapped value is returned as is\n     */\n    function removeWrapDelimitersFromValue(fieldValue) {\n        const firstChar = fieldValue[0], lastIndex = fieldValue.length - 1, lastChar = fieldValue[lastIndex];\n        // If the field starts and ends with a wrap delimiter\n        if (firstChar === options.delimiter.wrap && lastChar === options.delimiter.wrap) {\n            // Handle the case where the field is just a pair of wrap delimiters \n            return fieldValue.length <= 2 ? '' : fieldValue.substring(1, lastIndex);\n        }\n        return fieldValue;\n    }\n    /**\n     * Unescapes wrap delimiters by replacing duplicates with a single (eg. \"\" -> \")\n     * This is done in order to parse RFC 4180 compliant CSV back to JSON\n     */\n    function unescapeWrapDelimiterInField(fieldValue) {\n        return fieldValue.replace(escapedWrapDelimiterRegex, options.delimiter.wrap);\n    }\n    /**\n     * Main helper function to convert the CSV to the JSON document array\n     */\n    function transformRecordLines(params) {\n        // For each line, create the document and add it to the array of documents\n        return params.recordLines.reduce((generatedJsonObjects, line) => {\n            line = line.map((fieldValue) => {\n                // Perform the necessary operations on each line\n                fieldValue = removeWrapDelimitersFromValue(fieldValue);\n                fieldValue = unescapeWrapDelimiterInField(fieldValue);\n                fieldValue = trimRecordValue(fieldValue);\n                return fieldValue;\n            });\n            const generatedDocument = createDocument(params.headerFields, line);\n            return generatedJsonObjects.concat(generatedDocument);\n        }, []);\n    }\n    /**\n     * Attempts to parse the provided value. If it is not parsable, then an error is returned\n     */\n    function parseValue(value) {\n        try {\n            if (utils.isStringRepresentation(value, options) && !utils.isDateRepresentation(value)) {\n                return value;\n            }\n            const parsedJson = valueParserFn(value);\n            // If the parsed value is an array, then we also need to trim record values, if specified\n            if (Array.isArray(parsedJson)) {\n                return parsedJson.map(trimRecordValue);\n            }\n            return parsedJson;\n        }\n        catch (err) {\n            return err;\n        }\n    }\n    /**\n     * Internally exported csv2json function\n     */\n    function convert(data) {\n        // Split the CSV into lines using the specified EOL option\n        const stripped = stripExcelBOM(data);\n        const split = splitLines(stripped);\n        const heading = retrieveHeading(split); // Retrieve the headings from the CSV, unless the user specified the keys\n        const lines = retrieveRecordLines(heading); // Retrieve the record lines from the CSV\n        return transformRecordLines(lines); // Retrieve the JSON document array\n    }\n    return {\n        convert,\n    };\n};\nexports.Csv2Json = Csv2Json;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvY3N2Mmpzb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixtQkFBbUIsbUJBQU8sQ0FBQywyREFBVTtBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyxxRUFBYTtBQUN6QywyQkFBMkIsbUJBQU8sQ0FBQyw2REFBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxvREFBb0Q7QUFDcEQsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIkQ6XFxTT1dOX0dJQUlDXFxORVhULVdPUktcXEhBQ0tBVEhPTi0zXFxVSS1VWC1IQUNLQVRIT04tTmV4dEpTLURlc2lnbi1KYW0tMjAyNC0oTVktQ0xPTkUtUFJPSkVDVClcXG5vZGVfbW9kdWxlc1xcanNvbi0yLWNzdlxcbGliXFxjc3YyanNvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ3N2Mkpzb24gPSB2b2lkIDA7XG5jb25zdCBkb2NfcGF0aF8xID0gcmVxdWlyZShcImRvYy1wYXRoXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5jb25zdCBDc3YySnNvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgY29uc3QgZXNjYXBlZFdyYXBEZWxpbWl0ZXJSZWdleCA9IG5ldyBSZWdFeHAob3B0aW9ucy5kZWxpbWl0ZXIud3JhcCArIG9wdGlvbnMuZGVsaW1pdGVyLndyYXAsICdnJyksIGV4Y2VsQk9NUmVnZXggPSBuZXcgUmVnRXhwKCdeJyArIGNvbnN0YW50c18xLmV4Y2VsQk9NKSwgdmFsdWVQYXJzZXJGbiA9IG9wdGlvbnMucGFyc2VWYWx1ZSAmJiB0eXBlb2Ygb3B0aW9ucy5wYXJzZVZhbHVlID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5wYXJzZVZhbHVlIDogSlNPTi5wYXJzZTtcbiAgICAvKipcbiAgICAgKiBUcmltcyB0aGUgaGVhZGVyIGtleSwgaWYgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyIHZpYSB0aGUgcHJvdmlkZWQgb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NIZWFkZXJLZXkoaGVhZGVyS2V5KSB7XG4gICAgICAgIGhlYWRlcktleSA9IHJlbW92ZVdyYXBEZWxpbWl0ZXJzRnJvbVZhbHVlKGhlYWRlcktleSk7XG4gICAgICAgIGlmIChvcHRpb25zLnRyaW1IZWFkZXJGaWVsZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJLZXkuc3BsaXQoJy4nKVxuICAgICAgICAgICAgICAgIC5tYXAoKGNvbXBvbmVudCkgPT4gY29tcG9uZW50LnRyaW0oKSlcbiAgICAgICAgICAgICAgICAuam9pbignLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJLZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBKU09OIGhlYWRpbmcgZnJvbSB0aGUgQ1NWXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV0cmlldmVIZWFkaW5nKGxpbmVzKSB7XG4gICAgICAgIGxldCBoZWFkZXJGaWVsZHMgPSBbXTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVyRmllbGRzKSB7XG4gICAgICAgICAgICBoZWFkZXJGaWVsZHMgPSBvcHRpb25zLmhlYWRlckZpZWxkcy5tYXAoKGhlYWRlckZpZWxkLCBpbmRleCkgPT4gKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJvY2Vzc0hlYWRlcktleShoZWFkZXJGaWVsZCksXG4gICAgICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIGFuZCByZXR1cm4gdGhlIGhlYWRpbmcga2V5c1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUm93ID0gbGluZXNbMF07XG4gICAgICAgICAgICBoZWFkZXJGaWVsZHMgPSBoZWFkZXJSb3cubWFwKChoZWFkZXJLZXksIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwcm9jZXNzSGVhZGVyS2V5KGhlYWRlcktleSksXG4gICAgICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIHByb3ZpZGVkIGtleXMsIGZpbHRlciB0aGUgZ2VuZXJhdGVkIGtleXMgdG8ganVzdCB0aGUgdXNlciBwcm92aWRlZCBrZXlzIHNvIHdlIGFsc28gaGF2ZSB0aGUga2V5IGluZGV4XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5rZXlzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IG9wdGlvbnMua2V5czsgLy8gVHlwZVNjcmlwdCB0eXBlIGNoZWNraW5nIHdvcmsgYXJvdW5kIHRvIGdldCBpdCB0byByZWNvZ25pemUgdGhlIG9wdGlvbiBpcyBub3QgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgaGVhZGVyRmllbGRzID0gaGVhZGVyRmllbGRzLmZpbHRlcigoaGVhZGVyS2V5KSA9PiBrZXlzLmluY2x1ZGVzKGhlYWRlcktleS52YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5lcyxcbiAgICAgICAgICAgIGhlYWRlckZpZWxkcyxcbiAgICAgICAgICAgIHJlY29yZExpbmVzOiBbXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgRXhjZWwgQk9NIHZhbHVlLCBpZiBzcGVjaWZpZWQgYnkgdGhlIG9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RyaXBFeGNlbEJPTShjc3YpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZXhjZWxCT00pIHtcbiAgICAgICAgICAgIHJldHVybiBjc3YucmVwbGFjZShleGNlbEJPTVJlZ2V4LCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNzdjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgc3BsaXRzIGEgbGluZSBzbyB0aGF0IHdlIGNhbiBoYW5kbGUgd3JhcHBlZCBmaWVsZHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcGxpdExpbmVzKGNzdikge1xuICAgICAgICAvLyBQYXJzZSBvdXQgdGhlIGxpbmUuLi5cbiAgICAgICAgY29uc3QgbGluZXMgPSBbXSwgbGFzdENoYXJhY3RlckluZGV4ID0gY3N2Lmxlbmd0aCAtIDEsIGVvbERlbGltaXRlckxlbmd0aCA9IG9wdGlvbnMuZGVsaW1pdGVyLmVvbC5sZW5ndGgsIHN0YXRlVmFyaWFibGVzID0ge1xuICAgICAgICAgICAgaW5zaWRlV3JhcERlbGltaXRlcjogZmFsc2UsXG4gICAgICAgICAgICBwYXJzaW5nVmFsdWU6IHRydWUsXG4gICAgICAgICAgICBqdXN0UGFyc2VkRG91YmxlUXVvdGU6IGZhbHNlLFxuICAgICAgICAgICAgc3RhcnRJbmRleDogMFxuICAgICAgICB9O1xuICAgICAgICBsZXQgc3BsaXRMaW5lID0gW10sIGNoYXJhY3RlciwgY2hhckJlZm9yZSwgY2hhckFmdGVyLCBuZXh0TkNoYXIsIGluZGV4ID0gMDtcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggY2hhcmFjdGVyIGluIHRoZSBsaW5lIHRvIGlkZW50aWZ5IHdoZXJlIHRvIHNwbGl0IHRoZSB2YWx1ZXNcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgY3N2Lmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gQ3VycmVudCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGNoYXJhY3RlciA9IGNzdltpbmRleF07XG4gICAgICAgICAgICAvLyBQcmV2aW91cyBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGNoYXJCZWZvcmUgPSBpbmRleCA/IGNzdltpbmRleCAtIDFdIDogJyc7XG4gICAgICAgICAgICAvLyBOZXh0IGNoYXJhY3RlclxuICAgICAgICAgICAgY2hhckFmdGVyID0gaW5kZXggPCBsYXN0Q2hhcmFjdGVySW5kZXggPyBjc3ZbaW5kZXggKyAxXSA6ICcnO1xuICAgICAgICAgICAgLy8gTmV4dCBuIGNoYXJhY3RlcnMsIGluY2x1ZGluZyB0aGUgY3VycmVudCBjaGFyYWN0ZXIsIHdoZXJlIG4gPSBsZW5ndGgoRU9MIGRlbGltaXRlcilcbiAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIGZvciB0aGUgY2hlY2tpbmcgb2YgYW4gRU9MIGRlbGltaXRlciB3aGVuIGlmIGl0IGlzIG1vcmUgdGhhbiBhIHNpbmdsZSBjaGFyYWN0ZXIgKGVnLiAnXFxyXFxuJylcbiAgICAgICAgICAgIG5leHROQ2hhciA9IHV0aWxzLmdldE5DaGFyYWN0ZXJzKGNzdiwgaW5kZXgsIGVvbERlbGltaXRlckxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoKG5leHROQ2hhciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZW9sICYmICFzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyIHx8XG4gICAgICAgICAgICAgICAgaW5kZXggPT09IGxhc3RDaGFyYWN0ZXJJbmRleCkgJiYgY2hhckJlZm9yZSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGFuIEVPTCBkZWxpbWl0ZXIgb3IgdGhlIGVuZCBvZiB0aGUgY3N2IGFuZCB0aGUgcHJldmlvdXMgY2hhcmFjdGVyIGlzIGEgZmllbGQgZGVsaW1pdGVyLi4uXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHN0YXJ0IGluZGV4IGlzIHRoZSBjdXJyZW50IGluZGV4IChhbmQgc2luY2UgdGhlIHByZXZpb3VzIGNoYXJhY3RlciBpcyBhIGNvbW1hKSxcbiAgICAgICAgICAgICAgICAvLyAgIHRoZW4gdGhlIHZhbHVlIGJlaW5nIHBhcnNlZCBpcyBhbiBlbXB0eSB2YWx1ZSBhY2NvcmRpbmdseSwgYWRkIGFuIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgIGlmIChuZXh0TkNoYXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmVvbCAmJiBzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4ID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBDU1YsIHRoZXJlJ3Mgbm8gbmV3IGxpbmUsIGFuZCB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXMgYSBjb21tYVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIGFkZCBhbiBlbXB0eSBzdHJpbmcgZm9yIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0TGluZS5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhlcmUncyBhIHZhbGlkIHZhbHVlLCBhbmQgdGhlIHN0YXJ0IGluZGV4IGlzbid0IHRoZSBjdXJyZW50IGluZGV4LCBncmFiIHRoZSB3aG9sZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaChjc3Yuc3Vic3RyaW5nKHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIGxhc3QgY2hhcmFjdGVyIGlzIGEgY29tbWEsIHRoZXJlJ3Mgc3RpbGwgYW4gYWRkaXRpb25hbCBpbXBsaWVkIGZpZWxkIHZhbHVlIHRyYWlsaW5nIHRoZSBjb21tYS5cbiAgICAgICAgICAgICAgICAvLyAgIFNpbmNlIHRoaXMgdmFsdWUgaXMgZW1wdHksIHdlIHB1c2ggYW4gZXh0cmEgZW1wdHkgdmFsdWVcbiAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgLy8gRmluYWxseSwgcHVzaCB0aGUgc3BsaXQgbGluZSB2YWx1ZXMgaW50byB0aGUgbGluZXMgYXJyYXkgYW5kIGNsZWFyIHRoZSBzcGxpdCBsaW5lXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChzcGxpdExpbmUpO1xuICAgICAgICAgICAgICAgIHNwbGl0TGluZSA9IFtdO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXggPSBpbmRleCArIGVvbERlbGltaXRlckxlbmd0aDtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgPSBjaGFyQWZ0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gbGFzdENoYXJhY3RlckluZGV4ICYmIGNoYXJhY3RlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaCB0aGUgZW5kIG9mIHRoZSBDU1YgYW5kIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpcyBhIGZpZWxkIGRlbGltaXRlclxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBwcmV2aW91c2x5IHNlZW4gdmFsdWUgYW5kIGFkZCBpdCB0byB0aGUgbGluZVxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gY3N2LnN1YnN0cmluZyhzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgc3BsaXRMaW5lLnB1c2gocGFyc2VkVmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIFRoZW4gYWRkIGFuIGVtcHR5IHN0cmluZyB0byB0aGUgbGluZSBzaW5jZSB0aGUgbGFzdCBjaGFyYWN0ZXIgYmVpbmcgYSBmaWVsZCBkZWxpbWl0ZXIgaW5kaWNhdGVzIGFuIGVtcHR5IGZpZWxkXG4gICAgICAgICAgICAgICAgc3BsaXRMaW5lLnB1c2goJycpO1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goc3BsaXRMaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSBsYXN0Q2hhcmFjdGVySW5kZXggfHwgbmV4dE5DaGFyID09PSBvcHRpb25zLmRlbGltaXRlci5lb2wgJiZcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmVuJ3QgaW5zaWRlIHdyYXAgZGVsaW1pdGVycyBvciBpZiB3ZSBhcmUgYnV0IHRoZSBjaGFyYWN0ZXIgYmVmb3JlIHdhcyBhIHdyYXAgZGVsaW1pdGVyIGFuZCB3ZSBkaWRuJ3QganVzdCBzZWUgdHdvXG4gICAgICAgICAgICAgICAgKCFzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgJiYgY2hhckJlZm9yZSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiAhc3RhdGVWYXJpYWJsZXMuanVzdFBhcnNlZERvdWJsZVF1b3RlKSkge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpZiB3ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGxpbmUgb3IgY3N2IChhbmQgY3VycmVudCBjaGFyYWN0ZXIgaXMgbm90IGEgZmllbGQgZGVsaW1pdGVyKVxuICAgICAgICAgICAgICAgIGNvbnN0IHRvSW5kZXggPSBpbmRleCAhPT0gbGFzdENoYXJhY3RlckluZGV4IHx8IGNoYXJCZWZvcmUgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgPyBpbmRleCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgcmVtYWluaW5nIHZhbHVlIGFuZCBhZGQgaXQgdG8gdGhlIHNwbGl0IGxpbmUgbGlzdCBvZiB2YWx1ZXNcbiAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaChjc3Yuc3Vic3RyaW5nKHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXgsIHRvSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAvLyBGaW5hbGx5LCBwdXNoIHRoZSBzcGxpdCBsaW5lIHZhbHVlcyBpbnRvIHRoZSBsaW5lcyBhcnJheSBhbmQgY2xlYXIgdGhlIHNwbGl0IGxpbmVcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHNwbGl0TGluZSk7XG4gICAgICAgICAgICAgICAgc3BsaXRMaW5lID0gW107XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCA9IGluZGV4ICsgZW9sRGVsaW1pdGVyTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciA9IGNoYXJBZnRlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiBjaGFyQmVmb3JlID09PSBvcHRpb25zLmRlbGltaXRlci5maWVsZCAmJlxuICAgICAgICAgICAgICAgICFzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyICYmICFzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgd3JhcCBkZWxpbWl0ZXIgYWZ0ZXIgYSBjb21tYSBhbmQgd2UgYXJlbid0IGluc2lkZSBhIHdyYXAgZGVsaW1pdGVyXG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5leHQgY2hhcmFjdGVyKHMpIGFyZSBhbiBFT0wgZGVsaW1pdGVyLCB0aGVuIHNraXAgdGhlbSBzbyB3ZSBkb24ndCBwYXJzZSB3aGF0IHdlJ3ZlIHNlZW4gYXMgYW5vdGhlciB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmICh1dGlscy5nZXROQ2hhcmFjdGVycyhjc3YsIGluZGV4ICsgMSwgZW9sRGVsaW1pdGVyTGVuZ3RoKSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZW9sKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IG9wdGlvbnMuZGVsaW1pdGVyLmVvbC5sZW5ndGggKyAxOyAvLyBTa2lwIHBhc3QgRU9MXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhckJlZm9yZSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQgJiYgY2hhcmFjdGVyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmIGNoYXJBZnRlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZW9sKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgcmVhY2hlZCB0aGUgc3RhcnQgb2YgYSB3cmFwcGVkIG5ldyBmaWVsZCB0aGF0IGJlZ2lucyB3aXRoIGFuIEVPTCBkZWxpbWl0ZXJcbiAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgcmVtYWluaW5nIHZhbHVlIGFuZCBhZGQgaXQgdG8gdGhlIHNwbGl0IGxpbmUgbGlzdCBvZiB2YWx1ZXNcbiAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaChjc3Yuc3Vic3RyaW5nKHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXgsIGluZGV4IC0gMSkpO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmp1c3RQYXJzZWREb3VibGVRdW90ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChjaGFyQmVmb3JlICE9PSBvcHRpb25zLmRlbGltaXRlci53cmFwIHx8IHN0YXRlVmFyaWFibGVzLmp1c3RQYXJzZWREb3VibGVRdW90ZSAmJiBjaGFyQmVmb3JlID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwKSAmJlxuICAgICAgICAgICAgICAgIGNoYXJhY3RlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiB1dGlscy5nZXROQ2hhcmFjdGVycyhjc3YsIGluZGV4ICsgMSwgZW9sRGVsaW1pdGVyTGVuZ3RoKSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZW9sKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2ggYSB3cmFwIHdoaWNoIGlzIG5vdCBwcmVjZWRlZCBieSBhIHdyYXAgZGVsaW0gYW5kIHRoZSBuZXh0IGNoYXJhY3RlciBpcyBhbiBFT0wgZGVsaW0gKGllLiAqXCJcXG4pXG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIE5leHQgaXRlcmF0aW9uIHdpbGwgc3Vic3RyaW5nLCBhZGQgdGhlIHZhbHVlIHRvIHRoZSBsaW5lLCBhbmQgcHVzaCB0aGUgbGluZSBvbnRvIHRoZSBhcnJheSBvZiBsaW5lc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmIChpbmRleCA9PT0gMCB8fCB1dGlscy5nZXROQ2hhcmFjdGVycyhjc3YsIGluZGV4IC0gZW9sRGVsaW1pdGVyTGVuZ3RoLCBlb2xEZWxpbWl0ZXJMZW5ndGgpID09PSBvcHRpb25zLmRlbGltaXRlci5lb2wgJiYgIXN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGxpbmUgc3RhcnRzIHdpdGggYSB3cmFwIGRlbGltaXRlciAoaWUuIFwiKilcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiBjaGFyQWZ0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkICYmIHN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgd3JhcCBkZWxpbWl0ZXIgd2l0aCBhIGZpZWxkIGRlbGltaXRlciBhZnRlciBpdCAoaWUuICpcIiwpXG4gICAgICAgICAgICAgICAgc3BsaXRMaW5lLnB1c2goY3N2LnN1YnN0cmluZyhzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4LCBpbmRleCArIDEpKTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4ID0gaW5kZXggKyAyOyAvLyBuZXh0IHZhbHVlIHN0YXJ0cyBhZnRlciB0aGUgZmllbGQgZGVsaW1pdGVyXG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmIGNoYXJCZWZvcmUgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkICYmXG4gICAgICAgICAgICAgICAgIXN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgJiYgc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHdyYXAgZGVsaW1pdGVyIHdpdGggYSBmaWVsZCBkZWxpbWl0ZXIgYWZ0ZXIgaXQgKGllLiAsXCIqKVxuICAgICAgICAgICAgICAgIHNwbGl0TGluZS5wdXNoKGNzdi5zdWJzdHJpbmcoc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCwgaW5kZXggLSAxKSk7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgY2hhckFmdGVyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmIGluZGV4ICE9PSBzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcnVuIGludG8gYW4gZXNjYXBlZCBxdW90ZSAoaWUuIFwiXCIpIHNraXAgcGFzdCB0aGUgc2Vjb25kIHF1b3RlXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5qdXN0UGFyc2VkRG91YmxlUXVvdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyID09PSBvcHRpb25zLmRlbGltaXRlci5maWVsZCAmJiBjaGFyQmVmb3JlICE9PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmXG4gICAgICAgICAgICAgICAgY2hhckFmdGVyICE9PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmICFzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyICYmXG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIGZpZWxkIGRlbGltaXRlciBhbmQgYXJlIG5vdCBpbnNpZGUgdGhlIHdyYXAgZGVsaW1pdGVycyAoaWUuICosKilcbiAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaChjc3Yuc3Vic3RyaW5nKHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXgsIGluZGV4KSk7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQgJiYgY2hhckJlZm9yZSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJlxuICAgICAgICAgICAgICAgIGNoYXJBZnRlciAhPT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiAhc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIGZpZWxkIGRlbGltaXRlciwgdGhlIHByZXZpb3VzIGNoYXJhY3RlciB3YXMgYSB3cmFwIGRlbGltaXRlciwgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbmV4dCBjaGFyYWN0ZXIgaXMgbm90IGEgd3JhcCBkZWxpbWl0ZXIgKGllLiBcIiwqKVxuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IHRvIHRoZSBuZXh0IGNoYXJhY3RlclxuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBkb3VibGUgcXVvdGUgc3RhdGUgdmFyaWFibGVcbiAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmp1c3RQYXJzZWREb3VibGVRdW90ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSByZWNvcmQgbGluZXMgZnJvbSB0aGUgc3BsaXQgQ1NWIGxpbmVzIGFuZCBzZXRzIGl0IG9uIHRoZSBwYXJhbXMgb2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV0cmlldmVSZWNvcmRMaW5lcyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVyRmllbGRzKSB7IC8vIFRoaXMgb3B0aW9uIGlzIHBhc3NlZCBmb3IgaW5zdGFuY2VzIHdoZXJlIHRoZSBDU1YgaGFzIG5vIGhlYWRlciBsaW5lXG4gICAgICAgICAgICBwYXJhbXMucmVjb3JkTGluZXMgPSBwYXJhbXMubGluZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIEFsbCBsaW5lcyBleGNlcHQgZm9yIHRoZSBoZWFkZXIgbGluZVxuICAgICAgICAgICAgcGFyYW1zLnJlY29yZExpbmVzID0gcGFyYW1zLmxpbmVzLnNwbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHZhbHVlIGZvciB0aGUgcmVjb3JkIGZyb20gdGhlIGxpbmUgYXQgdGhlIHByb3ZpZGVkIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXRyaWV2ZVJlY29yZFZhbHVlRnJvbUxpbmUoaGVhZGVyRmllbGQsIGxpbmUpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSB2YWx1ZSBhdCB0aGUga2V5J3MgaW5kZXgsIHVzZSBpdDsgb3RoZXJ3aXNlLCBudWxsXG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGluZVtoZWFkZXJGaWVsZC5pbmRleF07XG4gICAgICAgIC8vIFBlcmZvcm0gYW55IG5lY2Vzc2FyeSB2YWx1ZSBjb252ZXJzaW9ucyBvbiB0aGUgcmVjb3JkIHZhbHVlXG4gICAgICAgIHJldHVybiBwcm9jZXNzUmVjb3JkVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgdGhlIHJlY29yZCdzIHZhbHVlIGJ5IHBhcnNpbmcgdGhlIGRhdGEgdG8gZW5zdXJlIHRoZSBDU1YgaXNcbiAgICAgKiBjb252ZXJ0ZWQgdG8gdGhlIEpTT04gdGhhdCBjcmVhdGVkIGl0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NSZWNvcmRWYWx1ZShmaWVsZFZhbHVlKSB7XG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhbiBhcnJheSByZXByZXNlbnRhdGlvbiwgY29udmVydCBpdFxuICAgICAgICBjb25zdCBwYXJzZWRKc29uID0gcGFyc2VWYWx1ZShmaWVsZFZhbHVlKTtcbiAgICAgICAgLy8gSWYgcGFyc2VkSnNvbiBpcyBhbnl0aGluZyBhc2lkZSBmcm9tIGFuIGVycm9yLCB0aGVuIHdlIHdhbnQgdG8gdXNlIHRoZSBwYXJzZWQgdmFsdWVcbiAgICAgICAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gaW50ZXJwcmV0IHZhbHVlcyBsaWtlICdudWxsJyAtLT4gbnVsbCwgJ2ZhbHNlJyAtLT4gZmFsc2VcbiAgICAgICAgaWYgKCF1dGlscy5pc0Vycm9yKHBhcnNlZEpzb24pICYmICF1dGlscy5pc0ludmFsaWQocGFyc2VkSnNvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRKc29uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpZWxkVmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWVsZFZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmltcyB0aGUgcmVjb3JkIHZhbHVlLCBpZiBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgdmlhIHRoZSBvcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1SZWNvcmRWYWx1ZShmaWVsZFZhbHVlKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnRyaW1GaWVsZFZhbHVlcyAmJiBmaWVsZFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZS50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIEpTT04gZG9jdW1lbnQgd2l0aCB0aGUgZ2l2ZW4ga2V5cyAoZGVzaWduYXRlZCBieSB0aGUgQ1NWIGhlYWRlcilcbiAgICAgKiAgIGFuZCB0aGUgdmFsdWVzIChmcm9tIHRoZSBnaXZlbiBsaW5lKVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGNyZWF0ZWQganNvbiBkb2N1bWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50KGhlYWRlckZpZWxkcywgbGluZSkge1xuICAgICAgICAvLyBSZWR1Y2UgdGhlIGtleXMgaW50byBhIEpTT04gZG9jdW1lbnQgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBsaW5lXG4gICAgICAgIHJldHVybiBoZWFkZXJGaWVsZHMucmVkdWNlKChkb2N1bWVudCwgaGVhZGVyRmllbGQpID0+IHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgdmFsdWUgYXQgdGhlIGtleSdzIGluZGV4IGluIHRoZSBsaW5lLCBzZXQgdGhlIHZhbHVlOyBvdGhlcndpc2UgbnVsbFxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXRyaWV2ZVJlY29yZFZhbHVlRnJvbUxpbmUoaGVhZGVyRmllbGQsIGxpbmUpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIHRoZSBrZXkgYW5kIHZhbHVlIHRvIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgZG9jX3BhdGhfMS5zZXRQYXRoKShkb2N1bWVudCwgaGVhZGVyRmllbGQudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIENhdGNoIGFueSBlcnJvcnMgd2hlcmUga2V5IHBhdGhzIGFyZSBudWxsIG9yICcnIGFuZCBjb250aW51ZVxuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBvdXRlcm1vc3Qgd3JhcCBkZWxpbWl0ZXJzIGZyb20gYSB2YWx1ZSwgaWYgdGhleSBhcmUgcHJlc2VudFxuICAgICAqIE90aGVyd2lzZSwgdGhlIG5vbi13cmFwcGVkIHZhbHVlIGlzIHJldHVybmVkIGFzIGlzXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlV3JhcERlbGltaXRlcnNGcm9tVmFsdWUoZmllbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCBmaXJzdENoYXIgPSBmaWVsZFZhbHVlWzBdLCBsYXN0SW5kZXggPSBmaWVsZFZhbHVlLmxlbmd0aCAtIDEsIGxhc3RDaGFyID0gZmllbGRWYWx1ZVtsYXN0SW5kZXhdO1xuICAgICAgICAvLyBJZiB0aGUgZmllbGQgc3RhcnRzIGFuZCBlbmRzIHdpdGggYSB3cmFwIGRlbGltaXRlclxuICAgICAgICBpZiAoZmlyc3RDaGFyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmIGxhc3RDaGFyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIGZpZWxkIGlzIGp1c3QgYSBwYWlyIG9mIHdyYXAgZGVsaW1pdGVycyBcbiAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlLmxlbmd0aCA8PSAyID8gJycgOiBmaWVsZFZhbHVlLnN1YnN0cmluZygxLCBsYXN0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWVsZFZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbmVzY2FwZXMgd3JhcCBkZWxpbWl0ZXJzIGJ5IHJlcGxhY2luZyBkdXBsaWNhdGVzIHdpdGggYSBzaW5nbGUgKGVnLiBcIlwiIC0+IFwiKVxuICAgICAqIFRoaXMgaXMgZG9uZSBpbiBvcmRlciB0byBwYXJzZSBSRkMgNDE4MCBjb21wbGlhbnQgQ1NWIGJhY2sgdG8gSlNPTlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlV3JhcERlbGltaXRlckluRmllbGQoZmllbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gZmllbGRWYWx1ZS5yZXBsYWNlKGVzY2FwZWRXcmFwRGVsaW1pdGVyUmVnZXgsIG9wdGlvbnMuZGVsaW1pdGVyLndyYXApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWluIGhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IHRoZSBDU1YgdG8gdGhlIEpTT04gZG9jdW1lbnQgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1SZWNvcmRMaW5lcyhwYXJhbXMpIHtcbiAgICAgICAgLy8gRm9yIGVhY2ggbGluZSwgY3JlYXRlIHRoZSBkb2N1bWVudCBhbmQgYWRkIGl0IHRvIHRoZSBhcnJheSBvZiBkb2N1bWVudHNcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5yZWNvcmRMaW5lcy5yZWR1Y2UoKGdlbmVyYXRlZEpzb25PYmplY3RzLCBsaW5lKSA9PiB7XG4gICAgICAgICAgICBsaW5lID0gbGluZS5tYXAoKGZpZWxkVmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIHRoZSBuZWNlc3Nhcnkgb3BlcmF0aW9ucyBvbiBlYWNoIGxpbmVcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlID0gcmVtb3ZlV3JhcERlbGltaXRlcnNGcm9tVmFsdWUoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9IHVuZXNjYXBlV3JhcERlbGltaXRlckluRmllbGQoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9IHRyaW1SZWNvcmRWYWx1ZShmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGVkRG9jdW1lbnQgPSBjcmVhdGVEb2N1bWVudChwYXJhbXMuaGVhZGVyRmllbGRzLCBsaW5lKTtcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRKc29uT2JqZWN0cy5jb25jYXQoZ2VuZXJhdGVkRG9jdW1lbnQpO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIHBhcnNlIHRoZSBwcm92aWRlZCB2YWx1ZS4gSWYgaXQgaXMgbm90IHBhcnNhYmxlLCB0aGVuIGFuIGVycm9yIGlzIHJldHVybmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nUmVwcmVzZW50YXRpb24odmFsdWUsIG9wdGlvbnMpICYmICF1dGlscy5pc0RhdGVSZXByZXNlbnRhdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRKc29uID0gdmFsdWVQYXJzZXJGbih2YWx1ZSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcGFyc2VkIHZhbHVlIGlzIGFuIGFycmF5LCB0aGVuIHdlIGFsc28gbmVlZCB0byB0cmltIHJlY29yZCB2YWx1ZXMsIGlmIHNwZWNpZmllZFxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkSnNvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkSnNvbi5tYXAodHJpbVJlY29yZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRKc29uO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWxseSBleHBvcnRlZCBjc3YyanNvbiBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnZlcnQoZGF0YSkge1xuICAgICAgICAvLyBTcGxpdCB0aGUgQ1NWIGludG8gbGluZXMgdXNpbmcgdGhlIHNwZWNpZmllZCBFT0wgb3B0aW9uXG4gICAgICAgIGNvbnN0IHN0cmlwcGVkID0gc3RyaXBFeGNlbEJPTShkYXRhKTtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBzcGxpdExpbmVzKHN0cmlwcGVkKTtcbiAgICAgICAgY29uc3QgaGVhZGluZyA9IHJldHJpZXZlSGVhZGluZyhzcGxpdCk7IC8vIFJldHJpZXZlIHRoZSBoZWFkaW5ncyBmcm9tIHRoZSBDU1YsIHVubGVzcyB0aGUgdXNlciBzcGVjaWZpZWQgdGhlIGtleXNcbiAgICAgICAgY29uc3QgbGluZXMgPSByZXRyaWV2ZVJlY29yZExpbmVzKGhlYWRpbmcpOyAvLyBSZXRyaWV2ZSB0aGUgcmVjb3JkIGxpbmVzIGZyb20gdGhlIENTVlxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtUmVjb3JkTGluZXMobGluZXMpOyAvLyBSZXRyaWV2ZSB0aGUgSlNPTiBkb2N1bWVudCBhcnJheVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjb252ZXJ0LFxuICAgIH07XG59O1xuZXhwb3J0cy5Dc3YySnNvbiA9IENzdjJKc29uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/json-2-csv/lib/csv2json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/json-2-csv/lib/json2csv.js":
/*!*************************************************!*\
  !*** ./node_modules/json-2-csv/lib/json2csv.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Json2Csv = void 0;\nconst doc_path_1 = __webpack_require__(/*! doc-path */ \"(ssr)/./node_modules/doc-path/lib/path.js\");\nconst deeks_1 = __webpack_require__(/*! deeks */ \"(ssr)/./node_modules/deeks/lib/deeks.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/json-2-csv/lib/constants.js\");\nconst utils = __importStar(__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/json-2-csv/lib/utils.js\"));\nconst Json2Csv = function (options) {\n    const wrapDelimiterCheckRegex = new RegExp(options.delimiter.wrap, 'g'), crlfSearchRegex = /\\r?\\n|\\r/, customValueParser = options.parseValue && typeof options.parseValue === 'function' ? options.parseValue : null, expandingWithoutUnwinding = options.expandArrayObjects && !options.unwindArrays, deeksOptions = {\n        arrayIndexesAsKeys: options.arrayIndexesAsKeys,\n        expandNestedObjects: options.expandNestedObjects,\n        expandArrayObjects: expandingWithoutUnwinding,\n        ignoreEmptyArraysWhenExpanding: expandingWithoutUnwinding,\n        escapeNestedDots: true,\n    };\n    /** HEADER FIELD FUNCTIONS **/\n    /**\n     * Returns the list of data field names of all documents in the provided list\n     */\n    function getFieldNameList(data) {\n        // If keys weren't specified, then we'll use the list of keys generated by the deeks module\n        return (0, deeks_1.deepKeysFromList)(data, deeksOptions);\n    }\n    /**\n     * Processes the schemas by checking for schema differences, if so desired.\n     * If schema differences are not to be checked, then it resolves the unique\n     * list of field names.\n     */\n    function processSchemas(documentSchemas) {\n        // If there are no document schemas then there is nothing to diff and no unique fields to get\n        if (documentSchemas.length === 0) {\n            return [];\n        }\n        // If the user wants to check for the same schema (regardless of schema ordering)\n        if (options.checkSchemaDifferences) {\n            return checkSchemaDifferences(documentSchemas);\n        }\n        else {\n            // Otherwise, we do not care if the schemas are different, so we should get the unique list of keys\n            const uniqueFieldNames = utils.unique(utils.flatten(documentSchemas));\n            return uniqueFieldNames;\n        }\n    }\n    /**\n     * This function performs the schema difference check, if the user specifies that it should be checked.\n     * If there are no field names, then there are no differences.\n     * Otherwise, we get the first schema and the remaining list of schemas\n     */\n    function checkSchemaDifferences(documentSchemas) {\n        // have multiple documents - ensure only one schema (regardless of field ordering)\n        const firstDocSchema = documentSchemas[0], restOfDocumentSchemas = documentSchemas.slice(1), schemaDifferences = computeNumberOfSchemaDifferences(firstDocSchema, restOfDocumentSchemas);\n        // If there are schema inconsistencies, throw a schema not the same error\n        if (schemaDifferences) {\n            throw new Error(constants_1.errors.json2csv.notSameSchema);\n        }\n        return firstDocSchema;\n    }\n    /**\n     * Computes the number of schema differences\n     */\n    function computeNumberOfSchemaDifferences(firstDocSchema, restOfDocumentSchemas) {\n        return restOfDocumentSchemas.reduce((schemaDifferences, documentSchema) => {\n            // If there is a difference between the schemas, increment the counter of schema inconsistencies\n            const numberOfDifferences = utils.computeSchemaDifferences(firstDocSchema, documentSchema).length;\n            return numberOfDifferences > 0\n                ? schemaDifferences + 1\n                : schemaDifferences;\n        }, 0);\n    }\n    /**\n     * If so specified, this filters the detected key paths to exclude any keys that have been specified\n     */\n    function filterExcludedKeys(keyPaths) {\n        if (options.excludeKeys) {\n            return keyPaths.filter((keyPath) => {\n                for (const excludedKey of options.excludeKeys) {\n                    // Only match if the excludedKey appears at the beginning of the string so we don't accidentally match a key farther down in a key path\n                    const regex = excludedKey instanceof RegExp ? excludedKey : new RegExp(`^${excludedKey}`);\n                    if (excludedKey === keyPath || keyPath.match(regex)) {\n                        return false; // Exclude the key\n                    }\n                }\n                return true; // Otherwise, include the key\n            });\n        }\n        return keyPaths;\n    }\n    /**\n     * If so specified, this sorts the header field names alphabetically\n     */\n    function sortHeaderFields(fieldNames) {\n        if (options.sortHeader && typeof options.sortHeader === 'function') {\n            return fieldNames.sort(options.sortHeader);\n        }\n        else if (options.sortHeader) {\n            return fieldNames.sort();\n        }\n        return fieldNames;\n    }\n    /**\n     * Trims the header fields, if the user desires them to be trimmed.\n     */\n    function trimHeaderFields(params) {\n        if (options.trimHeaderFields) {\n            params.headerFields = params.headerFields.map((field) => field.split('.')\n                .map((component) => component.trim())\n                .join('.'));\n        }\n        return params;\n    }\n    /**\n     * Wrap the headings, if desired by the user.\n     */\n    function wrapHeaderFields(params) {\n        // only perform this if we are actually prepending the header\n        if (options.prependHeader) {\n            params.headerFields = params.headerFields.map(function (headingKey) {\n                return wrapFieldValueIfNecessary(headingKey);\n            });\n        }\n        return params;\n    }\n    /**\n     * Generates the CSV header string by joining the headerFields by the field delimiter\n     */\n    function generateCsvHeader(params) {\n        // #185 - generate a keys list to avoid finding native Map() methods\n        const fieldTitleMapKeys = Object.keys(options.fieldTitleMap);\n        params.header = params.headerFields\n            .map(function (field) {\n            let headerKey = field;\n            // If a custom field title was provided for this field, use that\n            if (fieldTitleMapKeys.includes(field)) {\n                headerKey = options.fieldTitleMap[field];\n            }\n            else if (!options.escapeHeaderNestedDots) {\n                // Otherwise, if the user doesn't want nested dots in keys to be escaped, then unescape them\n                headerKey = headerKey.replace(/\\\\\\./g, '.');\n            }\n            return headerKey;\n        })\n            .join(options.delimiter.field);\n        return params;\n    }\n    function convertKeysToHeaderFields() {\n        if (!options.keys)\n            return [];\n        return options.keys.map((key) => {\n            if (typeof key === 'object' && 'field' in key) {\n                options.fieldTitleMap[key.field] = key.title ?? key.field;\n                return key.field;\n            }\n            return key;\n        });\n    }\n    function extractWildcardMatchKeys() {\n        if (!options.keys)\n            return [];\n        return options.keys.flatMap(item => {\n            if (typeof item === 'string') {\n                // Exclude plain strings that were passed in options.keys\n                return [];\n            }\n            else if (item?.wildcardMatch) {\n                // Return \"field\" value for objects with wildcardMatch: true\n                return item.field;\n            }\n            // Exclude other objects\n            return [];\n        });\n    }\n    /**\n     * Retrieve the headings for all documents and return it.\n     * This checks that all documents have the same schema.\n     */\n    function retrieveHeaderFields(data) {\n        const wildcardMatchKeys = extractWildcardMatchKeys();\n        const keyStrings = convertKeysToHeaderFields();\n        const fieldNames = getFieldNameList(data);\n        const processed = processSchemas(fieldNames);\n        if (options.keys) {\n            options.keys = keyStrings;\n            const matchedKeys = keyStrings.flatMap((userProvidedKey) => {\n                // If this is not a wildcard matched key, then just return and include it in the resulting key list\n                if (!wildcardMatchKeys.includes(userProvidedKey)) {\n                    return userProvidedKey;\n                }\n                // Otherwise, identify all detected keys that match with the provided wildcard key:\n                const matches = [];\n                const regex = new RegExp(`^${userProvidedKey}`);\n                for (const detectedKey of processed) {\n                    if (userProvidedKey === detectedKey || detectedKey.match(regex)) {\n                        matches.push(detectedKey);\n                    }\n                }\n                return matches;\n            });\n            if (!options.unwindArrays) {\n                const filtered = filterExcludedKeys(matchedKeys);\n                return sortHeaderFields(filtered);\n            }\n        }\n        const filtered = filterExcludedKeys(processed);\n        return sortHeaderFields(filtered);\n    }\n    /** RECORD FIELD FUNCTIONS **/\n    /**\n     * Unwinds objects in arrays within record objects if the user specifies the\n     * expandArrayObjects option. If not specified, this passes the params\n     * argument through to the next function in the promise chain.\n     *\n     * The `finalPass` parameter is used to trigger one last pass to ensure no more\n     * arrays need to be expanded\n     */\n    function unwindRecordsIfNecessary(params, finalPass = false) {\n        if (options.unwindArrays) {\n            const originalRecordsLength = params.records.length;\n            // Unwind each of the documents at the given headerField\n            params.headerFields.forEach((headerField) => {\n                params.records = utils.unwind(params.records, headerField);\n            });\n            const headerFields = retrieveHeaderFields(params.records);\n            params.headerFields = headerFields;\n            // If we were able to unwind more arrays, then try unwinding again...\n            if (originalRecordsLength !== params.records.length) {\n                return unwindRecordsIfNecessary(params);\n            }\n            // Otherwise, we didn't unwind any additional arrays, so continue...\n            // Run a final time in case the earlier unwinding exposed additional\n            // arrays to unwind...\n            if (!finalPass) {\n                return unwindRecordsIfNecessary(params, true);\n            }\n            // If keys were provided, set the headerFields back to the provided keys after unwinding:\n            if (options.keys) {\n                const userSelectedFields = convertKeysToHeaderFields();\n                params.headerFields = filterExcludedKeys(userSelectedFields);\n            }\n            return params;\n        }\n        return params;\n    }\n    /**\n     * Main function which handles the processing of a record, or document to be converted to CSV format\n     * This function specifies and performs the necessary operations in the necessary order\n     * in order to obtain the data and convert it to CSV form while maintaining RFC 4180 compliance.\n     * * Order of operations:\n     * - Get fields from provided key list (as array of actual values)\n     * - Convert the values to csv/string representation [possible option here for custom converters?]\n     * - Trim fields\n     * - Determine if they need to be wrapped (& wrap if necessary)\n     * - Combine values for each line (by joining by field delimiter)\n     */\n    function processRecords(params) {\n        params.recordString = params.records.map((record) => {\n            // Retrieve data for each of the headerFields from this record\n            const recordFieldData = retrieveRecordFieldData(record, params.headerFields), \n            // Process the data in this record and return the\n            processedRecordData = recordFieldData.map((fieldValue) => {\n                fieldValue = trimRecordFieldValue(fieldValue);\n                fieldValue = preventCsvInjection(fieldValue);\n                let stringified = customValueParser ? customValueParser(fieldValue, recordFieldValueToString) : recordFieldValueToString(fieldValue);\n                stringified = wrapFieldValueIfNecessary(stringified);\n                return stringified;\n            });\n            // Join the record data by the field delimiter\n            return generateCsvRowFromRecord(processedRecordData);\n        }).join(options.delimiter.eol);\n        return params;\n    }\n    /**\n     * Helper function intended to process *just* array values when the expandArrayObjects setting is set to true\n     */\n    function processRecordFieldDataForExpandedArrayObject(recordFieldValue) {\n        const filteredRecordFieldValue = utils.removeEmptyFields(recordFieldValue);\n        // If we have an array and it's either empty of full of empty values, then use an empty value representation\n        if (!recordFieldValue.length || !filteredRecordFieldValue.length) {\n            return options.emptyFieldValue || '';\n        }\n        else if (filteredRecordFieldValue.length === 1) {\n            // Otherwise, we have an array of actual values...\n            // Since we are expanding array objects, we will want to key in on values of objects.\n            return filteredRecordFieldValue[0]; // Extract the single value in the array\n        }\n        return recordFieldValue;\n    }\n    /**\n     * Gets all field values from a particular record for the given list of fields\n     */\n    function retrieveRecordFieldData(record, fields) {\n        const recordValues = [];\n        fields.forEach((field) => {\n            let recordFieldValue = (0, doc_path_1.evaluatePath)(record, field);\n            if (!utils.isUndefined(options.emptyFieldValue) && utils.isEmptyField(recordFieldValue)) {\n                recordFieldValue = options.emptyFieldValue;\n            }\n            else if (options.expandArrayObjects && Array.isArray(recordFieldValue)) {\n                recordFieldValue = processRecordFieldDataForExpandedArrayObject(recordFieldValue);\n            }\n            recordValues.push(recordFieldValue);\n        });\n        return recordValues;\n    }\n    /**\n     * Converts a record field value to its string representation\n     */\n    function recordFieldValueToString(fieldValue) {\n        const isDate = fieldValue instanceof Date; // store to avoid checking twice\n        if (fieldValue === null || Array.isArray(fieldValue) || typeof fieldValue === 'object' && !isDate) {\n            return JSON.stringify(fieldValue);\n        }\n        else if (typeof fieldValue === 'undefined') {\n            return 'undefined';\n        }\n        else if (isDate && options.useDateIso8601Format) {\n            return fieldValue.toISOString();\n        }\n        else {\n            return !options.useLocaleFormat ? fieldValue.toString() : fieldValue.toLocaleString();\n        }\n    }\n    /**\n     * Trims the record field value, if specified by the user's provided options\n     */\n    function trimRecordFieldValue(fieldValue) {\n        if (options.trimFieldValues) {\n            if (Array.isArray(fieldValue)) {\n                return fieldValue.map(trimRecordFieldValue);\n            }\n            else if (typeof fieldValue === 'string') {\n                return fieldValue.trim();\n            }\n            return fieldValue;\n        }\n        return fieldValue;\n    }\n    /**\n     * Prevent CSV injection on strings if specified by the user's provided options.\n     * Mitigation will be done by ensuring that the first character doesn't being with:\n     * Equals (=), Plus (+), Minus (-), At (@), Tab (0x09), Carriage return (0x0D).\n     * More info: https://owasp.org/www-community/attacks/CSV_Injection\n     */\n    function preventCsvInjection(fieldValue) {\n        if (options.preventCsvInjection) {\n            if (Array.isArray(fieldValue)) {\n                return fieldValue.map(preventCsvInjection);\n            }\n            else if (typeof fieldValue === 'string' && !utils.isNumber(fieldValue)) {\n                return fieldValue.replace(/^[=+\\-@\\t\\r]+/g, '');\n            }\n            return fieldValue;\n        }\n        return fieldValue;\n    }\n    /**\n     * Escapes quotation marks in the field value, if necessary, and appropriately\n     * wraps the record field value if it contains a comma (field delimiter),\n     * quotation mark (wrap delimiter), or a line break (CRLF)\n     */\n    function wrapFieldValueIfNecessary(fieldValue) {\n        const wrapDelimiter = options.delimiter.wrap;\n        // eg. includes quotation marks (default delimiter)\n        if (fieldValue.includes(options.delimiter.wrap)) {\n            // add an additional quotation mark before each quotation mark appearing in the field value\n            fieldValue = fieldValue.replace(wrapDelimiterCheckRegex, wrapDelimiter + wrapDelimiter);\n        }\n        // if the field contains a comma (field delimiter), quotation mark (wrap delimiter), line break, or CRLF\n        //   then enclose it in quotation marks (wrap delimiter)\n        if (fieldValue.includes(options.delimiter.field) ||\n            fieldValue.includes(options.delimiter.wrap) ||\n            fieldValue.match(crlfSearchRegex) ||\n            options.wrapBooleans && (fieldValue === 'true' || fieldValue === 'false')) {\n            // wrap the field's value in a wrap delimiter (quotation marks by default)\n            fieldValue = wrapDelimiter + fieldValue + wrapDelimiter;\n        }\n        return fieldValue;\n    }\n    /**\n     * Generates the CSV record string by joining the field values together by the field delimiter\n     */\n    function generateCsvRowFromRecord(recordFieldValues) {\n        return recordFieldValues.join(options.delimiter.field);\n    }\n    /** CSV COMPONENT COMBINER/FINAL PROCESSOR **/\n    /**\n     * Performs the final CSV construction by combining the fields in the appropriate\n     * order depending on the provided options values and sends the generated CSV\n     * back to the user\n     */\n    function generateCsvFromComponents(params) {\n        const header = params.header, records = params.recordString, \n        // If we are prepending the header, then add an EOL, otherwise just return the records\n        csv = (options.excelBOM ? constants_1.excelBOM : '') +\n            (options.prependHeader ? header + options.delimiter.eol : '') +\n            records;\n        return csv;\n    }\n    /** MAIN CONVERTER FUNCTION **/\n    /**\n     * Internally exported json2csv function\n     */\n    function convert(data) {\n        // Single document, not an array\n        if (!Array.isArray(data)) {\n            data = [data]; // Convert to an array of the given document\n        }\n        // Retrieve the heading and then generate the CSV with the keys that are identified\n        const headerFields = {\n            headerFields: retrieveHeaderFields(data),\n            records: data,\n            header: '',\n            recordString: '',\n        };\n        const unwinded = unwindRecordsIfNecessary(headerFields);\n        const processed = processRecords(unwinded);\n        const wrapped = wrapHeaderFields(processed);\n        const trimmed = trimHeaderFields(wrapped);\n        const generated = generateCsvHeader(trimmed);\n        return generateCsvFromComponents(generated);\n    }\n    return {\n        convert,\n    };\n};\nexports.Json2Csv = Json2Csv;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvanNvbjJjc3YuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixtQkFBbUIsbUJBQU8sQ0FBQywyREFBVTtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxzREFBTztBQUMvQixvQkFBb0IsbUJBQU8sQ0FBQyxxRUFBYTtBQUN6QywyQkFBMkIsbUJBQU8sQ0FBQyw2REFBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLFlBQVk7QUFDM0c7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIkQ6XFxTT1dOX0dJQUlDXFxORVhULVdPUktcXEhBQ0tBVEhPTi0zXFxVSS1VWC1IQUNLQVRIT04tTmV4dEpTLURlc2lnbi1KYW0tMjAyNC0oTVktQ0xPTkUtUFJPSkVDVClcXG5vZGVfbW9kdWxlc1xcanNvbi0yLWNzdlxcbGliXFxqc29uMmNzdi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSnNvbjJDc3YgPSB2b2lkIDA7XG5jb25zdCBkb2NfcGF0aF8xID0gcmVxdWlyZShcImRvYy1wYXRoXCIpO1xuY29uc3QgZGVla3NfMSA9IHJlcXVpcmUoXCJkZWVrc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuY29uc3QgSnNvbjJDc3YgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGNvbnN0IHdyYXBEZWxpbWl0ZXJDaGVja1JlZ2V4ID0gbmV3IFJlZ0V4cChvcHRpb25zLmRlbGltaXRlci53cmFwLCAnZycpLCBjcmxmU2VhcmNoUmVnZXggPSAvXFxyP1xcbnxcXHIvLCBjdXN0b21WYWx1ZVBhcnNlciA9IG9wdGlvbnMucGFyc2VWYWx1ZSAmJiB0eXBlb2Ygb3B0aW9ucy5wYXJzZVZhbHVlID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5wYXJzZVZhbHVlIDogbnVsbCwgZXhwYW5kaW5nV2l0aG91dFVud2luZGluZyA9IG9wdGlvbnMuZXhwYW5kQXJyYXlPYmplY3RzICYmICFvcHRpb25zLnVud2luZEFycmF5cywgZGVla3NPcHRpb25zID0ge1xuICAgICAgICBhcnJheUluZGV4ZXNBc0tleXM6IG9wdGlvbnMuYXJyYXlJbmRleGVzQXNLZXlzLFxuICAgICAgICBleHBhbmROZXN0ZWRPYmplY3RzOiBvcHRpb25zLmV4cGFuZE5lc3RlZE9iamVjdHMsXG4gICAgICAgIGV4cGFuZEFycmF5T2JqZWN0czogZXhwYW5kaW5nV2l0aG91dFVud2luZGluZyxcbiAgICAgICAgaWdub3JlRW1wdHlBcnJheXNXaGVuRXhwYW5kaW5nOiBleHBhbmRpbmdXaXRob3V0VW53aW5kaW5nLFxuICAgICAgICBlc2NhcGVOZXN0ZWREb3RzOiB0cnVlLFxuICAgIH07XG4gICAgLyoqIEhFQURFUiBGSUVMRCBGVU5DVElPTlMgKiovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBkYXRhIGZpZWxkIG5hbWVzIG9mIGFsbCBkb2N1bWVudHMgaW4gdGhlIHByb3ZpZGVkIGxpc3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGaWVsZE5hbWVMaXN0KGRhdGEpIHtcbiAgICAgICAgLy8gSWYga2V5cyB3ZXJlbid0IHNwZWNpZmllZCwgdGhlbiB3ZSdsbCB1c2UgdGhlIGxpc3Qgb2Yga2V5cyBnZW5lcmF0ZWQgYnkgdGhlIGRlZWtzIG1vZHVsZVxuICAgICAgICByZXR1cm4gKDAsIGRlZWtzXzEuZGVlcEtleXNGcm9tTGlzdCkoZGF0YSwgZGVla3NPcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIHRoZSBzY2hlbWFzIGJ5IGNoZWNraW5nIGZvciBzY2hlbWEgZGlmZmVyZW5jZXMsIGlmIHNvIGRlc2lyZWQuXG4gICAgICogSWYgc2NoZW1hIGRpZmZlcmVuY2VzIGFyZSBub3QgdG8gYmUgY2hlY2tlZCwgdGhlbiBpdCByZXNvbHZlcyB0aGUgdW5pcXVlXG4gICAgICogbGlzdCBvZiBmaWVsZCBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzU2NoZW1hcyhkb2N1bWVudFNjaGVtYXMpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGRvY3VtZW50IHNjaGVtYXMgdGhlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGRpZmYgYW5kIG5vIHVuaXF1ZSBmaWVsZHMgdG8gZ2V0XG4gICAgICAgIGlmIChkb2N1bWVudFNjaGVtYXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgd2FudHMgdG8gY2hlY2sgZm9yIHRoZSBzYW1lIHNjaGVtYSAocmVnYXJkbGVzcyBvZiBzY2hlbWEgb3JkZXJpbmcpXG4gICAgICAgIGlmIChvcHRpb25zLmNoZWNrU2NoZW1hRGlmZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja1NjaGVtYURpZmZlcmVuY2VzKGRvY3VtZW50U2NoZW1hcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIGRvIG5vdCBjYXJlIGlmIHRoZSBzY2hlbWFzIGFyZSBkaWZmZXJlbnQsIHNvIHdlIHNob3VsZCBnZXQgdGhlIHVuaXF1ZSBsaXN0IG9mIGtleXNcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZUZpZWxkTmFtZXMgPSB1dGlscy51bmlxdWUodXRpbHMuZmxhdHRlbihkb2N1bWVudFNjaGVtYXMpKTtcbiAgICAgICAgICAgIHJldHVybiB1bmlxdWVGaWVsZE5hbWVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcGVyZm9ybXMgdGhlIHNjaGVtYSBkaWZmZXJlbmNlIGNoZWNrLCBpZiB0aGUgdXNlciBzcGVjaWZpZXMgdGhhdCBpdCBzaG91bGQgYmUgY2hlY2tlZC5cbiAgICAgKiBJZiB0aGVyZSBhcmUgbm8gZmllbGQgbmFtZXMsIHRoZW4gdGhlcmUgYXJlIG5vIGRpZmZlcmVuY2VzLlxuICAgICAqIE90aGVyd2lzZSwgd2UgZ2V0IHRoZSBmaXJzdCBzY2hlbWEgYW5kIHRoZSByZW1haW5pbmcgbGlzdCBvZiBzY2hlbWFzXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hlY2tTY2hlbWFEaWZmZXJlbmNlcyhkb2N1bWVudFNjaGVtYXMpIHtcbiAgICAgICAgLy8gaGF2ZSBtdWx0aXBsZSBkb2N1bWVudHMgLSBlbnN1cmUgb25seSBvbmUgc2NoZW1hIChyZWdhcmRsZXNzIG9mIGZpZWxkIG9yZGVyaW5nKVxuICAgICAgICBjb25zdCBmaXJzdERvY1NjaGVtYSA9IGRvY3VtZW50U2NoZW1hc1swXSwgcmVzdE9mRG9jdW1lbnRTY2hlbWFzID0gZG9jdW1lbnRTY2hlbWFzLnNsaWNlKDEpLCBzY2hlbWFEaWZmZXJlbmNlcyA9IGNvbXB1dGVOdW1iZXJPZlNjaGVtYURpZmZlcmVuY2VzKGZpcnN0RG9jU2NoZW1hLCByZXN0T2ZEb2N1bWVudFNjaGVtYXMpO1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgc2NoZW1hIGluY29uc2lzdGVuY2llcywgdGhyb3cgYSBzY2hlbWEgbm90IHRoZSBzYW1lIGVycm9yXG4gICAgICAgIGlmIChzY2hlbWFEaWZmZXJlbmNlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNvbnN0YW50c18xLmVycm9ycy5qc29uMmNzdi5ub3RTYW1lU2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlyc3REb2NTY2hlbWE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBudW1iZXIgb2Ygc2NoZW1hIGRpZmZlcmVuY2VzXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcHV0ZU51bWJlck9mU2NoZW1hRGlmZmVyZW5jZXMoZmlyc3REb2NTY2hlbWEsIHJlc3RPZkRvY3VtZW50U2NoZW1hcykge1xuICAgICAgICByZXR1cm4gcmVzdE9mRG9jdW1lbnRTY2hlbWFzLnJlZHVjZSgoc2NoZW1hRGlmZmVyZW5jZXMsIGRvY3VtZW50U2NoZW1hKSA9PiB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc2NoZW1hcywgaW5jcmVtZW50IHRoZSBjb3VudGVyIG9mIHNjaGVtYSBpbmNvbnNpc3RlbmNpZXNcbiAgICAgICAgICAgIGNvbnN0IG51bWJlck9mRGlmZmVyZW5jZXMgPSB1dGlscy5jb21wdXRlU2NoZW1hRGlmZmVyZW5jZXMoZmlyc3REb2NTY2hlbWEsIGRvY3VtZW50U2NoZW1hKS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyT2ZEaWZmZXJlbmNlcyA+IDBcbiAgICAgICAgICAgICAgICA/IHNjaGVtYURpZmZlcmVuY2VzICsgMVxuICAgICAgICAgICAgICAgIDogc2NoZW1hRGlmZmVyZW5jZXM7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBzbyBzcGVjaWZpZWQsIHRoaXMgZmlsdGVycyB0aGUgZGV0ZWN0ZWQga2V5IHBhdGhzIHRvIGV4Y2x1ZGUgYW55IGtleXMgdGhhdCBoYXZlIGJlZW4gc3BlY2lmaWVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyRXhjbHVkZWRLZXlzKGtleVBhdGhzKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmV4Y2x1ZGVLZXlzKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5UGF0aHMuZmlsdGVyKChrZXlQYXRoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBleGNsdWRlZEtleSBvZiBvcHRpb25zLmV4Y2x1ZGVLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgbWF0Y2ggaWYgdGhlIGV4Y2x1ZGVkS2V5IGFwcGVhcnMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgc3RyaW5nIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBtYXRjaCBhIGtleSBmYXJ0aGVyIGRvd24gaW4gYSBrZXkgcGF0aFxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGV4Y2x1ZGVkS2V5IGluc3RhbmNlb2YgUmVnRXhwID8gZXhjbHVkZWRLZXkgOiBuZXcgUmVnRXhwKGBeJHtleGNsdWRlZEtleX1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVkS2V5ID09PSBrZXlQYXRoIHx8IGtleVBhdGgubWF0Y2gocmVnZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEV4Y2x1ZGUgdGhlIGtleVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBPdGhlcndpc2UsIGluY2x1ZGUgdGhlIGtleVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleVBhdGhzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBzbyBzcGVjaWZpZWQsIHRoaXMgc29ydHMgdGhlIGhlYWRlciBmaWVsZCBuYW1lcyBhbHBoYWJldGljYWxseVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRIZWFkZXJGaWVsZHMoZmllbGROYW1lcykge1xuICAgICAgICBpZiAob3B0aW9ucy5zb3J0SGVhZGVyICYmIHR5cGVvZiBvcHRpb25zLnNvcnRIZWFkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZE5hbWVzLnNvcnQob3B0aW9ucy5zb3J0SGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLnNvcnRIZWFkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZE5hbWVzLnNvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGROYW1lcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpbXMgdGhlIGhlYWRlciBmaWVsZHMsIGlmIHRoZSB1c2VyIGRlc2lyZXMgdGhlbSB0byBiZSB0cmltbWVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1IZWFkZXJGaWVsZHMocGFyYW1zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnRyaW1IZWFkZXJGaWVsZHMpIHtcbiAgICAgICAgICAgIHBhcmFtcy5oZWFkZXJGaWVsZHMgPSBwYXJhbXMuaGVhZGVyRmllbGRzLm1hcCgoZmllbGQpID0+IGZpZWxkLnNwbGl0KCcuJylcbiAgICAgICAgICAgICAgICAubWFwKChjb21wb25lbnQpID0+IGNvbXBvbmVudC50cmltKCkpXG4gICAgICAgICAgICAgICAgLmpvaW4oJy4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JhcCB0aGUgaGVhZGluZ3MsIGlmIGRlc2lyZWQgYnkgdGhlIHVzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcEhlYWRlckZpZWxkcyhwYXJhbXMpIHtcbiAgICAgICAgLy8gb25seSBwZXJmb3JtIHRoaXMgaWYgd2UgYXJlIGFjdHVhbGx5IHByZXBlbmRpbmcgdGhlIGhlYWRlclxuICAgICAgICBpZiAob3B0aW9ucy5wcmVwZW5kSGVhZGVyKSB7XG4gICAgICAgICAgICBwYXJhbXMuaGVhZGVyRmllbGRzID0gcGFyYW1zLmhlYWRlckZpZWxkcy5tYXAoZnVuY3Rpb24gKGhlYWRpbmdLZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcEZpZWxkVmFsdWVJZk5lY2Vzc2FyeShoZWFkaW5nS2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgQ1NWIGhlYWRlciBzdHJpbmcgYnkgam9pbmluZyB0aGUgaGVhZGVyRmllbGRzIGJ5IHRoZSBmaWVsZCBkZWxpbWl0ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNzdkhlYWRlcihwYXJhbXMpIHtcbiAgICAgICAgLy8gIzE4NSAtIGdlbmVyYXRlIGEga2V5cyBsaXN0IHRvIGF2b2lkIGZpbmRpbmcgbmF0aXZlIE1hcCgpIG1ldGhvZHNcbiAgICAgICAgY29uc3QgZmllbGRUaXRsZU1hcEtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zLmZpZWxkVGl0bGVNYXApO1xuICAgICAgICBwYXJhbXMuaGVhZGVyID0gcGFyYW1zLmhlYWRlckZpZWxkc1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgIGxldCBoZWFkZXJLZXkgPSBmaWVsZDtcbiAgICAgICAgICAgIC8vIElmIGEgY3VzdG9tIGZpZWxkIHRpdGxlIHdhcyBwcm92aWRlZCBmb3IgdGhpcyBmaWVsZCwgdXNlIHRoYXRcbiAgICAgICAgICAgIGlmIChmaWVsZFRpdGxlTWFwS2V5cy5pbmNsdWRlcyhmaWVsZCkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJLZXkgPSBvcHRpb25zLmZpZWxkVGl0bGVNYXBbZmllbGRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIW9wdGlvbnMuZXNjYXBlSGVhZGVyTmVzdGVkRG90cykge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlIHVzZXIgZG9lc24ndCB3YW50IG5lc3RlZCBkb3RzIGluIGtleXMgdG8gYmUgZXNjYXBlZCwgdGhlbiB1bmVzY2FwZSB0aGVtXG4gICAgICAgICAgICAgICAgaGVhZGVyS2V5ID0gaGVhZGVyS2V5LnJlcGxhY2UoL1xcXFxcXC4vZywgJy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJLZXk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbihvcHRpb25zLmRlbGltaXRlci5maWVsZCk7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRLZXlzVG9IZWFkZXJGaWVsZHMoKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5rZXlzKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5rZXlzLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgJiYgJ2ZpZWxkJyBpbiBrZXkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZpZWxkVGl0bGVNYXBba2V5LmZpZWxkXSA9IGtleS50aXRsZSA/PyBrZXkuZmllbGQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleS5maWVsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBleHRyYWN0V2lsZGNhcmRNYXRjaEtleXMoKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5rZXlzKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5rZXlzLmZsYXRNYXAoaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjbHVkZSBwbGFpbiBzdHJpbmdzIHRoYXQgd2VyZSBwYXNzZWQgaW4gb3B0aW9ucy5rZXlzXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbT8ud2lsZGNhcmRNYXRjaCkge1xuICAgICAgICAgICAgICAgIC8vIFJldHVybiBcImZpZWxkXCIgdmFsdWUgZm9yIG9iamVjdHMgd2l0aCB3aWxkY2FyZE1hdGNoOiB0cnVlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFeGNsdWRlIG90aGVyIG9iamVjdHNcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBoZWFkaW5ncyBmb3IgYWxsIGRvY3VtZW50cyBhbmQgcmV0dXJuIGl0LlxuICAgICAqIFRoaXMgY2hlY2tzIHRoYXQgYWxsIGRvY3VtZW50cyBoYXZlIHRoZSBzYW1lIHNjaGVtYS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXRyaWV2ZUhlYWRlckZpZWxkcyhkYXRhKSB7XG4gICAgICAgIGNvbnN0IHdpbGRjYXJkTWF0Y2hLZXlzID0gZXh0cmFjdFdpbGRjYXJkTWF0Y2hLZXlzKCk7XG4gICAgICAgIGNvbnN0IGtleVN0cmluZ3MgPSBjb252ZXJ0S2V5c1RvSGVhZGVyRmllbGRzKCk7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBnZXRGaWVsZE5hbWVMaXN0KGRhdGEpO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBwcm9jZXNzU2NoZW1hcyhmaWVsZE5hbWVzKTtcbiAgICAgICAgaWYgKG9wdGlvbnMua2V5cykge1xuICAgICAgICAgICAgb3B0aW9ucy5rZXlzID0ga2V5U3RyaW5ncztcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZWRLZXlzID0ga2V5U3RyaW5ncy5mbGF0TWFwKCh1c2VyUHJvdmlkZWRLZXkpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCBhIHdpbGRjYXJkIG1hdGNoZWQga2V5LCB0aGVuIGp1c3QgcmV0dXJuIGFuZCBpbmNsdWRlIGl0IGluIHRoZSByZXN1bHRpbmcga2V5IGxpc3RcbiAgICAgICAgICAgICAgICBpZiAoIXdpbGRjYXJkTWF0Y2hLZXlzLmluY2x1ZGVzKHVzZXJQcm92aWRlZEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVzZXJQcm92aWRlZEtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZGVudGlmeSBhbGwgZGV0ZWN0ZWQga2V5cyB0aGF0IG1hdGNoIHdpdGggdGhlIHByb3ZpZGVkIHdpbGRjYXJkIGtleTpcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBeJHt1c2VyUHJvdmlkZWRLZXl9YCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZXRlY3RlZEtleSBvZiBwcm9jZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJQcm92aWRlZEtleSA9PT0gZGV0ZWN0ZWRLZXkgfHwgZGV0ZWN0ZWRLZXkubWF0Y2gocmVnZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goZGV0ZWN0ZWRLZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMudW53aW5kQXJyYXlzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBmaWx0ZXJFeGNsdWRlZEtleXMobWF0Y2hlZEtleXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzb3J0SGVhZGVyRmllbGRzKGZpbHRlcmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IGZpbHRlckV4Y2x1ZGVkS2V5cyhwcm9jZXNzZWQpO1xuICAgICAgICByZXR1cm4gc29ydEhlYWRlckZpZWxkcyhmaWx0ZXJlZCk7XG4gICAgfVxuICAgIC8qKiBSRUNPUkQgRklFTEQgRlVOQ1RJT05TICoqL1xuICAgIC8qKlxuICAgICAqIFVud2luZHMgb2JqZWN0cyBpbiBhcnJheXMgd2l0aGluIHJlY29yZCBvYmplY3RzIGlmIHRoZSB1c2VyIHNwZWNpZmllcyB0aGVcbiAgICAgKiBleHBhbmRBcnJheU9iamVjdHMgb3B0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGlzIHBhc3NlcyB0aGUgcGFyYW1zXG4gICAgICogYXJndW1lbnQgdGhyb3VnaCB0byB0aGUgbmV4dCBmdW5jdGlvbiBpbiB0aGUgcHJvbWlzZSBjaGFpbi5cbiAgICAgKlxuICAgICAqIFRoZSBgZmluYWxQYXNzYCBwYXJhbWV0ZXIgaXMgdXNlZCB0byB0cmlnZ2VyIG9uZSBsYXN0IHBhc3MgdG8gZW5zdXJlIG5vIG1vcmVcbiAgICAgKiBhcnJheXMgbmVlZCB0byBiZSBleHBhbmRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVud2luZFJlY29yZHNJZk5lY2Vzc2FyeShwYXJhbXMsIGZpbmFsUGFzcyA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnVud2luZEFycmF5cykge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxSZWNvcmRzTGVuZ3RoID0gcGFyYW1zLnJlY29yZHMubGVuZ3RoO1xuICAgICAgICAgICAgLy8gVW53aW5kIGVhY2ggb2YgdGhlIGRvY3VtZW50cyBhdCB0aGUgZ2l2ZW4gaGVhZGVyRmllbGRcbiAgICAgICAgICAgIHBhcmFtcy5oZWFkZXJGaWVsZHMuZm9yRWFjaCgoaGVhZGVyRmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucmVjb3JkcyA9IHV0aWxzLnVud2luZChwYXJhbXMucmVjb3JkcywgaGVhZGVyRmllbGQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJGaWVsZHMgPSByZXRyaWV2ZUhlYWRlckZpZWxkcyhwYXJhbXMucmVjb3Jkcyk7XG4gICAgICAgICAgICBwYXJhbXMuaGVhZGVyRmllbGRzID0gaGVhZGVyRmllbGRzO1xuICAgICAgICAgICAgLy8gSWYgd2Ugd2VyZSBhYmxlIHRvIHVud2luZCBtb3JlIGFycmF5cywgdGhlbiB0cnkgdW53aW5kaW5nIGFnYWluLi4uXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxSZWNvcmRzTGVuZ3RoICE9PSBwYXJhbXMucmVjb3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW53aW5kUmVjb3Jkc0lmTmVjZXNzYXJ5KHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIGRpZG4ndCB1bndpbmQgYW55IGFkZGl0aW9uYWwgYXJyYXlzLCBzbyBjb250aW51ZS4uLlxuICAgICAgICAgICAgLy8gUnVuIGEgZmluYWwgdGltZSBpbiBjYXNlIHRoZSBlYXJsaWVyIHVud2luZGluZyBleHBvc2VkIGFkZGl0aW9uYWxcbiAgICAgICAgICAgIC8vIGFycmF5cyB0byB1bndpbmQuLi5cbiAgICAgICAgICAgIGlmICghZmluYWxQYXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVud2luZFJlY29yZHNJZk5lY2Vzc2FyeShwYXJhbXMsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYga2V5cyB3ZXJlIHByb3ZpZGVkLCBzZXQgdGhlIGhlYWRlckZpZWxkcyBiYWNrIHRvIHRoZSBwcm92aWRlZCBrZXlzIGFmdGVyIHVud2luZGluZzpcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1c2VyU2VsZWN0ZWRGaWVsZHMgPSBjb252ZXJ0S2V5c1RvSGVhZGVyRmllbGRzKCk7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmhlYWRlckZpZWxkcyA9IGZpbHRlckV4Y2x1ZGVkS2V5cyh1c2VyU2VsZWN0ZWRGaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWluIGZ1bmN0aW9uIHdoaWNoIGhhbmRsZXMgdGhlIHByb2Nlc3Npbmcgb2YgYSByZWNvcmQsIG9yIGRvY3VtZW50IHRvIGJlIGNvbnZlcnRlZCB0byBDU1YgZm9ybWF0XG4gICAgICogVGhpcyBmdW5jdGlvbiBzcGVjaWZpZXMgYW5kIHBlcmZvcm1zIHRoZSBuZWNlc3Nhcnkgb3BlcmF0aW9ucyBpbiB0aGUgbmVjZXNzYXJ5IG9yZGVyXG4gICAgICogaW4gb3JkZXIgdG8gb2J0YWluIHRoZSBkYXRhIGFuZCBjb252ZXJ0IGl0IHRvIENTViBmb3JtIHdoaWxlIG1haW50YWluaW5nIFJGQyA0MTgwIGNvbXBsaWFuY2UuXG4gICAgICogKiBPcmRlciBvZiBvcGVyYXRpb25zOlxuICAgICAqIC0gR2V0IGZpZWxkcyBmcm9tIHByb3ZpZGVkIGtleSBsaXN0IChhcyBhcnJheSBvZiBhY3R1YWwgdmFsdWVzKVxuICAgICAqIC0gQ29udmVydCB0aGUgdmFsdWVzIHRvIGNzdi9zdHJpbmcgcmVwcmVzZW50YXRpb24gW3Bvc3NpYmxlIG9wdGlvbiBoZXJlIGZvciBjdXN0b20gY29udmVydGVycz9dXG4gICAgICogLSBUcmltIGZpZWxkc1xuICAgICAqIC0gRGV0ZXJtaW5lIGlmIHRoZXkgbmVlZCB0byBiZSB3cmFwcGVkICgmIHdyYXAgaWYgbmVjZXNzYXJ5KVxuICAgICAqIC0gQ29tYmluZSB2YWx1ZXMgZm9yIGVhY2ggbGluZSAoYnkgam9pbmluZyBieSBmaWVsZCBkZWxpbWl0ZXIpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1JlY29yZHMocGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcy5yZWNvcmRTdHJpbmcgPSBwYXJhbXMucmVjb3Jkcy5tYXAoKHJlY29yZCkgPT4ge1xuICAgICAgICAgICAgLy8gUmV0cmlldmUgZGF0YSBmb3IgZWFjaCBvZiB0aGUgaGVhZGVyRmllbGRzIGZyb20gdGhpcyByZWNvcmRcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZEZpZWxkRGF0YSA9IHJldHJpZXZlUmVjb3JkRmllbGREYXRhKHJlY29yZCwgcGFyYW1zLmhlYWRlckZpZWxkcyksIFxuICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgZGF0YSBpbiB0aGlzIHJlY29yZCBhbmQgcmV0dXJuIHRoZVxuICAgICAgICAgICAgcHJvY2Vzc2VkUmVjb3JkRGF0YSA9IHJlY29yZEZpZWxkRGF0YS5tYXAoKGZpZWxkVmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlID0gdHJpbVJlY29yZEZpZWxkVmFsdWUoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9IHByZXZlbnRDc3ZJbmplY3Rpb24oZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgbGV0IHN0cmluZ2lmaWVkID0gY3VzdG9tVmFsdWVQYXJzZXIgPyBjdXN0b21WYWx1ZVBhcnNlcihmaWVsZFZhbHVlLCByZWNvcmRGaWVsZFZhbHVlVG9TdHJpbmcpIDogcmVjb3JkRmllbGRWYWx1ZVRvU3RyaW5nKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVkID0gd3JhcEZpZWxkVmFsdWVJZk5lY2Vzc2FyeShzdHJpbmdpZmllZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmaWVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBKb2luIHRoZSByZWNvcmQgZGF0YSBieSB0aGUgZmllbGQgZGVsaW1pdGVyXG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVDc3ZSb3dGcm9tUmVjb3JkKHByb2Nlc3NlZFJlY29yZERhdGEpO1xuICAgICAgICB9KS5qb2luKG9wdGlvbnMuZGVsaW1pdGVyLmVvbCk7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiBpbnRlbmRlZCB0byBwcm9jZXNzICpqdXN0KiBhcnJheSB2YWx1ZXMgd2hlbiB0aGUgZXhwYW5kQXJyYXlPYmplY3RzIHNldHRpbmcgaXMgc2V0IHRvIHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzUmVjb3JkRmllbGREYXRhRm9yRXhwYW5kZWRBcnJheU9iamVjdChyZWNvcmRGaWVsZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkUmVjb3JkRmllbGRWYWx1ZSA9IHV0aWxzLnJlbW92ZUVtcHR5RmllbGRzKHJlY29yZEZpZWxkVmFsdWUpO1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGFycmF5IGFuZCBpdCdzIGVpdGhlciBlbXB0eSBvZiBmdWxsIG9mIGVtcHR5IHZhbHVlcywgdGhlbiB1c2UgYW4gZW1wdHkgdmFsdWUgcmVwcmVzZW50YXRpb25cbiAgICAgICAgaWYgKCFyZWNvcmRGaWVsZFZhbHVlLmxlbmd0aCB8fCAhZmlsdGVyZWRSZWNvcmRGaWVsZFZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZW1wdHlGaWVsZFZhbHVlIHx8ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpbHRlcmVkUmVjb3JkRmllbGRWYWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgaGF2ZSBhbiBhcnJheSBvZiBhY3R1YWwgdmFsdWVzLi4uXG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSBhcmUgZXhwYW5kaW5nIGFycmF5IG9iamVjdHMsIHdlIHdpbGwgd2FudCB0byBrZXkgaW4gb24gdmFsdWVzIG9mIG9iamVjdHMuXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWRSZWNvcmRGaWVsZFZhbHVlWzBdOyAvLyBFeHRyYWN0IHRoZSBzaW5nbGUgdmFsdWUgaW4gdGhlIGFycmF5XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY29yZEZpZWxkVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGZpZWxkIHZhbHVlcyBmcm9tIGEgcGFydGljdWxhciByZWNvcmQgZm9yIHRoZSBnaXZlbiBsaXN0IG9mIGZpZWxkc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJldHJpZXZlUmVjb3JkRmllbGREYXRhKHJlY29yZCwgZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IHJlY29yZFZhbHVlcyA9IFtdO1xuICAgICAgICBmaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgIGxldCByZWNvcmRGaWVsZFZhbHVlID0gKDAsIGRvY19wYXRoXzEuZXZhbHVhdGVQYXRoKShyZWNvcmQsIGZpZWxkKTtcbiAgICAgICAgICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQob3B0aW9ucy5lbXB0eUZpZWxkVmFsdWUpICYmIHV0aWxzLmlzRW1wdHlGaWVsZChyZWNvcmRGaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJlY29yZEZpZWxkVmFsdWUgPSBvcHRpb25zLmVtcHR5RmllbGRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZXhwYW5kQXJyYXlPYmplY3RzICYmIEFycmF5LmlzQXJyYXkocmVjb3JkRmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZWNvcmRGaWVsZFZhbHVlID0gcHJvY2Vzc1JlY29yZEZpZWxkRGF0YUZvckV4cGFuZGVkQXJyYXlPYmplY3QocmVjb3JkRmllbGRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWNvcmRWYWx1ZXMucHVzaChyZWNvcmRGaWVsZFZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZWNvcmRWYWx1ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgcmVjb3JkIGZpZWxkIHZhbHVlIHRvIGl0cyBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWNvcmRGaWVsZFZhbHVlVG9TdHJpbmcoZmllbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCBpc0RhdGUgPSBmaWVsZFZhbHVlIGluc3RhbmNlb2YgRGF0ZTsgLy8gc3RvcmUgdG8gYXZvaWQgY2hlY2tpbmcgdHdpY2VcbiAgICAgICAgaWYgKGZpZWxkVmFsdWUgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShmaWVsZFZhbHVlKSB8fCB0eXBlb2YgZmllbGRWYWx1ZSA9PT0gJ29iamVjdCcgJiYgIWlzRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGZpZWxkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmaWVsZFZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRGF0ZSAmJiBvcHRpb25zLnVzZURhdGVJc284NjAxRm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZS50b0lTT1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICFvcHRpb25zLnVzZUxvY2FsZUZvcm1hdCA/IGZpZWxkVmFsdWUudG9TdHJpbmcoKSA6IGZpZWxkVmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmltcyB0aGUgcmVjb3JkIGZpZWxkIHZhbHVlLCBpZiBzcGVjaWZpZWQgYnkgdGhlIHVzZXIncyBwcm92aWRlZCBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbVJlY29yZEZpZWxkVmFsdWUoZmllbGRWYWx1ZSkge1xuICAgICAgICBpZiAob3B0aW9ucy50cmltRmllbGRWYWx1ZXMpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWUubWFwKHRyaW1SZWNvcmRGaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmaWVsZFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWVsZFZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmV2ZW50IENTViBpbmplY3Rpb24gb24gc3RyaW5ncyBpZiBzcGVjaWZpZWQgYnkgdGhlIHVzZXIncyBwcm92aWRlZCBvcHRpb25zLlxuICAgICAqIE1pdGlnYXRpb24gd2lsbCBiZSBkb25lIGJ5IGVuc3VyaW5nIHRoYXQgdGhlIGZpcnN0IGNoYXJhY3RlciBkb2Vzbid0IGJlaW5nIHdpdGg6XG4gICAgICogRXF1YWxzICg9KSwgUGx1cyAoKyksIE1pbnVzICgtKSwgQXQgKEApLCBUYWIgKDB4MDkpLCBDYXJyaWFnZSByZXR1cm4gKDB4MEQpLlxuICAgICAqIE1vcmUgaW5mbzogaHR0cHM6Ly9vd2FzcC5vcmcvd3d3LWNvbW11bml0eS9hdHRhY2tzL0NTVl9JbmplY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcmV2ZW50Q3N2SW5qZWN0aW9uKGZpZWxkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucHJldmVudENzdkluamVjdGlvbikge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZS5tYXAocHJldmVudENzdkluamVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZmllbGRWYWx1ZSA9PT0gJ3N0cmluZycgJiYgIXV0aWxzLmlzTnVtYmVyKGZpZWxkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWUucmVwbGFjZSgvXls9K1xcLUBcXHRcXHJdKy9nLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXNjYXBlcyBxdW90YXRpb24gbWFya3MgaW4gdGhlIGZpZWxkIHZhbHVlLCBpZiBuZWNlc3NhcnksIGFuZCBhcHByb3ByaWF0ZWx5XG4gICAgICogd3JhcHMgdGhlIHJlY29yZCBmaWVsZCB2YWx1ZSBpZiBpdCBjb250YWlucyBhIGNvbW1hIChmaWVsZCBkZWxpbWl0ZXIpLFxuICAgICAqIHF1b3RhdGlvbiBtYXJrICh3cmFwIGRlbGltaXRlciksIG9yIGEgbGluZSBicmVhayAoQ1JMRilcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwRmllbGRWYWx1ZUlmTmVjZXNzYXJ5KGZpZWxkVmFsdWUpIHtcbiAgICAgICAgY29uc3Qgd3JhcERlbGltaXRlciA9IG9wdGlvbnMuZGVsaW1pdGVyLndyYXA7XG4gICAgICAgIC8vIGVnLiBpbmNsdWRlcyBxdW90YXRpb24gbWFya3MgKGRlZmF1bHQgZGVsaW1pdGVyKVxuICAgICAgICBpZiAoZmllbGRWYWx1ZS5pbmNsdWRlcyhvcHRpb25zLmRlbGltaXRlci53cmFwKSkge1xuICAgICAgICAgICAgLy8gYWRkIGFuIGFkZGl0aW9uYWwgcXVvdGF0aW9uIG1hcmsgYmVmb3JlIGVhY2ggcXVvdGF0aW9uIG1hcmsgYXBwZWFyaW5nIGluIHRoZSBmaWVsZCB2YWx1ZVxuICAgICAgICAgICAgZmllbGRWYWx1ZSA9IGZpZWxkVmFsdWUucmVwbGFjZSh3cmFwRGVsaW1pdGVyQ2hlY2tSZWdleCwgd3JhcERlbGltaXRlciArIHdyYXBEZWxpbWl0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBmaWVsZCBjb250YWlucyBhIGNvbW1hIChmaWVsZCBkZWxpbWl0ZXIpLCBxdW90YXRpb24gbWFyayAod3JhcCBkZWxpbWl0ZXIpLCBsaW5lIGJyZWFrLCBvciBDUkxGXG4gICAgICAgIC8vICAgdGhlbiBlbmNsb3NlIGl0IGluIHF1b3RhdGlvbiBtYXJrcyAod3JhcCBkZWxpbWl0ZXIpXG4gICAgICAgIGlmIChmaWVsZFZhbHVlLmluY2x1ZGVzKG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkKSB8fFxuICAgICAgICAgICAgZmllbGRWYWx1ZS5pbmNsdWRlcyhvcHRpb25zLmRlbGltaXRlci53cmFwKSB8fFxuICAgICAgICAgICAgZmllbGRWYWx1ZS5tYXRjaChjcmxmU2VhcmNoUmVnZXgpIHx8XG4gICAgICAgICAgICBvcHRpb25zLndyYXBCb29sZWFucyAmJiAoZmllbGRWYWx1ZSA9PT0gJ3RydWUnIHx8IGZpZWxkVmFsdWUgPT09ICdmYWxzZScpKSB7XG4gICAgICAgICAgICAvLyB3cmFwIHRoZSBmaWVsZCdzIHZhbHVlIGluIGEgd3JhcCBkZWxpbWl0ZXIgKHF1b3RhdGlvbiBtYXJrcyBieSBkZWZhdWx0KVxuICAgICAgICAgICAgZmllbGRWYWx1ZSA9IHdyYXBEZWxpbWl0ZXIgKyBmaWVsZFZhbHVlICsgd3JhcERlbGltaXRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHRoZSBDU1YgcmVjb3JkIHN0cmluZyBieSBqb2luaW5nIHRoZSBmaWVsZCB2YWx1ZXMgdG9nZXRoZXIgYnkgdGhlIGZpZWxkIGRlbGltaXRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQ3N2Um93RnJvbVJlY29yZChyZWNvcmRGaWVsZFZhbHVlcykge1xuICAgICAgICByZXR1cm4gcmVjb3JkRmllbGRWYWx1ZXMuam9pbihvcHRpb25zLmRlbGltaXRlci5maWVsZCk7XG4gICAgfVxuICAgIC8qKiBDU1YgQ09NUE9ORU5UIENPTUJJTkVSL0ZJTkFMIFBST0NFU1NPUiAqKi9cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgZmluYWwgQ1NWIGNvbnN0cnVjdGlvbiBieSBjb21iaW5pbmcgdGhlIGZpZWxkcyBpbiB0aGUgYXBwcm9wcmlhdGVcbiAgICAgKiBvcmRlciBkZXBlbmRpbmcgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMgdmFsdWVzIGFuZCBzZW5kcyB0aGUgZ2VuZXJhdGVkIENTVlxuICAgICAqIGJhY2sgdG8gdGhlIHVzZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNzdkZyb21Db21wb25lbnRzKHBhcmFtcykge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBwYXJhbXMuaGVhZGVyLCByZWNvcmRzID0gcGFyYW1zLnJlY29yZFN0cmluZywgXG4gICAgICAgIC8vIElmIHdlIGFyZSBwcmVwZW5kaW5nIHRoZSBoZWFkZXIsIHRoZW4gYWRkIGFuIEVPTCwgb3RoZXJ3aXNlIGp1c3QgcmV0dXJuIHRoZSByZWNvcmRzXG4gICAgICAgIGNzdiA9IChvcHRpb25zLmV4Y2VsQk9NID8gY29uc3RhbnRzXzEuZXhjZWxCT00gOiAnJykgK1xuICAgICAgICAgICAgKG9wdGlvbnMucHJlcGVuZEhlYWRlciA/IGhlYWRlciArIG9wdGlvbnMuZGVsaW1pdGVyLmVvbCA6ICcnKSArXG4gICAgICAgICAgICByZWNvcmRzO1xuICAgICAgICByZXR1cm4gY3N2O1xuICAgIH1cbiAgICAvKiogTUFJTiBDT05WRVJURVIgRlVOQ1RJT04gKiovXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWxseSBleHBvcnRlZCBqc29uMmNzdiBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnZlcnQoZGF0YSkge1xuICAgICAgICAvLyBTaW5nbGUgZG9jdW1lbnQsIG5vdCBhbiBhcnJheVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07IC8vIENvbnZlcnQgdG8gYW4gYXJyYXkgb2YgdGhlIGdpdmVuIGRvY3VtZW50XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0cmlldmUgdGhlIGhlYWRpbmcgYW5kIHRoZW4gZ2VuZXJhdGUgdGhlIENTViB3aXRoIHRoZSBrZXlzIHRoYXQgYXJlIGlkZW50aWZpZWRcbiAgICAgICAgY29uc3QgaGVhZGVyRmllbGRzID0ge1xuICAgICAgICAgICAgaGVhZGVyRmllbGRzOiByZXRyaWV2ZUhlYWRlckZpZWxkcyhkYXRhKSxcbiAgICAgICAgICAgIHJlY29yZHM6IGRhdGEsXG4gICAgICAgICAgICBoZWFkZXI6ICcnLFxuICAgICAgICAgICAgcmVjb3JkU3RyaW5nOiAnJyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdW53aW5kZWQgPSB1bndpbmRSZWNvcmRzSWZOZWNlc3NhcnkoaGVhZGVyRmllbGRzKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gcHJvY2Vzc1JlY29yZHModW53aW5kZWQpO1xuICAgICAgICBjb25zdCB3cmFwcGVkID0gd3JhcEhlYWRlckZpZWxkcyhwcm9jZXNzZWQpO1xuICAgICAgICBjb25zdCB0cmltbWVkID0gdHJpbUhlYWRlckZpZWxkcyh3cmFwcGVkKTtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGVkID0gZ2VuZXJhdGVDc3ZIZWFkZXIodHJpbW1lZCk7XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZUNzdkZyb21Db21wb25lbnRzKGdlbmVyYXRlZCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnZlcnQsXG4gICAgfTtcbn07XG5leHBvcnRzLkpzb24yQ3N2ID0gSnNvbjJDc3Y7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/json-2-csv/lib/json2csv.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/json-2-csv/lib/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/json-2-csv/lib/utils.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isInvalid = exports.flatten = exports.unique = exports.arrayDifference = exports.isError = exports.isUndefined = exports.isNull = exports.isObject = exports.isString = exports.isNumber = exports.unwind = exports.getNCharacters = exports.removeEmptyFields = exports.isEmptyField = exports.computeSchemaDifferences = exports.isDateRepresentation = exports.isStringRepresentation = exports.deepCopy = exports.validate = exports.buildC2JOptions = exports.buildJ2COptions = void 0;\nconst doc_path_1 = __webpack_require__(/*! doc-path */ \"(ssr)/./node_modules/doc-path/lib/path.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/json-2-csv/lib/constants.js\");\nconst dateStringRegex = /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{3}Z/, MAX_ARRAY_LENGTH = 100000;\n/**\n * Build the options to be passed to the appropriate function\n * If a user does not provide custom options, then we use our default\n * If options are provided, then we set each valid key that was passed\n */\nfunction buildJ2COptions(opts) {\n    return {\n        ...constants_1.defaultJson2CsvOptions,\n        ...opts,\n        delimiter: {\n            field: opts?.delimiter?.field ?? constants_1.defaultJson2CsvOptions.delimiter.field,\n            wrap: opts?.delimiter?.wrap || constants_1.defaultJson2CsvOptions.delimiter.wrap,\n            eol: opts?.delimiter?.eol || constants_1.defaultJson2CsvOptions.delimiter.eol,\n        },\n        fieldTitleMap: Object.create({}),\n    };\n}\nexports.buildJ2COptions = buildJ2COptions;\n/**\n * Build the options to be passed to the appropriate function\n * If a user does not provide custom options, then we use our default\n * If options are provided, then we set each valid key that was passed\n */\nfunction buildC2JOptions(opts) {\n    return {\n        ...constants_1.defaultCsv2JsonOptions,\n        ...opts,\n        delimiter: {\n            field: opts?.delimiter?.field ?? constants_1.defaultCsv2JsonOptions.delimiter.field,\n            wrap: opts?.delimiter?.wrap || constants_1.defaultCsv2JsonOptions.delimiter.wrap,\n            eol: opts?.delimiter?.eol || constants_1.defaultCsv2JsonOptions.delimiter.eol,\n        },\n    };\n}\nexports.buildC2JOptions = buildC2JOptions;\nfunction validate(data, validationFn, errorMessages) {\n    if (!data)\n        throw new Error(`${errorMessages.cannotCallOn} ${data}.`);\n    if (!validationFn(data))\n        throw new Error(errorMessages.dataCheckFailure);\n    return true;\n}\nexports.validate = validate;\n/**\n * Utility function to deep copy an object, used by the module tests\n */\nfunction deepCopy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nexports.deepCopy = deepCopy;\n/**\n * Helper function that determines whether the provided value is a representation\n *   of a string. Given the RFC4180 requirements, that means that the value is\n *   wrapped in value wrap delimiters (usually a quotation mark on each side).\n */\nfunction isStringRepresentation(fieldValue, options) {\n    const firstChar = fieldValue[0], lastIndex = fieldValue.length - 1, lastChar = fieldValue[lastIndex];\n    // If the field starts and ends with a wrap delimiter\n    return firstChar === options.delimiter.wrap && lastChar === options.delimiter.wrap;\n}\nexports.isStringRepresentation = isStringRepresentation;\n/**\n * Helper function that determines whether the provided value is a representation\n *   of a date.\n */\nfunction isDateRepresentation(fieldValue) {\n    return dateStringRegex.test(fieldValue);\n}\nexports.isDateRepresentation = isDateRepresentation;\n/**\n * Helper function that determines the schema differences between two objects.\n */\nfunction computeSchemaDifferences(schemaA, schemaB) {\n    return arrayDifference(schemaA, schemaB)\n        .concat(arrayDifference(schemaB, schemaA));\n}\nexports.computeSchemaDifferences = computeSchemaDifferences;\n/**\n * Utility function to check if a field is considered empty so that the emptyFieldValue can be used instead\n */\nfunction isEmptyField(fieldValue) {\n    return isUndefined(fieldValue) || isNull(fieldValue) || fieldValue === '';\n}\nexports.isEmptyField = isEmptyField;\n/**\n * Helper function that removes empty field values from an array.\n */\nfunction removeEmptyFields(fields) {\n    return fields.filter((field) => !isEmptyField(field));\n}\nexports.removeEmptyFields = removeEmptyFields;\n/**\n * Helper function that retrieves the next n characters from the start index in\n *   the string including the character at the start index. This is used to\n *   check if are currently at an EOL value, since it could be multiple\n *   characters in length (eg. '\\r\\n')\n */\nfunction getNCharacters(str, start, n) {\n    return str.substring(start, start + n);\n}\nexports.getNCharacters = getNCharacters;\n/**\n * The following unwind functionality is a heavily modified version of @edwincen's\n * unwind extension for lodash. Since lodash is a large package to require in,\n * and all of the required functionality was already being imported, either\n * natively or with doc-path, I decided to rewrite the majority of the logic\n * so that an additional dependency would not be required. The original code\n * with the lodash dependency can be found here:\n *\n * https://github.com/edwincen/unwind/blob/master/index.js\n */\n/**\n * Core function that unwinds an item at the provided path\n */\nfunction unwindItem(accumulator, item, fieldPath) {\n    const valueToUnwind = (0, doc_path_1.evaluatePath)(item, fieldPath);\n    let cloned = deepCopy(item);\n    if (Array.isArray(valueToUnwind) && valueToUnwind.length) {\n        valueToUnwind.forEach((val) => {\n            cloned = deepCopy(item);\n            accumulator.push((0, doc_path_1.setPath)(cloned, fieldPath, val));\n        });\n    }\n    else if (Array.isArray(valueToUnwind) && valueToUnwind.length === 0) {\n        // Push an empty string so the value is empty since there are no values\n        (0, doc_path_1.setPath)(cloned, fieldPath, '');\n        accumulator.push(cloned);\n    }\n    else {\n        accumulator.push(cloned);\n    }\n}\n/**\n * Main unwind function which takes an array and a field to unwind.\n */\nfunction unwind(array, field) {\n    const result = [];\n    array.forEach((item) => {\n        unwindItem(result, item, field);\n    });\n    return result;\n}\nexports.unwind = unwind;\n/**\n * Checks whether value can be converted to a number\n */\nfunction isNumber(value) {\n    return !isNaN(Number(value));\n}\nexports.isNumber = isNumber;\n/*\n * Helper functions which were created to remove underscorejs from this package.\n */\nfunction isString(value) {\n    return typeof value === 'string';\n}\nexports.isString = isString;\nfunction isObject(value) {\n    return typeof value === 'object';\n}\nexports.isObject = isObject;\nfunction isNull(value) {\n    return value === null;\n}\nexports.isNull = isNull;\nfunction isUndefined(value) {\n    return typeof value === 'undefined';\n}\nexports.isUndefined = isUndefined;\nfunction isError(value) {\n    // TODO(mrodrig): test this possible change\n    // return value instanceof Error;\n    return Object.prototype.toString.call(value) === '[object Error]';\n}\nexports.isError = isError;\nfunction arrayDifference(a, b) {\n    return a.filter((x) => !b.includes(x));\n}\nexports.arrayDifference = arrayDifference;\nfunction unique(array) {\n    return [...new Set(array)];\n}\nexports.unique = unique;\nfunction flatten(array) {\n    // Node 11+ - use the native array flattening function\n    if (array.flat) {\n        return array.flat();\n    }\n    // #167 - allow browsers to flatten very long 200k+ element arrays\n    if (array.length > MAX_ARRAY_LENGTH) {\n        let safeArray = [];\n        for (let a = 0; a < array.length; a += MAX_ARRAY_LENGTH) {\n            safeArray = safeArray.concat(...array.slice(a, a + MAX_ARRAY_LENGTH));\n        }\n        return safeArray;\n    }\n    return array.reduce((accumulator, value) => accumulator.concat(value), []);\n}\nexports.flatten = flatten;\n/**\n * Used to help avoid incorrect values returned by JSON.parse when converting\n * CSV back to JSON, such as '39e1804' which JSON.parse converts to Infinity\n */\nfunction isInvalid(parsedJson) {\n    return parsedJson === Infinity ||\n        parsedJson === -Infinity;\n}\nexports.isInvalid = isInvalid;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyx1QkFBdUIsR0FBRyxlQUFlLEdBQUcsbUJBQW1CLEdBQUcsY0FBYyxHQUFHLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGNBQWMsR0FBRyxzQkFBc0IsR0FBRyx5QkFBeUIsR0FBRyxvQkFBb0IsR0FBRyxnQ0FBZ0MsR0FBRyw0QkFBNEIsR0FBRyw4QkFBOEIsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyx1QkFBdUIsR0FBRyx1QkFBdUI7QUFDMWQsbUJBQW1CLG1CQUFPLENBQUMsMkRBQVU7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMscUVBQWE7QUFDekMsNEJBQTRCLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsMkJBQTJCLDRCQUE0QixFQUFFLEtBQUs7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyJEOlxcU09XTl9HSUFJQ1xcTkVYVC1XT1JLXFxIQUNLQVRIT04tM1xcVUktVVgtSEFDS0FUSE9OLU5leHRKUy1EZXNpZ24tSmFtLTIwMjQtKE1ZLUNMT05FLVBST0pFQ1QpXFxub2RlX21vZHVsZXNcXGpzb24tMi1jc3ZcXGxpYlxcdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0ludmFsaWQgPSBleHBvcnRzLmZsYXR0ZW4gPSBleHBvcnRzLnVuaXF1ZSA9IGV4cG9ydHMuYXJyYXlEaWZmZXJlbmNlID0gZXhwb3J0cy5pc0Vycm9yID0gZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGV4cG9ydHMuaXNOdWxsID0gZXhwb3J0cy5pc09iamVjdCA9IGV4cG9ydHMuaXNTdHJpbmcgPSBleHBvcnRzLmlzTnVtYmVyID0gZXhwb3J0cy51bndpbmQgPSBleHBvcnRzLmdldE5DaGFyYWN0ZXJzID0gZXhwb3J0cy5yZW1vdmVFbXB0eUZpZWxkcyA9IGV4cG9ydHMuaXNFbXB0eUZpZWxkID0gZXhwb3J0cy5jb21wdXRlU2NoZW1hRGlmZmVyZW5jZXMgPSBleHBvcnRzLmlzRGF0ZVJlcHJlc2VudGF0aW9uID0gZXhwb3J0cy5pc1N0cmluZ1JlcHJlc2VudGF0aW9uID0gZXhwb3J0cy5kZWVwQ29weSA9IGV4cG9ydHMudmFsaWRhdGUgPSBleHBvcnRzLmJ1aWxkQzJKT3B0aW9ucyA9IGV4cG9ydHMuYnVpbGRKMkNPcHRpb25zID0gdm9pZCAwO1xuY29uc3QgZG9jX3BhdGhfMSA9IHJlcXVpcmUoXCJkb2MtcGF0aFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZGF0ZVN0cmluZ1JlZ2V4ID0gL1xcZHs0fS1cXGR7Mn0tXFxkezJ9VFxcZHsyfTpcXGR7Mn06XFxkezJ9LlxcZHszfVovLCBNQVhfQVJSQVlfTEVOR1RIID0gMTAwMDAwO1xuLyoqXG4gKiBCdWlsZCB0aGUgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIGFwcHJvcHJpYXRlIGZ1bmN0aW9uXG4gKiBJZiBhIHVzZXIgZG9lcyBub3QgcHJvdmlkZSBjdXN0b20gb3B0aW9ucywgdGhlbiB3ZSB1c2Ugb3VyIGRlZmF1bHRcbiAqIElmIG9wdGlvbnMgYXJlIHByb3ZpZGVkLCB0aGVuIHdlIHNldCBlYWNoIHZhbGlkIGtleSB0aGF0IHdhcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gYnVpbGRKMkNPcHRpb25zKG9wdHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5jb25zdGFudHNfMS5kZWZhdWx0SnNvbjJDc3ZPcHRpb25zLFxuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBkZWxpbWl0ZXI6IHtcbiAgICAgICAgICAgIGZpZWxkOiBvcHRzPy5kZWxpbWl0ZXI/LmZpZWxkID8/IGNvbnN0YW50c18xLmRlZmF1bHRKc29uMkNzdk9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkLFxuICAgICAgICAgICAgd3JhcDogb3B0cz8uZGVsaW1pdGVyPy53cmFwIHx8IGNvbnN0YW50c18xLmRlZmF1bHRKc29uMkNzdk9wdGlvbnMuZGVsaW1pdGVyLndyYXAsXG4gICAgICAgICAgICBlb2w6IG9wdHM/LmRlbGltaXRlcj8uZW9sIHx8IGNvbnN0YW50c18xLmRlZmF1bHRKc29uMkNzdk9wdGlvbnMuZGVsaW1pdGVyLmVvbCxcbiAgICAgICAgfSxcbiAgICAgICAgZmllbGRUaXRsZU1hcDogT2JqZWN0LmNyZWF0ZSh7fSksXG4gICAgfTtcbn1cbmV4cG9ydHMuYnVpbGRKMkNPcHRpb25zID0gYnVpbGRKMkNPcHRpb25zO1xuLyoqXG4gKiBCdWlsZCB0aGUgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIGFwcHJvcHJpYXRlIGZ1bmN0aW9uXG4gKiBJZiBhIHVzZXIgZG9lcyBub3QgcHJvdmlkZSBjdXN0b20gb3B0aW9ucywgdGhlbiB3ZSB1c2Ugb3VyIGRlZmF1bHRcbiAqIElmIG9wdGlvbnMgYXJlIHByb3ZpZGVkLCB0aGVuIHdlIHNldCBlYWNoIHZhbGlkIGtleSB0aGF0IHdhcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gYnVpbGRDMkpPcHRpb25zKG9wdHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5jb25zdGFudHNfMS5kZWZhdWx0Q3N2Mkpzb25PcHRpb25zLFxuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBkZWxpbWl0ZXI6IHtcbiAgICAgICAgICAgIGZpZWxkOiBvcHRzPy5kZWxpbWl0ZXI/LmZpZWxkID8/IGNvbnN0YW50c18xLmRlZmF1bHRDc3YySnNvbk9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkLFxuICAgICAgICAgICAgd3JhcDogb3B0cz8uZGVsaW1pdGVyPy53cmFwIHx8IGNvbnN0YW50c18xLmRlZmF1bHRDc3YySnNvbk9wdGlvbnMuZGVsaW1pdGVyLndyYXAsXG4gICAgICAgICAgICBlb2w6IG9wdHM/LmRlbGltaXRlcj8uZW9sIHx8IGNvbnN0YW50c18xLmRlZmF1bHRDc3YySnNvbk9wdGlvbnMuZGVsaW1pdGVyLmVvbCxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0cy5idWlsZEMySk9wdGlvbnMgPSBidWlsZEMySk9wdGlvbnM7XG5mdW5jdGlvbiB2YWxpZGF0ZShkYXRhLCB2YWxpZGF0aW9uRm4sIGVycm9yTWVzc2FnZXMpIHtcbiAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtlcnJvck1lc3NhZ2VzLmNhbm5vdENhbGxPbn0gJHtkYXRhfS5gKTtcbiAgICBpZiAoIXZhbGlkYXRpb25GbihkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZXMuZGF0YUNoZWNrRmFpbHVyZSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZGVlcCBjb3B5IGFuIG9iamVjdCwgdXNlZCBieSB0aGUgbW9kdWxlIHRlc3RzXG4gKi9cbmZ1bmN0aW9uIGRlZXBDb3B5KG9iaikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufVxuZXhwb3J0cy5kZWVwQ29weSA9IGRlZXBDb3B5O1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGEgcmVwcmVzZW50YXRpb25cbiAqICAgb2YgYSBzdHJpbmcuIEdpdmVuIHRoZSBSRkM0MTgwIHJlcXVpcmVtZW50cywgdGhhdCBtZWFucyB0aGF0IHRoZSB2YWx1ZSBpc1xuICogICB3cmFwcGVkIGluIHZhbHVlIHdyYXAgZGVsaW1pdGVycyAodXN1YWxseSBhIHF1b3RhdGlvbiBtYXJrIG9uIGVhY2ggc2lkZSkuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nUmVwcmVzZW50YXRpb24oZmllbGRWYWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZpcnN0Q2hhciA9IGZpZWxkVmFsdWVbMF0sIGxhc3RJbmRleCA9IGZpZWxkVmFsdWUubGVuZ3RoIC0gMSwgbGFzdENoYXIgPSBmaWVsZFZhbHVlW2xhc3RJbmRleF07XG4gICAgLy8gSWYgdGhlIGZpZWxkIHN0YXJ0cyBhbmQgZW5kcyB3aXRoIGEgd3JhcCBkZWxpbWl0ZXJcbiAgICByZXR1cm4gZmlyc3RDaGFyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmIGxhc3RDaGFyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwO1xufVxuZXhwb3J0cy5pc1N0cmluZ1JlcHJlc2VudGF0aW9uID0gaXNTdHJpbmdSZXByZXNlbnRhdGlvbjtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBhIHJlcHJlc2VudGF0aW9uXG4gKiAgIG9mIGEgZGF0ZS5cbiAqL1xuZnVuY3Rpb24gaXNEYXRlUmVwcmVzZW50YXRpb24oZmllbGRWYWx1ZSkge1xuICAgIHJldHVybiBkYXRlU3RyaW5nUmVnZXgudGVzdChmaWVsZFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNEYXRlUmVwcmVzZW50YXRpb24gPSBpc0RhdGVSZXByZXNlbnRhdGlvbjtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB0aGUgc2NoZW1hIGRpZmZlcmVuY2VzIGJldHdlZW4gdHdvIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVTY2hlbWFEaWZmZXJlbmNlcyhzY2hlbWFBLCBzY2hlbWFCKSB7XG4gICAgcmV0dXJuIGFycmF5RGlmZmVyZW5jZShzY2hlbWFBLCBzY2hlbWFCKVxuICAgICAgICAuY29uY2F0KGFycmF5RGlmZmVyZW5jZShzY2hlbWFCLCBzY2hlbWFBKSk7XG59XG5leHBvcnRzLmNvbXB1dGVTY2hlbWFEaWZmZXJlbmNlcyA9IGNvbXB1dGVTY2hlbWFEaWZmZXJlbmNlcztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBjaGVjayBpZiBhIGZpZWxkIGlzIGNvbnNpZGVyZWQgZW1wdHkgc28gdGhhdCB0aGUgZW1wdHlGaWVsZFZhbHVlIGNhbiBiZSB1c2VkIGluc3RlYWRcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eUZpZWxkKGZpZWxkVmFsdWUpIHtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQoZmllbGRWYWx1ZSkgfHwgaXNOdWxsKGZpZWxkVmFsdWUpIHx8IGZpZWxkVmFsdWUgPT09ICcnO1xufVxuZXhwb3J0cy5pc0VtcHR5RmllbGQgPSBpc0VtcHR5RmllbGQ7XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IHJlbW92ZXMgZW1wdHkgZmllbGQgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUVtcHR5RmllbGRzKGZpZWxkcykge1xuICAgIHJldHVybiBmaWVsZHMuZmlsdGVyKChmaWVsZCkgPT4gIWlzRW1wdHlGaWVsZChmaWVsZCkpO1xufVxuZXhwb3J0cy5yZW1vdmVFbXB0eUZpZWxkcyA9IHJlbW92ZUVtcHR5RmllbGRzO1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZXRyaWV2ZXMgdGhlIG5leHQgbiBjaGFyYWN0ZXJzIGZyb20gdGhlIHN0YXJ0IGluZGV4IGluXG4gKiAgIHRoZSBzdHJpbmcgaW5jbHVkaW5nIHRoZSBjaGFyYWN0ZXIgYXQgdGhlIHN0YXJ0IGluZGV4LiBUaGlzIGlzIHVzZWQgdG9cbiAqICAgY2hlY2sgaWYgYXJlIGN1cnJlbnRseSBhdCBhbiBFT0wgdmFsdWUsIHNpbmNlIGl0IGNvdWxkIGJlIG11bHRpcGxlXG4gKiAgIGNoYXJhY3RlcnMgaW4gbGVuZ3RoIChlZy4gJ1xcclxcbicpXG4gKi9cbmZ1bmN0aW9uIGdldE5DaGFyYWN0ZXJzKHN0ciwgc3RhcnQsIG4pIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZyhzdGFydCwgc3RhcnQgKyBuKTtcbn1cbmV4cG9ydHMuZ2V0TkNoYXJhY3RlcnMgPSBnZXROQ2hhcmFjdGVycztcbi8qKlxuICogVGhlIGZvbGxvd2luZyB1bndpbmQgZnVuY3Rpb25hbGl0eSBpcyBhIGhlYXZpbHkgbW9kaWZpZWQgdmVyc2lvbiBvZiBAZWR3aW5jZW4nc1xuICogdW53aW5kIGV4dGVuc2lvbiBmb3IgbG9kYXNoLiBTaW5jZSBsb2Rhc2ggaXMgYSBsYXJnZSBwYWNrYWdlIHRvIHJlcXVpcmUgaW4sXG4gKiBhbmQgYWxsIG9mIHRoZSByZXF1aXJlZCBmdW5jdGlvbmFsaXR5IHdhcyBhbHJlYWR5IGJlaW5nIGltcG9ydGVkLCBlaXRoZXJcbiAqIG5hdGl2ZWx5IG9yIHdpdGggZG9jLXBhdGgsIEkgZGVjaWRlZCB0byByZXdyaXRlIHRoZSBtYWpvcml0eSBvZiB0aGUgbG9naWNcbiAqIHNvIHRoYXQgYW4gYWRkaXRpb25hbCBkZXBlbmRlbmN5IHdvdWxkIG5vdCBiZSByZXF1aXJlZC4gVGhlIG9yaWdpbmFsIGNvZGVcbiAqIHdpdGggdGhlIGxvZGFzaCBkZXBlbmRlbmN5IGNhbiBiZSBmb3VuZCBoZXJlOlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9lZHdpbmNlbi91bndpbmQvYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAqL1xuLyoqXG4gKiBDb3JlIGZ1bmN0aW9uIHRoYXQgdW53aW5kcyBhbiBpdGVtIGF0IHRoZSBwcm92aWRlZCBwYXRoXG4gKi9cbmZ1bmN0aW9uIHVud2luZEl0ZW0oYWNjdW11bGF0b3IsIGl0ZW0sIGZpZWxkUGF0aCkge1xuICAgIGNvbnN0IHZhbHVlVG9VbndpbmQgPSAoMCwgZG9jX3BhdGhfMS5ldmFsdWF0ZVBhdGgpKGl0ZW0sIGZpZWxkUGF0aCk7XG4gICAgbGV0IGNsb25lZCA9IGRlZXBDb3B5KGl0ZW0pO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlVG9VbndpbmQpICYmIHZhbHVlVG9VbndpbmQubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlVG9VbndpbmQuZm9yRWFjaCgodmFsKSA9PiB7XG4gICAgICAgICAgICBjbG9uZWQgPSBkZWVwQ29weShpdGVtKTtcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yLnB1c2goKDAsIGRvY19wYXRoXzEuc2V0UGF0aCkoY2xvbmVkLCBmaWVsZFBhdGgsIHZhbCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVRvVW53aW5kKSAmJiB2YWx1ZVRvVW53aW5kLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBQdXNoIGFuIGVtcHR5IHN0cmluZyBzbyB0aGUgdmFsdWUgaXMgZW1wdHkgc2luY2UgdGhlcmUgYXJlIG5vIHZhbHVlc1xuICAgICAgICAoMCwgZG9jX3BhdGhfMS5zZXRQYXRoKShjbG9uZWQsIGZpZWxkUGF0aCwgJycpO1xuICAgICAgICBhY2N1bXVsYXRvci5wdXNoKGNsb25lZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhY2N1bXVsYXRvci5wdXNoKGNsb25lZCk7XG4gICAgfVxufVxuLyoqXG4gKiBNYWluIHVud2luZCBmdW5jdGlvbiB3aGljaCB0YWtlcyBhbiBhcnJheSBhbmQgYSBmaWVsZCB0byB1bndpbmQuXG4gKi9cbmZ1bmN0aW9uIHVud2luZChhcnJheSwgZmllbGQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBhcnJheS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIHVud2luZEl0ZW0ocmVzdWx0LCBpdGVtLCBmaWVsZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMudW53aW5kID0gdW53aW5kO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB2YWx1ZSBjYW4gYmUgY29udmVydGVkIHRvIGEgbnVtYmVyXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuICFpc05hTihOdW1iZXIodmFsdWUpKTtcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIHdoaWNoIHdlcmUgY3JlYXRlZCB0byByZW1vdmUgdW5kZXJzY29yZWpzIGZyb20gdGhpcyBwYWNrYWdlLlxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jztcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbmZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbmZ1bmN0aW9uIGlzRXJyb3IodmFsdWUpIHtcbiAgICAvLyBUT0RPKG1yb2RyaWcpOiB0ZXN0IHRoaXMgcG9zc2libGUgY2hhbmdlXG4gICAgLy8gcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRXJyb3I7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEVycm9yXSc7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuZnVuY3Rpb24gYXJyYXlEaWZmZXJlbmNlKGEsIGIpIHtcbiAgICByZXR1cm4gYS5maWx0ZXIoKHgpID0+ICFiLmluY2x1ZGVzKHgpKTtcbn1cbmV4cG9ydHMuYXJyYXlEaWZmZXJlbmNlID0gYXJyYXlEaWZmZXJlbmNlO1xuZnVuY3Rpb24gdW5pcXVlKGFycmF5KSB7XG4gICAgcmV0dXJuIFsuLi5uZXcgU2V0KGFycmF5KV07XG59XG5leHBvcnRzLnVuaXF1ZSA9IHVuaXF1ZTtcbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgICAvLyBOb2RlIDExKyAtIHVzZSB0aGUgbmF0aXZlIGFycmF5IGZsYXR0ZW5pbmcgZnVuY3Rpb25cbiAgICBpZiAoYXJyYXkuZmxhdCkge1xuICAgICAgICByZXR1cm4gYXJyYXkuZmxhdCgpO1xuICAgIH1cbiAgICAvLyAjMTY3IC0gYWxsb3cgYnJvd3NlcnMgdG8gZmxhdHRlbiB2ZXJ5IGxvbmcgMjAwaysgZWxlbWVudCBhcnJheXNcbiAgICBpZiAoYXJyYXkubGVuZ3RoID4gTUFYX0FSUkFZX0xFTkdUSCkge1xuICAgICAgICBsZXQgc2FmZUFycmF5ID0gW107XG4gICAgICAgIGZvciAobGV0IGEgPSAwOyBhIDwgYXJyYXkubGVuZ3RoOyBhICs9IE1BWF9BUlJBWV9MRU5HVEgpIHtcbiAgICAgICAgICAgIHNhZmVBcnJheSA9IHNhZmVBcnJheS5jb25jYXQoLi4uYXJyYXkuc2xpY2UoYSwgYSArIE1BWF9BUlJBWV9MRU5HVEgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2FmZUFycmF5O1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXkucmVkdWNlKChhY2N1bXVsYXRvciwgdmFsdWUpID0+IGFjY3VtdWxhdG9yLmNvbmNhdCh2YWx1ZSksIFtdKTtcbn1cbmV4cG9ydHMuZmxhdHRlbiA9IGZsYXR0ZW47XG4vKipcbiAqIFVzZWQgdG8gaGVscCBhdm9pZCBpbmNvcnJlY3QgdmFsdWVzIHJldHVybmVkIGJ5IEpTT04ucGFyc2Ugd2hlbiBjb252ZXJ0aW5nXG4gKiBDU1YgYmFjayB0byBKU09OLCBzdWNoIGFzICczOWUxODA0JyB3aGljaCBKU09OLnBhcnNlIGNvbnZlcnRzIHRvIEluZmluaXR5XG4gKi9cbmZ1bmN0aW9uIGlzSW52YWxpZChwYXJzZWRKc29uKSB7XG4gICAgcmV0dXJuIHBhcnNlZEpzb24gPT09IEluZmluaXR5IHx8XG4gICAgICAgIHBhcnNlZEpzb24gPT09IC1JbmZpbml0eTtcbn1cbmV4cG9ydHMuaXNJbnZhbGlkID0gaXNJbnZhbGlkO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/json-2-csv/lib/utils.js\n");

/***/ })

};
;